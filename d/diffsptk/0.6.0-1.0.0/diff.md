# Comparing `tmp/diffsptk-0.6.0-py3-none-any.whl.zip` & `tmp/diffsptk-1.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,84 +1,91 @@
-Zip file size: 117424 bytes, number of entries: 82
--rw-r--r--  2.0 unx      111 b- defN 23-Jan-26 12:24 diffsptk/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 23-Feb-28 02:10 diffsptk/version.py
--rw-r--r--  2.0 unx     4260 b- defN 23-Feb-28 02:10 diffsptk/core/__init__.py
--rw-r--r--  2.0 unx     3318 b- defN 23-Jan-26 12:10 diffsptk/core/acorr.py
--rw-r--r--  2.0 unx     2667 b- defN 23-Jan-31 10:38 diffsptk/core/b2mc.py
--rw-r--r--  2.0 unx     2623 b- defN 23-Feb-07 05:04 diffsptk/core/c2acr.py
--rw-r--r--  2.0 unx     3018 b- defN 23-Jan-26 12:24 diffsptk/core/c2mpir.py
--rw-r--r--  2.0 unx     2737 b- defN 23-Feb-07 03:17 diffsptk/core/c2ndps.py
--rw-r--r--  2.0 unx     3399 b- defN 23-Feb-28 02:10 diffsptk/core/cdist.py
--rw-r--r--  2.0 unx     4061 b- defN 23-Jan-31 10:38 diffsptk/core/cqt.py
--rw-r--r--  2.0 unx     2453 b- defN 23-Feb-07 03:17 diffsptk/core/dct.py
--rw-r--r--  2.0 unx     2469 b- defN 22-Mar-29 07:41 diffsptk/core/decimate.py
--rw-r--r--  2.0 unx     3078 b- defN 23-Feb-07 05:04 diffsptk/core/delay.py
--rw-r--r--  2.0 unx     5422 b- defN 23-Feb-28 02:10 diffsptk/core/delta.py
--rw-r--r--  2.0 unx     3203 b- defN 22-Aug-30 01:32 diffsptk/core/dequantize.py
--rw-r--r--  2.0 unx     3673 b- defN 22-Apr-27 11:48 diffsptk/core/df2.py
--rw-r--r--  2.0 unx     3534 b- defN 23-Jan-31 10:38 diffsptk/core/dfs.py
--rw-r--r--  2.0 unx     2483 b- defN 22-Nov-22 03:27 diffsptk/core/entropy.py
--rw-r--r--  2.0 unx     4282 b- defN 23-Feb-28 02:10 diffsptk/core/excite.py
--rw-r--r--  2.0 unx     5193 b- defN 23-Feb-07 03:18 diffsptk/core/fbank.py
--rw-r--r--  2.0 unx     3617 b- defN 23-Feb-07 03:18 diffsptk/core/fftcep.py
--rw-r--r--  2.0 unx     3180 b- defN 23-Feb-07 01:08 diffsptk/core/frame.py
--rw-r--r--  2.0 unx     3211 b- defN 23-Feb-03 08:05 diffsptk/core/freqt.py
--rw-r--r--  2.0 unx     2862 b- defN 23-Feb-07 05:04 diffsptk/core/gnorm.py
--rw-r--r--  2.0 unx     3693 b- defN 23-Feb-07 03:15 diffsptk/core/grpdelay.py
--rw-r--r--  2.0 unx     2327 b- defN 23-Jan-31 10:38 diffsptk/core/idct.py
--rw-r--r--  2.0 unx     2959 b- defN 23-Feb-07 05:04 diffsptk/core/ignorm.py
--rw-r--r--  2.0 unx     3622 b- defN 23-Feb-28 02:10 diffsptk/core/imglsadf.py
--rw-r--r--  2.0 unx     2623 b- defN 23-Feb-03 11:38 diffsptk/core/imsvq.py
--rw-r--r--  2.0 unx     2653 b- defN 22-Apr-17 12:49 diffsptk/core/interpolate.py
--rw-r--r--  2.0 unx     3647 b- defN 23-Jan-31 10:38 diffsptk/core/ipqmf.py
--rw-r--r--  2.0 unx     3069 b- defN 23-Feb-07 05:04 diffsptk/core/istft.py
--rw-r--r--  2.0 unx     2445 b- defN 23-Jan-31 10:38 diffsptk/core/iulaw.py
--rw-r--r--  2.0 unx     2534 b- defN 23-Feb-03 08:05 diffsptk/core/ivq.py
--rw-r--r--  2.0 unx     2391 b- defN 22-Jul-01 11:15 diffsptk/core/lar2par.py
--rw-r--r--  2.0 unx     6420 b- defN 23-Feb-28 02:10 diffsptk/core/lbg.py
--rw-r--r--  2.0 unx     2617 b- defN 23-Feb-28 02:10 diffsptk/core/levdur.py
--rw-r--r--  2.0 unx     3434 b- defN 23-Jan-31 10:38 diffsptk/core/linear_intpl.py
--rw-r--r--  2.0 unx     2488 b- defN 23-Feb-28 02:10 diffsptk/core/lpc.py
--rw-r--r--  2.0 unx     3729 b- defN 23-Feb-28 02:10 diffsptk/core/lpc2par.py
--rw-r--r--  2.0 unx     3101 b- defN 23-Feb-28 02:10 diffsptk/core/lpccheck.py
--rw-r--r--  2.0 unx     2660 b- defN 23-Jan-31 10:38 diffsptk/core/mc2b.py
--rw-r--r--  2.0 unx     4946 b- defN 23-Jan-31 10:38 diffsptk/core/mcep.py
--rw-r--r--  2.0 unx     3712 b- defN 23-Feb-28 02:10 diffsptk/core/mcpf.py
--rw-r--r--  2.0 unx     4517 b- defN 23-Jan-31 10:38 diffsptk/core/mfcc.py
--rw-r--r--  2.0 unx     8938 b- defN 23-Jan-31 10:38 diffsptk/core/mgc2mgc.py
--rw-r--r--  2.0 unx     4748 b- defN 23-Feb-07 06:39 diffsptk/core/mgc2sp.py
--rw-r--r--  2.0 unx     8823 b- defN 23-Jan-31 10:38 diffsptk/core/mgcep.py
--rw-r--r--  2.0 unx     8339 b- defN 23-Feb-28 02:10 diffsptk/core/mglsadf.py
--rw-r--r--  2.0 unx     4248 b- defN 23-Jan-31 10:38 diffsptk/core/mlpg.py
--rw-r--r--  2.0 unx     3043 b- defN 23-Jan-26 12:24 diffsptk/core/mpir2c.py
--rw-r--r--  2.0 unx     3781 b- defN 23-Feb-06 14:16 diffsptk/core/msvq.py
--rw-r--r--  2.0 unx     2782 b- defN 23-Jan-31 10:38 diffsptk/core/ndps2c.py
--rw-r--r--  2.0 unx     2571 b- defN 22-Apr-17 12:49 diffsptk/core/norm0.py
--rw-r--r--  2.0 unx     2468 b- defN 22-Jul-01 11:15 diffsptk/core/par2lar.py
--rw-r--r--  2.0 unx     2821 b- defN 23-Feb-28 02:10 diffsptk/core/par2lpc.py
--rw-r--r--  2.0 unx     3040 b- defN 23-Feb-28 02:10 diffsptk/core/pca.py
--rw-r--r--  2.0 unx     3034 b- defN 22-Aug-30 01:32 diffsptk/core/phase.py
--rw-r--r--  2.0 unx     8549 b- defN 23-Feb-28 02:10 diffsptk/core/pitch.py
--rw-r--r--  2.0 unx     5183 b- defN 23-Jan-31 10:38 diffsptk/core/pqmf.py
--rw-r--r--  2.0 unx     3488 b- defN 22-Aug-30 01:32 diffsptk/core/quantize.py
--rw-r--r--  2.0 unx     2744 b- defN 23-Feb-28 02:10 diffsptk/core/rmse.py
--rw-r--r--  2.0 unx     4580 b- defN 23-Feb-03 15:47 diffsptk/core/root_pol.py
--rw-r--r--  2.0 unx     8753 b- defN 23-Feb-07 01:22 diffsptk/core/smcep.py
--rw-r--r--  2.0 unx     3535 b- defN 23-Feb-28 02:10 diffsptk/core/snr.py
--rw-r--r--  2.0 unx     5152 b- defN 22-Jul-01 11:15 diffsptk/core/sopr.py
--rw-r--r--  2.0 unx     3810 b- defN 22-Aug-30 01:32 diffsptk/core/spec.py
--rw-r--r--  2.0 unx     3707 b- defN 23-Feb-07 05:04 diffsptk/core/stft.py
--rw-r--r--  2.0 unx     2412 b- defN 23-Jan-31 10:38 diffsptk/core/ulaw.py
--rw-r--r--  2.0 unx     4126 b- defN 23-Feb-28 02:10 diffsptk/core/unframe.py
--rw-r--r--  2.0 unx     3417 b- defN 23-Feb-06 14:16 diffsptk/core/vq.py
--rw-r--r--  2.0 unx     4069 b- defN 23-Jan-31 10:38 diffsptk/core/window.py
--rw-r--r--  2.0 unx     2617 b- defN 23-Feb-28 02:10 diffsptk/core/zcross.py
--rw-r--r--  2.0 unx     3109 b- defN 22-Nov-22 02:22 diffsptk/core/zerodf.py
--rw-r--r--  2.0 unx      101 b- defN 23-Jan-31 06:09 diffsptk/misc/__init__.py
--rw-r--r--  2.0 unx     6071 b- defN 23-Feb-28 02:10 diffsptk/misc/signals.py
--rw-r--r--  2.0 unx     6716 b- defN 23-Feb-28 02:10 diffsptk/misc/utils.py
--rw-r--r--  2.0 unx    11358 b- defN 23-Feb-28 02:24 diffsptk-0.6.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     5591 b- defN 23-Feb-28 02:24 diffsptk-0.6.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Feb-28 02:24 diffsptk-0.6.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 23-Feb-28 02:24 diffsptk-0.6.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     6502 b- defN 23-Feb-28 02:24 diffsptk-0.6.0.dist-info/RECORD
-82 files, 308790 bytes uncompressed, 107390 bytes compressed:  65.2%
+Zip file size: 136214 bytes, number of entries: 89
+-rw-r--r--  2.0 unx      111 b- defN 20-Feb-02 00:00 diffsptk/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 20-Feb-02 00:00 diffsptk/version.py
+-rw-r--r--  2.0 unx     4623 b- defN 20-Feb-02 00:00 diffsptk/core/__init__.py
+-rw-r--r--  2.0 unx     3319 b- defN 20-Feb-02 00:00 diffsptk/core/acorr.py
+-rw-r--r--  2.0 unx    12056 b- defN 20-Feb-02 00:00 diffsptk/core/ap.py
+-rw-r--r--  2.0 unx     2669 b- defN 20-Feb-02 00:00 diffsptk/core/b2mc.py
+-rw-r--r--  2.0 unx     2623 b- defN 20-Feb-02 00:00 diffsptk/core/c2acr.py
+-rw-r--r--  2.0 unx     2920 b- defN 20-Feb-02 00:00 diffsptk/core/c2mpir.py
+-rw-r--r--  2.0 unx     2737 b- defN 20-Feb-02 00:00 diffsptk/core/c2ndps.py
+-rw-r--r--  2.0 unx     3399 b- defN 20-Feb-02 00:00 diffsptk/core/cdist.py
+-rw-r--r--  2.0 unx     4061 b- defN 20-Feb-02 00:00 diffsptk/core/cqt.py
+-rw-r--r--  2.0 unx     2650 b- defN 20-Feb-02 00:00 diffsptk/core/dct.py
+-rw-r--r--  2.0 unx     2469 b- defN 20-Feb-02 00:00 diffsptk/core/decimate.py
+-rw-r--r--  2.0 unx     3078 b- defN 20-Feb-02 00:00 diffsptk/core/delay.py
+-rw-r--r--  2.0 unx     5893 b- defN 20-Feb-02 00:00 diffsptk/core/delta.py
+-rw-r--r--  2.0 unx     3203 b- defN 20-Feb-02 00:00 diffsptk/core/dequantize.py
+-rw-r--r--  2.0 unx     3603 b- defN 20-Feb-02 00:00 diffsptk/core/df2.py
+-rw-r--r--  2.0 unx     3422 b- defN 20-Feb-02 00:00 diffsptk/core/dfs.py
+-rw-r--r--  2.0 unx     2483 b- defN 20-Feb-02 00:00 diffsptk/core/entropy.py
+-rw-r--r--  2.0 unx     4408 b- defN 20-Feb-02 00:00 diffsptk/core/excite.py
+-rw-r--r--  2.0 unx     5100 b- defN 20-Feb-02 00:00 diffsptk/core/fbank.py
+-rw-r--r--  2.0 unx     3343 b- defN 20-Feb-02 00:00 diffsptk/core/fftcep.py
+-rw-r--r--  2.0 unx     3180 b- defN 20-Feb-02 00:00 diffsptk/core/frame.py
+-rw-r--r--  2.0 unx     3213 b- defN 20-Feb-02 00:00 diffsptk/core/freqt.py
+-rw-r--r--  2.0 unx     4657 b- defN 20-Feb-02 00:00 diffsptk/core/freqt2.py
+-rw-r--r--  2.0 unx    12168 b- defN 20-Feb-02 00:00 diffsptk/core/gmm.py
+-rw-r--r--  2.0 unx     2862 b- defN 20-Feb-02 00:00 diffsptk/core/gnorm.py
+-rw-r--r--  2.0 unx     3667 b- defN 20-Feb-02 00:00 diffsptk/core/grpdelay.py
+-rw-r--r--  2.0 unx     2327 b- defN 20-Feb-02 00:00 diffsptk/core/idct.py
+-rw-r--r--  2.0 unx     3666 b- defN 20-Feb-02 00:00 diffsptk/core/ifreqt2.py
+-rw-r--r--  2.0 unx     2959 b- defN 20-Feb-02 00:00 diffsptk/core/ignorm.py
+-rw-r--r--  2.0 unx     2788 b- defN 20-Feb-02 00:00 diffsptk/core/imglsadf.py
+-rw-r--r--  2.0 unx     2623 b- defN 20-Feb-02 00:00 diffsptk/core/imsvq.py
+-rw-r--r--  2.0 unx     2653 b- defN 20-Feb-02 00:00 diffsptk/core/interpolate.py
+-rw-r--r--  2.0 unx     4145 b- defN 20-Feb-02 00:00 diffsptk/core/ipqmf.py
+-rw-r--r--  2.0 unx     3086 b- defN 20-Feb-02 00:00 diffsptk/core/istft.py
+-rw-r--r--  2.0 unx     2445 b- defN 20-Feb-02 00:00 diffsptk/core/iulaw.py
+-rw-r--r--  2.0 unx     2534 b- defN 20-Feb-02 00:00 diffsptk/core/ivq.py
+-rw-r--r--  2.0 unx     2391 b- defN 20-Feb-02 00:00 diffsptk/core/lar2par.py
+-rw-r--r--  2.0 unx     6740 b- defN 20-Feb-02 00:00 diffsptk/core/lbg.py
+-rw-r--r--  2.0 unx     2781 b- defN 20-Feb-02 00:00 diffsptk/core/levdur.py
+-rw-r--r--  2.0 unx     3144 b- defN 20-Feb-02 00:00 diffsptk/core/linear_intpl.py
+-rw-r--r--  2.0 unx     2468 b- defN 20-Feb-02 00:00 diffsptk/core/lpc.py
+-rw-r--r--  2.0 unx     3691 b- defN 20-Feb-02 00:00 diffsptk/core/lpc2par.py
+-rw-r--r--  2.0 unx     3099 b- defN 20-Feb-02 00:00 diffsptk/core/lpccheck.py
+-rw-r--r--  2.0 unx     4956 b- defN 20-Feb-02 00:00 diffsptk/core/magic_intpl.py
+-rw-r--r--  2.0 unx     2662 b- defN 20-Feb-02 00:00 diffsptk/core/mc2b.py
+-rw-r--r--  2.0 unx     4946 b- defN 20-Feb-02 00:00 diffsptk/core/mcep.py
+-rw-r--r--  2.0 unx     3642 b- defN 20-Feb-02 00:00 diffsptk/core/mcpf.py
+-rw-r--r--  2.0 unx     4517 b- defN 20-Feb-02 00:00 diffsptk/core/mfcc.py
+-rw-r--r--  2.0 unx     9773 b- defN 20-Feb-02 00:00 diffsptk/core/mgc2mgc.py
+-rw-r--r--  2.0 unx     4873 b- defN 20-Feb-02 00:00 diffsptk/core/mgc2sp.py
+-rw-r--r--  2.0 unx     8823 b- defN 20-Feb-02 00:00 diffsptk/core/mgcep.py
+-rw-r--r--  2.0 unx    12486 b- defN 20-Feb-02 00:00 diffsptk/core/mglsadf.py
+-rw-r--r--  2.0 unx     4248 b- defN 20-Feb-02 00:00 diffsptk/core/mlpg.py
+-rw-r--r--  2.0 unx     5724 b- defN 20-Feb-02 00:00 diffsptk/core/mlsacheck.py
+-rw-r--r--  2.0 unx     2945 b- defN 20-Feb-02 00:00 diffsptk/core/mpir2c.py
+-rw-r--r--  2.0 unx     3745 b- defN 20-Feb-02 00:00 diffsptk/core/msvq.py
+-rw-r--r--  2.0 unx     2782 b- defN 20-Feb-02 00:00 diffsptk/core/ndps2c.py
+-rw-r--r--  2.0 unx     2571 b- defN 20-Feb-02 00:00 diffsptk/core/norm0.py
+-rw-r--r--  2.0 unx     2468 b- defN 20-Feb-02 00:00 diffsptk/core/par2lar.py
+-rw-r--r--  2.0 unx     2821 b- defN 20-Feb-02 00:00 diffsptk/core/par2lpc.py
+-rw-r--r--  2.0 unx     3040 b- defN 20-Feb-02 00:00 diffsptk/core/pca.py
+-rw-r--r--  2.0 unx     3040 b- defN 20-Feb-02 00:00 diffsptk/core/phase.py
+-rw-r--r--  2.0 unx     8574 b- defN 20-Feb-02 00:00 diffsptk/core/pitch.py
+-rw-r--r--  2.0 unx     3235 b- defN 20-Feb-02 00:00 diffsptk/core/poledf.py
+-rw-r--r--  2.0 unx     6698 b- defN 20-Feb-02 00:00 diffsptk/core/pqmf.py
+-rw-r--r--  2.0 unx     3488 b- defN 20-Feb-02 00:00 diffsptk/core/quantize.py
+-rw-r--r--  2.0 unx     3322 b- defN 20-Feb-02 00:00 diffsptk/core/rlevdur.py
+-rw-r--r--  2.0 unx     2744 b- defN 20-Feb-02 00:00 diffsptk/core/rmse.py
+-rw-r--r--  2.0 unx     4595 b- defN 20-Feb-02 00:00 diffsptk/core/root_pol.py
+-rw-r--r--  2.0 unx     6134 b- defN 20-Feb-02 00:00 diffsptk/core/smcep.py
+-rw-r--r--  2.0 unx     3535 b- defN 20-Feb-02 00:00 diffsptk/core/snr.py
+-rw-r--r--  2.0 unx     3834 b- defN 20-Feb-02 00:00 diffsptk/core/spec.py
+-rw-r--r--  2.0 unx     3707 b- defN 20-Feb-02 00:00 diffsptk/core/stft.py
+-rw-r--r--  2.0 unx     2412 b- defN 20-Feb-02 00:00 diffsptk/core/ulaw.py
+-rw-r--r--  2.0 unx     4129 b- defN 20-Feb-02 00:00 diffsptk/core/unframe.py
+-rw-r--r--  2.0 unx     3381 b- defN 20-Feb-02 00:00 diffsptk/core/vq.py
+-rw-r--r--  2.0 unx     4069 b- defN 20-Feb-02 00:00 diffsptk/core/window.py
+-rw-r--r--  2.0 unx     4693 b- defN 20-Feb-02 00:00 diffsptk/core/yingram.py
+-rw-r--r--  2.0 unx     2617 b- defN 20-Feb-02 00:00 diffsptk/core/zcross.py
+-rw-r--r--  2.0 unx     3110 b- defN 20-Feb-02 00:00 diffsptk/core/zerodf.py
+-rw-r--r--  2.0 unx      101 b- defN 20-Feb-02 00:00 diffsptk/misc/__init__.py
+-rw-r--r--  2.0 unx     6881 b- defN 20-Feb-02 00:00 diffsptk/misc/signals.py
+-rw-r--r--  2.0 unx     7007 b- defN 20-Feb-02 00:00 diffsptk/misc/utils.py
+?rw-r--r--  2.0 unx     6288 b- defN 20-Feb-02 00:00 diffsptk-1.0.0.dist-info/METADATA
+?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 diffsptk-1.0.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx    11358 b- defN 20-Feb-02 00:00 diffsptk-1.0.0.dist-info/licenses/LICENSE
+?rw-r--r--  2.0 unx     7068 b- defN 20-Feb-02 00:00 diffsptk-1.0.0.dist-info/RECORD
+89 files, 364608 bytes uncompressed, 125326 bytes compressed:  65.6%
```

## zipnote {}

```diff
@@ -6,14 +6,17 @@
 
 Filename: diffsptk/core/__init__.py
 Comment: 
 
 Filename: diffsptk/core/acorr.py
 Comment: 
 
+Filename: diffsptk/core/ap.py
+Comment: 
+
 Filename: diffsptk/core/b2mc.py
 Comment: 
 
 Filename: diffsptk/core/c2acr.py
 Comment: 
 
 Filename: diffsptk/core/c2mpir.py
@@ -63,23 +66,32 @@
 
 Filename: diffsptk/core/frame.py
 Comment: 
 
 Filename: diffsptk/core/freqt.py
 Comment: 
 
+Filename: diffsptk/core/freqt2.py
+Comment: 
+
+Filename: diffsptk/core/gmm.py
+Comment: 
+
 Filename: diffsptk/core/gnorm.py
 Comment: 
 
 Filename: diffsptk/core/grpdelay.py
 Comment: 
 
 Filename: diffsptk/core/idct.py
 Comment: 
 
+Filename: diffsptk/core/ifreqt2.py
+Comment: 
+
 Filename: diffsptk/core/ignorm.py
 Comment: 
 
 Filename: diffsptk/core/imglsadf.py
 Comment: 
 
 Filename: diffsptk/core/imsvq.py
@@ -117,14 +129,17 @@
 
 Filename: diffsptk/core/lpc2par.py
 Comment: 
 
 Filename: diffsptk/core/lpccheck.py
 Comment: 
 
+Filename: diffsptk/core/magic_intpl.py
+Comment: 
+
 Filename: diffsptk/core/mc2b.py
 Comment: 
 
 Filename: diffsptk/core/mcep.py
 Comment: 
 
 Filename: diffsptk/core/mcpf.py
@@ -144,14 +159,17 @@
 
 Filename: diffsptk/core/mglsadf.py
 Comment: 
 
 Filename: diffsptk/core/mlpg.py
 Comment: 
 
+Filename: diffsptk/core/mlsacheck.py
+Comment: 
+
 Filename: diffsptk/core/mpir2c.py
 Comment: 
 
 Filename: diffsptk/core/msvq.py
 Comment: 
 
 Filename: diffsptk/core/ndps2c.py
@@ -171,35 +189,38 @@
 
 Filename: diffsptk/core/phase.py
 Comment: 
 
 Filename: diffsptk/core/pitch.py
 Comment: 
 
+Filename: diffsptk/core/poledf.py
+Comment: 
+
 Filename: diffsptk/core/pqmf.py
 Comment: 
 
 Filename: diffsptk/core/quantize.py
 Comment: 
 
+Filename: diffsptk/core/rlevdur.py
+Comment: 
+
 Filename: diffsptk/core/rmse.py
 Comment: 
 
 Filename: diffsptk/core/root_pol.py
 Comment: 
 
 Filename: diffsptk/core/smcep.py
 Comment: 
 
 Filename: diffsptk/core/snr.py
 Comment: 
 
-Filename: diffsptk/core/sopr.py
-Comment: 
-
 Filename: diffsptk/core/spec.py
 Comment: 
 
 Filename: diffsptk/core/stft.py
 Comment: 
 
 Filename: diffsptk/core/ulaw.py
@@ -210,14 +231,17 @@
 
 Filename: diffsptk/core/vq.py
 Comment: 
 
 Filename: diffsptk/core/window.py
 Comment: 
 
+Filename: diffsptk/core/yingram.py
+Comment: 
+
 Filename: diffsptk/core/zcross.py
 Comment: 
 
 Filename: diffsptk/core/zerodf.py
 Comment: 
 
 Filename: diffsptk/misc/__init__.py
@@ -225,23 +249,20 @@
 
 Filename: diffsptk/misc/signals.py
 Comment: 
 
 Filename: diffsptk/misc/utils.py
 Comment: 
 
-Filename: diffsptk-0.6.0.dist-info/LICENSE
-Comment: 
-
-Filename: diffsptk-0.6.0.dist-info/METADATA
+Filename: diffsptk-1.0.0.dist-info/METADATA
 Comment: 
 
-Filename: diffsptk-0.6.0.dist-info/WHEEL
+Filename: diffsptk-1.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: diffsptk-0.6.0.dist-info/top_level.txt
+Filename: diffsptk-1.0.0.dist-info/licenses/LICENSE
 Comment: 
 
-Filename: diffsptk-0.6.0.dist-info/RECORD
+Filename: diffsptk-1.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## diffsptk/version.py

```diff
@@ -1 +1 @@
-__version__ = "0.6.0"
+__version__ = "1.0.0"
```

## diffsptk/core/__init__.py

```diff
@@ -1,8 +1,9 @@
 from .acorr import AutocorrelationAnalysis
+from .ap import Aperiodicity
 from .b2mc import MLSADigitalFilterCoefficientsToMelCepstrum
 from .c2acr import CepstrumToAutocorrelation
 from .c2mpir import CepstrumToMinimumPhaseImpulseResponse
 from .c2ndps import CepstrumToNegativeDerivativeOfPhaseSpectrum
 from .cdist import CepstralDistance
 from .cqt import ConstantQTransform
 from .cqt import ConstantQTransform as CQT
@@ -17,72 +18,80 @@
 from .dfs import InfiniteImpulseResponseDigitalFilter as IIR
 from .entropy import Entropy
 from .excite import ExcitationGeneration
 from .fbank import MelFilterBankAnalysis
 from .fftcep import CepstralAnalysis
 from .frame import Frame
 from .freqt import FrequencyTransform
+from .freqt2 import SecondOrderAllPassFrequencyTransform
+from .gmm import GaussianMixtureModeling
+from .gmm import GaussianMixtureModeling as GMM
 from .gnorm import GeneralizedCepstrumGainNormalization
 from .grpdelay import GroupDelay
 from .idct import InverseDiscreteCosineTransform
 from .idct import InverseDiscreteCosineTransform as IDCT
+from .ifreqt2 import SecondOrderAllPassInverseFrequencyTransform
 from .ignorm import GeneralizedCepstrumInverseGainNormalization
 from .imglsadf import PseudoInverseMGLSADigitalFilter
 from .imglsadf import PseudoInverseMGLSADigitalFilter as IMLSA
 from .imsvq import InverseMultiStageVectorQuantization
 from .interpolate import Interpolation
 from .ipqmf import InversePseudoQuadratureMirrorFilterBanks
 from .ipqmf import InversePseudoQuadratureMirrorFilterBanks as IPQMF
 from .istft import InverseShortTermFourierTransform
 from .istft import InverseShortTermFourierTransform as ISTFT
 from .iulaw import MuLawExpansion
 from .ivq import InverseVectorQuantization
 from .lar2par import LogAreaRatioToParcorCoefficients
 from .lbg import LindeBuzoGrayAlgorithm
-from .lbg import LindeBuzoGrayAlgorithm as KMeans
-from .levdur import PseudoLevinsonDurbinRecursion
-from .levdur import PseudoLevinsonDurbinRecursion as LevinsonDurbinRecursion
+from .lbg import LindeBuzoGrayAlgorithm as LBG
+from .levdur import LevinsonDurbin
 from .linear_intpl import LinearInterpolation
 from .lpc import LinearPredictiveCodingAnalysis
 from .lpc import LinearPredictiveCodingAnalysis as LPC
 from .lpc2par import LinearPredictiveCoefficientsToParcorCoefficients
 from .lpccheck import LinearPredictiveCoefficientsStabilityCheck
+from .magic_intpl import MagicNumberInterpolation
 from .mc2b import MelCepstrumToMLSADigitalFilterCoefficients
 from .mcpf import MelCepstrumPostfiltering
 from .mfcc import MelFrequencyCepstralCoefficientsAnalysis
 from .mfcc import MelFrequencyCepstralCoefficientsAnalysis as MFCC
 from .mgc2mgc import MelGeneralizedCepstrumToMelGeneralizedCepstrum
 from .mgc2sp import MelGeneralizedCepstrumToSpectrum
 from .mgcep import MelGeneralizedCepstralAnalysis
 from .mgcep import MelGeneralizedCepstralAnalysis as MelCepstralAnalysis
 from .mglsadf import PseudoMGLSADigitalFilter
 from .mglsadf import PseudoMGLSADigitalFilter as MLSA
 from .mlpg import MaximumLikelihoodParameterGeneration
 from .mlpg import MaximumLikelihoodParameterGeneration as MLPG
+from .mlsacheck import MLSADigitalFilterStabilityCheck
 from .mpir2c import MinimumPhaseImpulseResponseToCepstrum
 from .msvq import MultiStageVectorQuantization
 from .ndps2c import NegativeDerivativeOfPhaseSpectrumToCepstrum
 from .norm0 import AllPoleToAllZeroDigitalFilterCoefficients
 from .par2lar import ParcorCoefficientsToLogAreaRatio
 from .par2lpc import ParcorCoefficientsToLinearPredictiveCoefficients
 from .pca import PrincipalComponentAnalysis
 from .pca import PrincipalComponentAnalysis as PCA
 from .phase import Phase
 from .pitch import Pitch
+from .poledf import AllPoleDigitalFilter
 from .pqmf import PseudoQuadratureMirrorFilterBanks
 from .pqmf import PseudoQuadratureMirrorFilterBanks as PQMF
 from .quantize import UniformQuantization
+from .rlevdur import ReverseLevinsonDurbin
 from .rmse import RootMeanSquaredError
 from .rmse import RootMeanSquaredError as RMSE
 from .root_pol import DurandKernerMethod
 from .smcep import SecondOrderAllPassMelCepstralAnalysis
 from .snr import SignalToNoiseRatio
 from .snr import SignalToNoiseRatio as SNR
 from .spec import Spectrum
 from .stft import ShortTermFourierTransform
 from .stft import ShortTermFourierTransform as STFT
 from .ulaw import MuLawCompression
 from .unframe import Unframe
 from .vq import VectorQuantization
 from .window import Window
+from .yingram import Yingram
 from .zcross import ZeroCrossingAnalysis
 from .zerodf import AllZeroDigitalFilter
```

## diffsptk/core/acorr.py

```diff
@@ -69,15 +69,15 @@
 
     def forward(self, x):
         """Estimate autocorrelation of input.
 
         Parameters
         ----------
         x : Tensor [shape=(..., L)]
-            Framed waveform
+            Framed waveform.
 
         Returns
         -------
         r : Tensor [shape=(..., M+1)]
             Autocorrelation.
 
         Examples
```

## diffsptk/core/b2mc.py

```diff
@@ -31,15 +31,15 @@
         Order of cepstrum, :math:`M`.
 
     alpha : float [-1 < alpha < 1]
         Frequency warping factor, :math:`\\alpha`.
 
     """
 
-    def __init__(self, cep_order, alpha):
+    def __init__(self, cep_order, alpha=0):
         super(MLSADigitalFilterCoefficientsToMelCepstrum, self).__init__()
 
         assert 0 <= cep_order
         assert abs(alpha) < 1
 
         # Make transform matrix.
         A = np.eye(cep_order + 1)
```

## diffsptk/core/c2mpir.py

```diff
@@ -26,32 +26,32 @@
     for details. The conversion uses FFT instead of recursive formula.
 
     Parameters
     ----------
     cep_order : int >= 0 [scalar]
         Order of cepstrum, :math:`M`.
 
-    impulse_response_length : int >= 1 [scalar]
+    ir_length : int >= 1 [scalar]
         Length of impulse response, :math:`N`.
 
     n_fft : int >> :math:`N` [scalar]
         Number of FFT bins. Accurate conversion requires the large value.
 
     """
 
-    def __init__(self, cep_order, impulse_response_length, n_fft=512):
+    def __init__(self, cep_order, ir_length, n_fft=512):
         super(CepstrumToMinimumPhaseImpulseResponse, self).__init__()
 
         self.cep_order = cep_order
-        self.impulse_response_length = impulse_response_length
+        self.ir_length = ir_length
         self.n_fft = n_fft
 
         assert 0 <= self.cep_order
-        assert 1 <= self.impulse_response_length
-        assert max(self.cep_order + 1, self.impulse_response_length) < self.n_fft
+        assert 1 <= self.ir_length
+        assert max(self.cep_order + 1, self.ir_length) < self.n_fft
 
     def forward(self, c):
         """Convert cepstrum to minimum phase impulse response.
 
         Parameters
         ----------
         c : Tensor [shape=(..., M+1)]
@@ -70,9 +70,9 @@
         >>> h
         tensor([1.0000, 1.0000, 2.5000, 5.1667, 6.0417])
 
         """
         check_size(c.size(-1), self.cep_order + 1, "dimension of cepstrum")
 
         C = torch.fft.fft(c, n=self.n_fft)
-        h = torch.fft.ifft(cexp(C))[..., : self.impulse_response_length].real
+        h = torch.fft.ifft(cexp(C))[..., : self.ir_length].real
         return h
```

## diffsptk/core/dct.py

```diff
@@ -18,14 +18,27 @@
 import torch
 import torch.nn as nn
 
 from ..misc.utils import numpy_to_torch
 
 
 def make_dct_matrix(L):
+    """Make DCT matrix.
+
+    Parameters
+    ----------
+    L : int >= 1 [scalar]
+        DCT length, :math:`L`.
+
+    Returns
+    -------
+    W : ndarray [shape=(L, L)]
+        DCT matrix.
+
+    """
     W = np.empty((L, L))
     n = (np.arange(L) + 0.5) * (np.pi / L)
     c = np.sqrt(2 / L)
     for k in range(L):
         z = np.sqrt(1 / L) if k == 0 else c
         W[:, k] = z * np.cos(k * n)
     return W
```

## diffsptk/core/delta.py

```diff
@@ -18,14 +18,31 @@
 import torch.nn as nn
 import torch.nn.functional as F
 
 from ..misc.utils import numpy_to_torch
 
 
 def make_window(seed, static_out=True):
+    """Make window for delta computation.
+
+    Parameters
+    ----------
+    seed : list[list[float]] or list[int]
+        Delta coefficients or width(s) of 1st (and 2nd) regression coefficients.
+
+    static_out : bool [scalar]
+        If True, make window for static component.
+
+    Returns
+    -------
+    window : ndarray [shape=(D+1, W)]
+        Window for delta computation, where D is the number of dynamic components and
+        W is the width of window.
+
+    """
     if not isinstance(seed, (tuple, list)):
         raise ValueError("seed must be tuple or list")
 
     if isinstance(seed[0], (tuple, list)):
         # Make window from delta coefficients.
         if static_out:
             seed = [[1]] + list(seed)
```

## diffsptk/core/df2.py

```diff
@@ -38,27 +38,27 @@
 
     zero_frequency : float > 0 [scalar]
         Zero frequency in Hz.
 
     zero_bandwidth : float > 0 [scalar]
         Zero bandwidth in Hz.
 
-    impulse_response_length : int >= 1 [scalar]
+    ir_length : int >= 1 [scalar]
         Length of impulse response.
 
     """
 
     def __init__(
         self,
         sample_rate,
         pole_frequency=None,
         pole_bandwidth=None,
         zero_frequency=None,
         zero_bandwidth=None,
-        impulse_response_length=None,
+        ir_length=None,
     ):
         super(SecondOrderDigitalFilter, self).__init__()
 
         def get_filter_coefficients(frequency, bandwidth, sample_rate):
             assert 0 < frequency
             assert 0 < bandwidth
             assert 0 < sample_rate
@@ -72,16 +72,16 @@
             param["a"] = get_filter_coefficients(
                 pole_frequency, pole_bandwidth, sample_rate
             )
         if zero_frequency is not None:
             param["b"] = get_filter_coefficients(
                 zero_frequency, zero_bandwidth, sample_rate
             )
-        if impulse_response_length is not None:
-            param["impulse_response_length"] = impulse_response_length
+        if ir_length is not None:
+            param["ir_length"] = ir_length
 
         self.dfs = InfiniteImpulseResponseDigitalFilter(**param)
 
     def forward(self, x):
         """Apply a second order digital filter.
 
         Parameters
```

## diffsptk/core/dfs.py

```diff
@@ -30,48 +30,48 @@
     ----------
     b : List [shape=(M+1,)]
         Numerator coefficients.
 
     a : List [shape=(N+1,)]
         Denominator coefficients.
 
-    impulse_response_length : int >= 1 [scalar]
+    ir_length : int >= 1 [scalar]
         Length of impulse response.
 
     """
 
-    def __init__(self, b=[1], a=[1], impulse_response_length=None):
+    def __init__(self, b=[1], a=[1], ir_length=None):
         super(InfiniteImpulseResponseDigitalFilter, self).__init__()
 
-        if impulse_response_length is None:
-            impulse_response_length = len(b)
-        assert 1 <= impulse_response_length
+        if ir_length is None:
+            ir_length = len(b)
+        assert 1 <= ir_length
 
         d = np.zeros(max(len(b), len(a)))
-        h = np.empty(impulse_response_length)
+        h = np.empty(ir_length)
 
         a0 = a[0]
         a1 = np.asarray(a[1:])
         b = np.asarray(b)
 
         # Pre-compute impulse response.
-        for t in range(impulse_response_length):
+        for t in range(ir_length):
             x = a0 if t == 0 else 0
             y = x - np.sum(d[: len(a1)] * a1)
 
             d = np.roll(d, 1)
             d[0] = y
 
             y = np.sum(d[: len(b)] * b)
             h[t] = y
 
         h = h.reshape(1, 1, -1)
         self.register_buffer("h", numpy_to_torch(h).flip(-1))
 
-        self.pad = nn.ConstantPad1d((impulse_response_length - 1, 0), 0)
+        self.pad = nn.ConstantPad1d((ir_length - 1, 0), 0)
 
     def forward(self, x):
         """Apply an approximated IIR digital filter.
 
         Parameters
         ----------
         x : Tensor [shape=(B, 1, T) or (B, T) or (T,)]
```

## diffsptk/core/excite.py

```diff
@@ -12,29 +12,30 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import torch
 import torch.nn as nn
+import torch.nn.functional as F
 
 from ..misc.utils import UNVOICED_SYMBOL
 from .linear_intpl import LinearInterpolation
 
 
 class ExcitationGeneration(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/excite.html>`_
     for details.
 
     Parameters
     ----------
     frame_period : int >= 1 [scalar]
         Frame period in samples, :math:`P`.
 
-    voiced_region : ['pulse', 'sinusoidal']
+    voiced_region : ['pulse', 'sinusoidal', 'sawtooth']
         Value on voiced region.
 
     unvoiced_region : ['gauss', 'zeros']
         Value on unvoiced region.
 
     """
 
@@ -42,15 +43,15 @@
         super(ExcitationGeneration, self).__init__()
 
         self.frame_period = frame_period
         self.voiced_region = voiced_region
         self.unvoiced_region = unvoiced_region
 
         assert 1 <= self.frame_period
-        assert self.voiced_region in ("pulse", "sinusoidal")
+        assert self.voiced_region in ("pulse", "sinusoidal", "sawtooth")
         assert self.unvoiced_region in ("gauss", "zeros")
 
         self.linear_intpl = LinearInterpolation(self.frame_period)
 
     def forward(self, p):
         """Generate a simple excitation signal.
 
@@ -75,40 +76,44 @@
         """
         # Make mask represents voiced region.
         base_mask = torch.clip(p, min=0, max=1)
         mask = torch.ne(base_mask, UNVOICED_SYMBOL)
         mask = torch.repeat_interleave(mask, self.frame_period, dim=-1)
 
         # Extend right side for interpolation.
-        tmp_mask = torch.cat((base_mask[..., :1] * 0, base_mask), dim=-1)
+        tmp_mask = F.pad(base_mask, (1, 0))
         tmp_mask = torch.eq(tmp_mask[..., 1:] - tmp_mask[..., :-1], -1)
         p[tmp_mask] = torch.roll(p, 1, dims=-1)[tmp_mask]
 
         # Interpolate pitch.
         if p.dim() != 1:
-            p = p.transpose(-2, -1)
+            p = p.mT
         p = self.linear_intpl(p)
         if p.dim() != 1:
-            p = p.transpose(-2, -1)
+            p = p.mT
         p *= mask
 
         # Compute phase.
-        q = torch.nan_to_num(torch.reciprocal(p), posinf=0)
+        voiced_pos = torch.gt(p, 0)
+        q = torch.zeros_like(p)
+        q[voiced_pos] = torch.reciprocal(p[voiced_pos])
         s = torch.cumsum(q.double(), dim=-1)
         bias, _ = torch.cummax(s * ~mask, dim=-1)
         phase = (s - bias).to(p.dtype)
 
         if self.voiced_region == "pulse":
             r = torch.ceil(phase)
-            r = torch.cat((r[..., :1] * 0, r), dim=-1)
+            r = F.pad(r, (1, 0))
             pulse_pos = torch.ge(r[..., 1:] - r[..., :-1], 1)
             e = torch.zeros_like(p)
             e[pulse_pos] = torch.sqrt(p[pulse_pos])
         elif self.voiced_region == "sinusoidal":
             e = torch.sin((2 * torch.pi) * phase)
+        elif self.voiced_region == "sawtooth":
+            e = torch.fmod(phase, 2) - 1
         else:
             raise RuntimeError
 
         if self.unvoiced_region == "gauss":
             e[~mask] = torch.randn(torch.sum(~mask), device=e.device)
         elif self.unvoiced_region == "zeros":
             pass
```

## diffsptk/core/fbank.py

```diff
@@ -17,23 +17,14 @@
 import numpy as np
 import torch
 import torch.nn as nn
 
 from ..misc.utils import numpy_to_torch
 
 
-def hz_to_mel(x):
-    return 1127 * np.log(x / 700 + 1)
-
-
-def sample_mel(n, fft_length, sample_rate):
-    hz = sample_rate * n / fft_length
-    return hz_to_mel(hz)
-
-
 class MelFilterBankAnalysis(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/fbank.html>`_
     for details.
 
     Parameters
     ----------
     n_channel : int >= 1 [scalar]
@@ -89,27 +80,30 @@
         elif out_format == 1 or out_format == "yE":
             self.format_func = lambda y, E: torch.cat((y, E), dim=-1)
         elif out_format == 2 or out_format == "y,E":
             self.format_func = lambda y, E: (y, E)
         else:
             raise ValueError(f"out_format {out_format} is not supported")
 
+        def hz_to_mel(x):
+            return 1127 * np.log(x / 700 + 1)
+
         lower_bin_index = max(1, int(f_min / sample_rate * fft_length + 1.5))
         upper_bin_index = min(
             fft_length // 2, int(f_max / sample_rate * fft_length + 0.5)
         )
 
         mel_min = hz_to_mel(f_min)
         mel_max = hz_to_mel(f_max)
 
         seed = np.arange(1, n_channel + 2)
         freq = (mel_max - mel_min) / (n_channel + 1) * seed + mel_min
 
         seed = np.arange(lower_bin_index, upper_bin_index)
-        mel = sample_mel(seed, fft_length, sample_rate)
+        mel = hz_to_mel(sample_rate * seed / fft_length)
         lower_channel_map = [np.argmax((freq >= m) > 0) for m in mel]
 
         diff = freq - np.insert(freq[:-1], 0, mel_min)
         weights = np.zeros((fft_length // 2 + 1, n_channel))
         for i, k in enumerate(seed):
             m = lower_channel_map[i]
             w = (freq[max(0, m)] - mel[i]) / diff[max(0, m)]
```

## diffsptk/core/fftcep.py

```diff
@@ -75,19 +75,14 @@
         >>> fftcep = diffsptk.CepstralAnalysis(3, 16)
         >>> c = fftcep(stft(x))
         >>> c
         tensor([[-0.9663,  0.8190, -0.0932, -0.0152],
                 [-0.8539,  4.6173, -0.5496, -0.3207]])
 
         """
-        # Torch's pad only supports 3D, 4D, 5D padding with non-constant padding.
-        d = x.dim()
-        for _ in range(3 - d):
-            x = x.unsqueeze(0)
-
         M = self.cep_order
         H = self.fft_length // 2
 
         e = torch.fft.irfft(torch.log(x))
         v = e[..., : M + 1]
         e = F.pad(e[..., M + 1 : H + 1], (M + 1, 0))
 
@@ -97,14 +92,9 @@
             e = torch.fft.ihfft(e).real
 
             t = e[..., : M + 1] * self.accel
             v = v + t
             e = e - F.pad(t, (0, H - M))
 
         indices = [0, M] if H == M else [0]
-        for m in indices:
-            v[..., m] *= 0.5
-
-        # Revert shape.
-        for _ in range(3 - d):
-            v = v.squeeze(0)
+        v[..., indices] *= 0.5
         return v
```

## diffsptk/core/freqt.py

```diff
@@ -34,15 +34,15 @@
         Order of output sequence, :math:`M_2`.
 
     alpha : float [-1 < alpha < 1]
         Frequency warping factor, :math:`\\alpha`.
 
     """
 
-    def __init__(self, in_order, out_order, alpha):
+    def __init__(self, in_order, out_order, alpha=0):
         super(FrequencyTransform, self).__init__()
 
         assert 0 <= in_order
         assert 0 <= out_order
         assert abs(alpha) < 1
 
         beta = 1 - alpha * alpha
```

## diffsptk/core/grpdelay.py

```diff
@@ -82,16 +82,15 @@
             order = 0
             c = b
         else:
             order = a.size(-1) - 1
 
             # Remove gain.
             K, a1 = torch.split(a, [1, order], dim=-1)
-            K = K * 0 + 1
-            a2 = torch.cat((K, a1), dim=-1).unsqueeze(-1)
+            a2 = F.pad(a1, (1, 0), value=1).unsqueeze(-1)
 
             # Perform full convolution.
             b1 = F.pad(b, (order, order))
             b2 = b1.unfold(-1, b.size(-1) + order, 1)
             c = (b2 * a2).sum(-2)
 
         length = c.size(-1)
```

## diffsptk/core/imglsadf.py

```diff
@@ -16,65 +16,28 @@
 
 import torch.nn as nn
 
 from .mglsadf import PseudoMGLSADigitalFilter
 
 
 class PseudoInverseMGLSADigitalFilter(nn.Module):
-    """See `this page <https://sp-nitech.github.io/sptk/latest/main/imglsadf.html>`_
-    for details.
+    """See :func:`~diffsptk.PseudoMGLSADigitalFilter` for details."""
 
-    Parameters
-    ----------
-    filter_order : int >= 0 [scalar]
-        Order of filter coefficients, :math:`M`.
-
-    alpha : float [-1 < alpha < 1]
-        Frequency warping factor, :math:`\\alpha`.
-
-    gamma : float [-1 <= gamma <= 1]
-        Gamma, :math:`\\gamma`.
-
-    c : int >= 1 [scalar]
-        Number of stages.
-
-    frame_period : int >= 1 [scalar]
-        Frame period, :math:`P`.
-
-    ignore_gain : bool [scalar]
-        If True, perform filtering without gain.
-
-    phase : ['minimum', 'maximum', 'zero']
-        Filter type.
-
-    cascade : bool [scalar]
-        If True, use multi-stage FIR filter.
-
-    cep_order : int >= 0 [scalar]
-        Order of linear cepstrum (valid only if **cascade** is True).
-
-    taylor_order : int >= 0 [scalar]
-        Order of Taylor series expansion (valid only if **cascade** is True).
-
-    impulse_response_length : int >= 1 [scalar]
-        Length of impulse response (valid only if **cascade** is False).
-
-    n_fft : int >= 1 [scalar]
-        Number of FFT bins for conversion (valid only if **cascade** is False).
-
-    """
-
-    def __init__(
-        self,
-        filter_order,
-        **kwargs,
-    ):
+    def __init__(self, filter_order, frame_period, **kwargs):
         super(PseudoInverseMGLSADigitalFilter, self).__init__()
 
-        self.mglsadf = PseudoMGLSADigitalFilter(filter_order, **kwargs)
+        # Change the default value of the order of Taylor series.
+        # This is because inverse filtering requires the large value.
+        if (
+            kwargs.get("mode", "multi-stage") == "multi-stage"
+            and "taylor_order" not in kwargs
+        ):
+            kwargs["taylor_order"] = 40
+
+        self.mglsadf = PseudoMGLSADigitalFilter(filter_order, frame_period, **kwargs)
 
     def forward(self, y, mc):
         """Apply an inverse MGLSA digital filter.
 
         Parameters
         ----------
         y : Tensor [shape=(..., T)]
@@ -92,15 +55,15 @@
         --------
         >>> M = 4
         >>> y = diffsptk.step(3)
         >>> mc = diffsptk.nrand(2, M)
         >>> mc
         tensor([[ 0.8457,  1.5812,  0.1379,  1.6558,  1.4591],
                 [-1.3714, -0.9669, -1.2025, -1.3683, -0.2352]])
-        >>> imglsadf = diffsptk.PseudoInverseMGLSADigitalFilter(M, frame_period=2)
+        >>> imglsadf = diffsptk.IMLSA(M, frame_period=2)
         >>> x = imglsadf(y.view(1, -1), mc.view(1, 2, M + 1))
         >>> x
         tensor([[ 0.4293,  1.0592,  7.9349, 14.9794]])
 
         """
         x = self.mglsadf(y, -mc)
         return x
```

## diffsptk/core/ipqmf.py

```diff
@@ -10,14 +10,16 @@
 # Unless required by applicable law or agreed to in writing, software      #
 # distributed under the License is distributed on an "AS IS" BASIS,        #
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
+import warnings
+
 import numpy as np
 import torch.nn as nn
 import torch.nn.functional as F
 
 from ..misc.utils import numpy_to_torch
 from .pqmf import make_filter_banks
 
@@ -33,28 +35,42 @@
 
     filter_order : int >= 2 [scalar]
         Order of filter, :math:`M`.
 
     alpha : float > 0 [scalar]
         Stopband attenuation in dB.
 
+    learnable : bool [scalar]
+        Whether to make filter-bank coefficients learnable.
+
+    **kwargs : additional keyword arguments
+        Parameters to find optimal filter-bank coefficients.
+
     """
 
-    def __init__(self, n_band, filter_order, alpha=100):
+    def __init__(self, n_band, filter_order, alpha=100, learnable=False, **kwargs):
         super(InversePseudoQuadratureMirrorFilterBanks, self).__init__()
 
         assert 1 <= n_band
         assert 2 <= filter_order
         assert 0 < alpha
 
         # Make filterbanks.
-        filters = make_filter_banks(n_band, filter_order, "synthesis", alpha=alpha)
+        filters, is_converged = make_filter_banks(
+            n_band, filter_order, mode="synthesis", alpha=alpha, **kwargs
+        )
+        if not is_converged:
+            warnings.warn("Failed to find PQMF coefficients")
         filters = np.expand_dims(filters, 0)
         filters = np.flip(filters, 2).copy()
-        self.register_buffer("filters", numpy_to_torch(filters))
+        filters = numpy_to_torch(filters)
+        if learnable:
+            self.filters = nn.Parameter(filters)
+        else:
+            self.register_buffer("filters", filters)
 
         # Make padding module.
         if filter_order % 2 == 0:
             delay_left = filter_order // 2
             delay_right = filter_order // 2
         else:
             delay_left = (filter_order - 1) // 2
```

## diffsptk/core/istft.py

```diff
@@ -18,15 +18,15 @@
 import torch.nn as nn
 
 from ..misc.utils import Lambda
 from .unframe import Unframe
 
 
 class InverseShortTermFourierTransform(nn.Module):
-    """This is the opposite module to ShortTermFourierTransform.
+    """This is the opposite module to :func:`~diffsptk.ShortTermFourierTransform`
 
     Parameters
     ----------
     frame_length : int >= 1 [scalar]
         Frame length, :math:`L`.
 
     frame_peirod : int >= 1 [scalar]
```

## diffsptk/core/lbg.py

```diff
@@ -83,14 +83,15 @@
 
         if self.verbose:
             self.logger = logging.getLogger("lbg")
             self.logger.setLevel(logging.INFO)
             formatter = logging.Formatter(
                 "%(asctime)s (%(module)s:%(lineno)d) %(levelname)s: %(message)s"
             )
+            self.logger.handlers.clear()
             handler = logging.StreamHandler()
             handler.setFormatter(formatter)
             self.logger.addHandler(handler)
 
     def forward(self, x):
         """Design a codebook.
 
@@ -100,27 +101,32 @@
             Input vectors.
 
         Returns
         -------
         codebook : Tensor [shape=(K, M+1)]
             Codebook.
 
+        indices : Tensor [shape=(...,)]
+            Codebook indices.
+
         distance : Tensor [scalar]
             Distance.
 
         Examples
         --------
         >>> x = diffsptk.nrand(10, 0)
-        >>> lbg = diffsptk.KMeans(0, 2)
-        >>> codebook, distance = lbg(x)
+        >>> lbg = diffsptk.LBG(0, 2)
+        >>> codebook, indices, distance = lbg(x)
         >>> codebook
-        tensor([[-1.3889],
-                [ 0.6275]])
+        tensor([[-0.5277],
+                [ 0.6747]])
+        >>> indices
+        tensor([0, 0, 0, 1, 0, 1, 1, 1, 1, 0])
         >>> distance
-        tensor(0.2489)
+        tensor(0.2331)
 
         """
         check_size(x.size(-1), self.order + 1, "dimension of input")
 
         # Initalize codebook.
         x = x.view(-1, x.size(-1))
         mean = x.mean(0)
@@ -133,27 +139,29 @@
             # Double codebook.
             codebook = self.vq.codebook[:curr_codebook_size]
             r = torch.randn_like(codebook) * self.perturb_factor
             self.vq.codebook[curr_codebook_size:next_codebook_size] = codebook - r
             self.vq.codebook[:curr_codebook_size] += r
             curr_codebook_size = next_codebook_size
             next_codebook_size *= 2
+            if self.verbose:
+                self.logger.info(f"K = {curr_codebook_size}")
 
             prev_distance = distance  # Suppress flake8 warnings.
             for n in range(self.n_iter):
                 # E-step: evaluate model.
                 xq, indices, _ = self.vq(x)
                 distance = (x - xq).square().sum()
                 distance /= x.size(0)
                 if self.verbose:
-                    self.logger.info(f"K={curr_codebook_size} {n:5d}: {distance:g}")
+                    self.logger.info(f"iter {n+1:5d}: distance = {distance:g}")
 
                 # Check convergence.
-                diff = (prev_distance - distance).abs()
-                if n and diff / (distance + 1e-16) < self.eps:
+                change = (prev_distance - distance).abs()
+                if n and change / (distance + 1e-16) < self.eps:
                     break
                 prev_distance = distance
 
                 # Get number of data points for each cluster.
                 n_data = torch.histc(
                     indices.float(),
                     bins=curr_codebook_size,
@@ -176,8 +184,10 @@
                     copied_centroids = centroids[m : m + 1].expand((~mask).sum(), -1)
                     r = torch.randn_like(copied_centroids) * self.perturb_factor
                     centroids[~mask] = copied_centroids - r
                     centroids[m] += r.mean(0)
 
                 self.vq.codebook[:curr_codebook_size] = centroids
 
-        return self.vq.codebook, distance
+        _, indices, _ = self.vq(x)
+
+        return self.vq.codebook, indices, distance
```

## diffsptk/core/levdur.py

```diff
@@ -13,26 +13,35 @@
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import torch
 import torch.nn as nn
 
+from ..misc.utils import check_size
 from ..misc.utils import symmetric_toeplitz
 
 
-class PseudoLevinsonDurbinRecursion(nn.Module):
+class LevinsonDurbin(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/levdur.html>`_
-    for details. Note that the current implementation does not use the Durbin's
-    algorithm though the class name includes it.
+    for details.
+
+    Parameters
+    ----------
+    lpc_order : int >= 0 [scalar]
+        Order of LPC coefficients, :math:`M`.
 
     """
 
-    def __init__(self):
-        super(PseudoLevinsonDurbinRecursion, self).__init__()
+    def __init__(self, lpc_order):
+        super(LevinsonDurbin, self).__init__()
+
+        self.lpc_order = lpc_order
+
+        assert 0 <= self.lpc_order
 
     def forward(self, r):
         """Solve a Yule-Walker linear system.
 
         Parameters
         ----------
         r : Tensor [shape=(..., M+1)]
@@ -44,20 +53,22 @@
             Gain and LPC coefficients.
 
         Examples
         --------
         >>> x = diffsptk.nrand(4)
         tensor([ 0.8226, -0.0284, -0.5715,  0.2127,  0.1217])
         >>> acorr = diffsptk.AutocorrelationAnalysis(2, 5)
-        >>> levdur = diffsptk.LevinsonDurbinRecursion()
+        >>> levdur = diffsptk.LevinsonDurbin(2)
         >>> a = levdur(acorr(x))
         >>> a
         tensor([0.8726, 0.1475, 0.5270])
 
         """
+        check_size(r.size(-1), self.lpc_order + 1, "dimension of autocorrelation")
+
         # Make Toeplitz matrix.
         R = symmetric_toeplitz(r[..., :-1])
 
         # Solve system.
         r1 = r[..., 1:]
         a = torch.einsum("...mn,...m->...n", R.inverse(), -r1)
```

## diffsptk/core/linear_intpl.py

```diff
@@ -10,20 +10,17 @@
 # Unless required by applicable law or agreed to in writing, software      #
 # distributed under the License is distributed on an "AS IS" BASIS,        #
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
-import numpy as np
 import torch.nn as nn
 import torch.nn.functional as F
 
-from ..misc.utils import numpy_to_torch
-
 
 class LinearInterpolation(nn.Module):
     """Perform linear interpolation.
 
     Note that this is not for lienar_intpl in C the version of SPTK, but for
     filter coefficients interpolation in digital filtering.
 
@@ -33,26 +30,19 @@
         Upsampling factor, :math:`P`.
 
     """
 
     def __init__(self, upsampling_factor):
         super(LinearInterpolation, self).__init__()
 
-        assert 1 <= upsampling_factor
+        self.upsampling_factor = upsampling_factor
 
-        # Make upsampling filter.
-        w = np.linspace(1, 0, upsampling_factor + 1)[:-1]
-        upsampling_filter = np.stack((w, 1 - w), axis=1)
-        upsampling_filter = np.expand_dims(
-            upsampling_filter, (1, 3)
-        )  # (Out, In, Height, Width)
-        self.register_buffer("upsampling_filter", numpy_to_torch(upsampling_filter))
+        assert 1 <= self.upsampling_factor
 
-        # Make padding module.
-        self.pad = nn.ReplicationPad2d((0, 0, 0, 1))
+        self.pad = nn.ReplicationPad1d((0, 1))
 
     def forward(self, x):
         """Interpolate filter coefficients.
 
         Parameters
         ----------
         x : Tensor [shape=(B, N, D) or (N, D) or (N,)]
@@ -70,30 +60,36 @@
         tensor([0., 1., 2.])
         >>> linear_intpl = diffsptk.LinearInterpolation(2)
         >>> y = linear_intpl(x)
         >>> y
         tensor([0.0000, 0.5000, 1.0000, 1.5000, 2.0000, 2.0000])
 
         """
-        # Return copy if upsampling factor is one.
-        if self.upsampling_filter.size(0) == 1:
+        # Pass through if upsampling factor is one.
+        if self.upsampling_factor == 1:
             return x
 
         d = x.dim()
         if d == 1:
             x = x.view(1, -1, 1)
         elif d == 2:
             x = x.unsqueeze(0)
         assert x.dim() == 3, "Input must be 3D tensor"
-        B, _, D = x.shape
+        B, T, D = x.shape
 
-        x = x.unsqueeze(1)  # (B, 1, N, D)
+        x = x.mT
         x = self.pad(x)
-
-        y = F.conv2d(x, self.upsampling_filter)  # (B, P, N, D)
-        y = y.permute(0, 2, 1, 3).reshape(B, -1, D)
+        x = F.interpolate(
+            x,
+            size=T * self.upsampling_factor + 1,
+            mode="linear",
+            align_corners=True,
+        )[
+            ..., :-1
+        ]  # Remove the padded value.
+        y = x.mT.reshape(B, -1, D)
 
         if d == 1:
             y = y.view(-1)
         elif d == 2:
             y = y.squeeze(0)
         return y
```

## diffsptk/core/lpc.py

```diff
@@ -13,15 +13,15 @@
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import torch.nn as nn
 
 from .acorr import AutocorrelationAnalysis
-from .levdur import PseudoLevinsonDurbinRecursion
+from .levdur import LevinsonDurbin
 
 
 class LinearPredictiveCodingAnalysis(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/lpc.html>`_
     for details. This module is a simple cascade of acorr and levdur.
 
     Parameters
@@ -35,24 +35,24 @@
     """
 
     def __init__(self, lpc_order, frame_length):
         super(LinearPredictiveCodingAnalysis, self).__init__()
 
         self.lpc = nn.Sequential(
             AutocorrelationAnalysis(lpc_order, frame_length),
-            PseudoLevinsonDurbinRecursion(),
+            LevinsonDurbin(lpc_order),
         )
 
     def forward(self, x):
         """Perform LPC analysis.
 
         Parameters
         ----------
         x : Tensor [shape=(..., L)]
-            Framed waveform
+            Framed waveform.
 
         Returns
         -------
         a : Tensor [shape=(..., M+1)]
             Gain and LPC coefficients.
 
         Examples
```

## diffsptk/core/lpc2par.py

```diff
@@ -84,18 +84,18 @@
         ks = []
         a = a * self.gamma
         for m in range(self.lpc_order - 1, -1, -1):
             km = a[..., m : m + 1]
             if torch.any(1 <= torch.abs(km)):
                 if self.warn_type == "ignore":
                     pass
-                elif self.warn_type == "warn":  # pragma: no cover
-                    warnings.warn("Unstable LPC is detected")
-                elif self.warn_type == "exit":  # pragma: no cover
-                    raise RuntimeError("Unstable LPC is detected")
+                elif self.warn_type == "warn":
+                    warnings.warn("Unstable LPC coefficients")
+                elif self.warn_type == "exit":
+                    raise RuntimeError("Unstable LPC coefficients")
                 else:
                     raise RuntimeError
 
             ks.append(km)
             z = 1 - km * km
             k = a[..., :-1]
             a = (k - km * k.flip(-1)) / z
```

## diffsptk/core/lpccheck.py

```diff
@@ -57,15 +57,15 @@
         ----------
         a1 : Tensor [shape=(..., M+1)]
             LPC coefficients.
 
         Returns
         -------
         a2 : Tensor [shape=(..., M+1)]
-            Stabilized LPC coefficients.
+            Modified LPC coefficients.
 
         Examples
         --------
         >>> x = diffsptk.nrand(4)
         tensor([-0.9966, -0.2970, -0.2173,  0.0594,  0.5831])
         >>> lpc = diffsptk.LPC(3, 5)
         >>> a = lpc(x)
```

## diffsptk/core/mc2b.py

```diff
@@ -31,15 +31,15 @@
         Order of cepstrum, :math:`M`.
 
     alpha : float [-1 < alpha < 1]
         Frequency warping factor, :math:`\\alpha`.
 
     """
 
-    def __init__(self, cep_order, alpha):
+    def __init__(self, cep_order, alpha=0):
         super(MelCepstrumToMLSADigitalFilterCoefficients, self).__init__()
 
         assert 0 <= cep_order
         assert abs(alpha) < 1
 
         # Make transform matrix.
         A = np.eye(cep_order + 1)
```

## diffsptk/core/mcpf.py

```diff
@@ -39,29 +39,27 @@
 
     beta : float [scalar]
         Intensity parameter, :math:`\\beta`.
 
     onset : int >= 0 [scalar]
         Onset index.
 
-    impulse_response_length : int >= 1 [scalar]
+    ir_length : int >= 1 [scalar]
         Length of impulse response.
 
     """
 
-    def __init__(
-        self, cep_order, alpha=0, beta=0, onset=2, impulse_response_length=1024
-    ):
+    def __init__(self, cep_order, alpha=0, beta=0, onset=2, ir_length=1024):
         super(MelCepstrumPostfiltering, self).__init__()
 
         assert 0 <= onset
 
         self.mc2en = nn.Sequential(
-            FrequencyTransform(cep_order, impulse_response_length - 1, -alpha),
-            CepstrumToAutocorrelation(0, impulse_response_length),
+            FrequencyTransform(cep_order, ir_length - 1, -alpha),
+            CepstrumToAutocorrelation(0, ir_length),
         )
         self.mc2b = MelCepstrumToMLSADigitalFilterCoefficients(cep_order, alpha)
         self.b2mc = MLSADigitalFilterCoefficientsToMelCepstrum(cep_order, alpha)
 
         weight = np.full(cep_order + 1, 1 + beta)
         weight[:onset] = 1
         self.register_buffer("weight", numpy_to_torch(weight))
```

## diffsptk/core/mgc2mgc.py

```diff
@@ -13,27 +13,49 @@
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import numpy as np
 import torch
 import torch.nn as nn
+import torch.nn.functional as F
 
 from ..misc.utils import cexp
 from ..misc.utils import clog
 from ..misc.utils import numpy_to_torch
 from .freqt import FrequencyTransform
 from .gnorm import GeneralizedCepstrumGainNormalization as GainNormalization
 from .ignorm import (
     GeneralizedCepstrumInverseGainNormalization as InverseGainNormalization,
 )
 
 
 class GeneralizedCepstrumToGeneralizedCepstrum(nn.Module):
-    def __init__(self, in_order, out_order, in_gamma, out_gamma, n_fft):
+    """Generalized cepstral transformation module.
+
+    Parameters
+    ----------
+    in_order : int >= 0 [scalar]
+        Order of input cepstrum, :math:`M_1`.
+
+    out_order : int >= 0 [scalar]
+        Order of output cepstrum, :math:`M_2`.
+
+    in_gamma : float [-1 <= in_gamma <= 1]
+        Input gamma, :math:`\\gamma_1`.
+
+    out_gamma : float [-1 <= out_gamma <= 1]
+        Output gamma, :math:`\\gamma_2`.
+
+    n_fft : int >> :math:`M_1, M_2` [scalar]
+        Number of FFT bins. Accurate conversion requires the large value.
+
+    """
+
+    def __init__(self, in_order, out_order, in_gamma, out_gamma, n_fft=512):
         super(GeneralizedCepstrumToGeneralizedCepstrum, self).__init__()
 
         self.in_order = in_order
         self.out_order = out_order
         self.in_gamma = in_gamma
         self.out_gamma = out_gamma
         self.n_fft = n_fft
@@ -41,15 +63,28 @@
         assert 0 <= self.in_order
         assert 0 <= self.out_order
         assert abs(self.in_gamma) <= 1
         assert abs(self.out_gamma) <= 1
         assert max(self.in_order, self.out_order) + 1 < self.n_fft
 
     def forward(self, c1):
-        c01 = torch.cat((c1[..., :1] * 0, c1[..., 1:]), dim=-1)
+        """Perform generalized cepstral transformation.
+
+        Parameters
+        ----------
+        c1 : Tensor [shape=(..., M1+1)]
+            Input cepstrum.
+
+        Returns
+        -------
+        c2 : Tensor [shape=(..., M2+1)]
+            Output cepstrum.
+
+        """
+        c01 = F.pad(c1[..., 1:], (1, 0))
         C1 = torch.fft.fft(c01, n=self.n_fft)
 
         if self.in_gamma == 0:
             sC1 = cexp(C1)
         else:
             C1 *= self.in_gamma
             C1.real += 1
```

## diffsptk/core/mgc2sp.py

```diff
@@ -43,15 +43,15 @@
     norm : bool [scalar]
         If True, assume normalized cepstrum.
 
     mul : bool [scalar]
         If True, assume gamma-multiplied cepstrum.
 
     out_format : ['db', 'log-magnitude', 'magnitude', 'power', \
-                  'cycle', 'radian', 'degree']
+                  'cycle', 'radian', 'degree', 'complex']
         Output format.
 
     n_fft : int >> :math:`L` [scalar]
         Number of FFT bins. Accurate conversion requires the large value.
 
     """
 
@@ -84,14 +84,16 @@
         elif out_format == 4 or out_format == "cycle":
             self.convert = lambda x: x.imag / math.pi
         elif out_format == 5 or out_format == "radian":
             self.convert = lambda x: x.imag
         elif out_format == 6 or out_format == "degree":
             c = 180 / math.pi
             self.convert = lambda x: x.imag * c
+        elif out_format == "complex":
+            self.convert = lambda x: torch.polar(torch.exp(x.real), x.imag)
         else:
             raise ValueError(f"out_format {out_format} is not supported")
 
         self.mgc2c = MelGeneralizedCepstrumToMelGeneralizedCepstrum(
             cep_order,
             fft_length // 2,
             in_alpha=alpha,
```

## diffsptk/core/mglsadf.py

```diff
@@ -13,108 +13,159 @@
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import torch
 import torch.nn as nn
 
+from ..misc.utils import Lambda
 from ..misc.utils import check_size
 from ..misc.utils import get_gamma
+from .b2mc import MLSADigitalFilterCoefficientsToMelCepstrum
+from .gnorm import GeneralizedCepstrumGainNormalization
+from .istft import InverseShortTermFourierTransform
 from .linear_intpl import LinearInterpolation
+from .mc2b import MelCepstrumToMLSADigitalFilterCoefficients
 from .mgc2mgc import MelGeneralizedCepstrumToMelGeneralizedCepstrum
+from .mgc2sp import MelGeneralizedCepstrumToSpectrum
+from .stft import ShortTermFourierTransform
+
+
+def mirror(x, half=False):
+    """Mirror the input tensor.
+
+    Parameters
+    ----------
+    x : Tensor [shape=(..., L)]
+        Input tensor.
+
+    half : bool [scalar]
+        If True, multiply all elements except the first one by 0.5.
+
+    Returns
+    -------
+    y : Tensor [shape=(..., 2L-1)]
+        Output tensor.
+
+    """
+    x0, x1 = torch.split(x, [1, x.size(-1) - 1], dim=-1)
+    if half:
+        x1 = x1 * 0.5
+    y = torch.cat((x1.flip(-1), x0, x1), dim=-1)
+    return y
 
 
 class PseudoMGLSADigitalFilter(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/mglsadf.html>`_
     for details.
 
     Parameters
     ----------
     filter_order : int >= 0 [scalar]
         Order of filter coefficients, :math:`M`.
 
+    frame_period : int >= 1 [scalar]
+        Frame period, :math:`P`.
+
     alpha : float [-1 < alpha < 1]
         Frequency warping factor, :math:`\\alpha`.
 
     gamma : float [-1 <= gamma <= 1]
         Gamma, :math:`\\gamma`.
 
     c : int >= 1 [scalar]
         Number of stages.
 
-    frame_period : int >= 1 [scalar]
-        Frame period, :math:`P`.
-
     ignore_gain : bool [scalar]
         If True, perform filtering without gain.
 
     phase : ['minimum', 'maximum', 'zero']
         Filter type.
 
-    cascade : bool [scalar]
-        If True, use multi-stage FIR filter.
-
-    cep_order : int >= 0 [scalar]
-        Order of linear cepstrum (valid only if **cascade** is True).
+    mode : ['multi-stage', 'single-stage', 'freq-domain']
+        'multi-stage' approximates the MLSA filter by cascading FIR filters based on the
+        Taylor series expansion. 'single-stage' uses a FIR filter whose coefficients are
+        the impulse response converted from input mel-cepstral coefficients using FFT.
+        'freq-domain' performs filtering in the frequency domain rather than time one.
 
     taylor_order : int >= 0 [scalar]
-        Order of Taylor series expansion (valid only if **cascade** is True).
+        Order of Taylor series expansion (valid only if **mode** is 'multi-stage').
+
+    cep_order : int >= 0 [scalar]
+        Order of linear cepstrum (valid only if **mode** is 'multi-stage').
 
-    impulse_response_length : int >= 1 [scalar]
-        Length of impulse response (valid only if **cascade** is False).
+    ir_length : int >= 1 [scalar]
+        Length of impulse response (valid only if **mode** is 'single-stage').
 
     n_fft : int >= 1 [scalar]
-        Number of FFT bins for conversion (valid only if **cascade** is False).
+        Number of FFT bins for conversion (valid only if **mode** is 'single-stage').
+
+    **stft_kwargs : additional keyword arguments
+        See :func:`~diffsptk.ShortTermFourierTransform` (valid only if **mode** is
+        'freq-domain').
 
     References
     ----------
     .. [1] T. Yoshimura et al., "Embedding a differentiable mel-cepstral synthesis
            filter to a neural speech synthesis system," *arXiv:2211.11222*, 2022.
 
     """
 
     def __init__(
         self,
         filter_order,
+        frame_period,
+        *,
         alpha=0,
         gamma=0,
         c=None,
-        frame_period=1,
         ignore_gain=False,
         phase="minimum",
-        cascade=True,
+        mode="multi-stage",
         **kwargs,
     ):
         super(PseudoMGLSADigitalFilter, self).__init__()
 
         self.filter_order = filter_order
         self.frame_period = frame_period
 
         gamma = get_gamma(gamma, c)
 
-        if cascade:
+        if mode == "multi-stage":
             self.mglsadf = MultiStageFIRFilter(
                 filter_order,
+                frame_period,
                 alpha=alpha,
                 gamma=gamma,
-                frame_period=frame_period,
                 ignore_gain=ignore_gain,
                 phase=phase,
                 **kwargs,
             )
-        else:
+        elif mode == "single-stage":
             self.mglsadf = SingleStageFIRFilter(
                 filter_order,
+                frame_period,
+                alpha=alpha,
+                gamma=gamma,
+                ignore_gain=ignore_gain,
+                phase=phase,
+                **kwargs,
+            )
+        elif mode == "freq-domain":
+            self.mglsadf = FrequencyDomainFIRFilter(
+                filter_order,
+                frame_period,
                 alpha=alpha,
                 gamma=gamma,
-                frame_period=frame_period,
                 ignore_gain=ignore_gain,
                 phase=phase,
                 **kwargs,
             )
+        else:
+            raise ValueError(f"mode {mode} is not supported")
 
     def forward(self, x, mc):
         """Apply an MGLSA digital filter.
 
         Parameters
         ----------
         x : Tensor [shape=(..., T)]
@@ -132,15 +183,15 @@
         --------
         >>> M = 4
         >>> x = diffsptk.step(3)
         >>> mc = diffsptk.nrand(2, M)
         >>> mc
         tensor([[-0.9134, -0.5774, -0.4567,  0.7423, -0.5782],
                 [ 0.6904,  0.5175,  0.8765,  0.1677,  2.4624]])
-        >>> mglsadf = diffsptk.PseudoMGLSADigitalFilter(M, frame_period=2)
+        >>> mglsadf = diffsptk.MLSA(M, frame_period=2)
         >>> y = mglsadf(x.view(1, -1), mc.view(1, 2, M + 1))
         >>> y
         tensor([[0.4011, 0.8760, 3.5677, 4.8725]])
 
         """
         check_size(mc.size(-1), self.filter_order + 1, "dimension of mel-cepstrum")
         check_size(x.size(-1), mc.size(-2) * self.frame_period, "sequence length")
@@ -149,27 +200,28 @@
         return y
 
 
 class MultiStageFIRFilter(nn.Module):
     def __init__(
         self,
         filter_order,
+        frame_period,
+        *,
         alpha=0,
         gamma=0,
-        frame_period=1,
         ignore_gain=False,
         phase="minimum",
         taylor_order=20,
         cep_order=199,
     ):
         super(MultiStageFIRFilter, self).__init__()
 
-        self.taylor_order = taylor_order
         self.ignore_gain = ignore_gain
         self.phase = phase
+        self.taylor_order = taylor_order
 
         assert 0 <= self.taylor_order
 
         if self.phase == "minimum":
             self.pad = nn.ConstantPad1d((cep_order, 0), 0)
         elif self.phase == "maximum":
             self.pad = nn.ConstantPad1d((0, cep_order), 0)
@@ -192,17 +244,15 @@
             c[..., 0] = 0
 
         if self.phase == "minimum":
             c = c.flip(-1)
         elif self.phase == "maximum":
             pass
         elif self.phase == "zero":
-            c0, c1 = torch.split(c, [1, c.size(-1) - 1], dim=-1)
-            c1 = c1 * 0.5
-            c = torch.cat((c1.flip(-1), c0, c1), dim=-1)
+            c = mirror(c, half=True)
         else:
             raise RuntimeError
 
         c = self.linear_intpl(c)
 
         y = x.clone()
         for a in range(1, self.taylor_order + 1):
@@ -213,61 +263,145 @@
         return y
 
 
 class SingleStageFIRFilter(nn.Module):
     def __init__(
         self,
         filter_order,
+        frame_period,
+        *,
         alpha=0,
         gamma=0,
-        frame_period=1,
         ignore_gain=False,
         phase="minimum",
-        impulse_response_length=2000,
+        ir_length=2000,
         n_fft=4096,
     ):
         super(SingleStageFIRFilter, self).__init__()
 
         self.ignore_gain = ignore_gain
         self.phase = phase
 
-        taps = impulse_response_length - 1
+        taps = ir_length - 1
         if self.phase == "minimum":
             self.pad = nn.ConstantPad1d((taps, 0), 0)
         elif self.phase == "maximum":
             self.pad = nn.ConstantPad1d((0, taps), 0)
+        elif self.phase == "zero":
+            self.pad = nn.ConstantPad1d((taps, taps), 0)
         else:
             raise ValueError(f"phase {phase} is not supported")
 
-        self.mgc2ir = MelGeneralizedCepstrumToMelGeneralizedCepstrum(
-            filter_order,
-            impulse_response_length - 1,
-            in_alpha=alpha,
-            in_gamma=gamma,
-            out_gamma=1,
-            out_mul=True,
-            n_fft=n_fft,
-        )
+        if self.phase in ["minimum", "maximum"]:
+            self.mgc2ir = MelGeneralizedCepstrumToMelGeneralizedCepstrum(
+                filter_order,
+                ir_length - 1,
+                in_alpha=alpha,
+                in_gamma=gamma,
+                out_gamma=1,
+                out_mul=True,
+                n_fft=n_fft,
+            )
+        else:
+            self.mgc2c = MelGeneralizedCepstrumToMelGeneralizedCepstrum(
+                filter_order,
+                ir_length - 1,
+                in_alpha=alpha,
+                in_gamma=gamma,
+                n_fft=n_fft,
+            )
+            self.c2ir = nn.Sequential(
+                Lambda(lambda x: torch.fft.hfft(x, n=n_fft)),
+                Lambda(lambda x: torch.fft.ifft(torch.exp(x)).real[..., :ir_length]),
+            )
         self.linear_intpl = LinearInterpolation(frame_period)
 
     def forward(self, x, mc):
-        h = self.mgc2ir(mc)
+        if self.phase == "zero":
+            c = self.mgc2c(mc)
+            c[..., 1:] *= 0.5
+            if self.ignore_gain:
+                c[..., 0] = 0
+            h = self.c2ir(c)
+        else:
+            h = self.mgc2ir(mc)
+
         if self.phase == "minimum":
             h = h.flip(-1)
         elif self.phase == "maximum":
             pass
+        elif self.phase == "zero":
+            h = mirror(h)
         else:
             raise RuntimeError
 
         h = self.linear_intpl(h)
+
         if self.ignore_gain:
             if self.phase == "minimum":
                 h = h / h[..., -1:]
             elif self.phase == "maximum":
                 h = h / h[..., :1]
+            elif self.phase == "zero":
+                pass
             else:
                 raise RuntimeError
 
         x = self.pad(x)
         x = x.unfold(-1, h.size(-1), 1)
         y = (x * h).sum(-1)
         return y
+
+
+class FrequencyDomainFIRFilter(nn.Module):
+    def __init__(
+        self,
+        filter_order,
+        frame_period,
+        *,
+        alpha=0,
+        gamma=0,
+        ignore_gain=False,
+        phase="minimum",
+        frame_length=400,
+        fft_length=512,
+        **kwargs,
+    ):
+        super(FrequencyDomainFIRFilter, self).__init__()
+
+        self.ignore_gain = ignore_gain
+
+        if self.ignore_gain:
+            self.gnorm = GeneralizedCepstrumGainNormalization(filter_order, gamma=gamma)
+            self.mc2b = MelCepstrumToMLSADigitalFilterCoefficients(
+                filter_order, alpha=alpha
+            )
+            self.b2mc = MLSADigitalFilterCoefficientsToMelCepstrum(
+                filter_order, alpha=alpha
+            )
+
+        self.stft = ShortTermFourierTransform(
+            frame_length, frame_period, fft_length, out_format="complex", **kwargs
+        )
+        self.istft = InverseShortTermFourierTransform(
+            frame_length, frame_period, fft_length, **kwargs
+        )
+        self.mgc2sp = MelGeneralizedCepstrumToSpectrum(
+            filter_order,
+            fft_length,
+            alpha=alpha,
+            gamma=gamma,
+            out_format="magnitude" if phase == "zero" else "complex",
+        )
+
+    def forward(self, x, mc):
+        if self.ignore_gain:
+            b = self.mc2b(mc)
+            b = self.gnorm(b)
+            b[..., 0] = 0
+            mc = self.b2mc(b)
+
+        H = self.mgc2sp(mc)
+        X = self.stft(x)
+        Y = H * X
+        y = self.istft(Y, out_length=x.size(-1))
+        return y
```

## diffsptk/core/mpir2c.py

```diff
@@ -26,32 +26,32 @@
     for details. The conversion uses FFT instead of recursive formula.
 
     Parameters
     ----------
     cep_order : int >= 0 [scalar]
         Order of cepstrum, :math:`M`.
 
-    impulse_response_length : int >= 1 [scalar]
+    ir_length : int >= 1 [scalar]
         Length of impulse response, :math:`N`.
 
     n_fft : int >> :math:`N` [scalar]
         Number of FFT bins. Accurate conversion requires the large value.
 
     """
 
-    def __init__(self, cep_order, impulse_response_length, n_fft=512):
+    def __init__(self, cep_order, ir_length, n_fft=512):
         super(MinimumPhaseImpulseResponseToCepstrum, self).__init__()
 
         self.cep_order = cep_order
-        self.impulse_response_length = impulse_response_length
+        self.ir_length = ir_length
         self.n_fft = n_fft
 
         assert 0 <= self.cep_order
-        assert 1 <= self.impulse_response_length
-        assert max(self.cep_order + 1, self.impulse_response_length) < self.n_fft
+        assert 1 <= self.ir_length
+        assert max(self.cep_order + 1, self.ir_length) < self.n_fft
 
     def forward(self, h):
         """Convert minimum phase impulse response to cepstrum.
 
         Parameters
         ----------
         h : Tensor [shape=(..., N)]
@@ -67,13 +67,13 @@
         >>> h = diffsptk.ramp(4, 0, -1)
         >>> mpir2c = diffsptk.MinimumPhaseImpulseResponseToCepstrum(3, 5)
         >>> c = mpir2c(h)
         >>> c
         tensor([1.3863, 0.7500, 0.2188, 0.0156])
 
         """
-        check_size(h.size(-1), self.impulse_response_length, "impulse response length")
+        check_size(h.size(-1), self.ir_length, "impulse response length")
 
         H = torch.fft.fft(h, n=self.n_fft)
         c = torch.fft.ifft(clog(H))[..., : self.cep_order + 1].real
         c[..., 1:] *= 2
         return c
```

## diffsptk/core/msvq.py

```diff
@@ -34,15 +34,15 @@
     codebook_size : int >= 1 [scalar]
         Codebook size, :math:`K`.
 
     n_stage : int >= 1 [scalar]
         Number of stages (quantizers), :math:`Q`.
 
     **kwargs : additional keyword arguments
-        See vector-quantize-pytorch repository for details.
+        See `this page`_ for details.
 
     """
 
     def __init__(self, order, codebook_size, n_stage, **kwargs):
         super(MultiStageVectorQuantization, self).__init__()
 
         assert 0 <= order
@@ -65,15 +65,15 @@
         x : Tensor [shape=(..., M+1)]
             Input vectors.
 
         codebooks : Tensor [shape=(Q, K, M+1)]
             External codebooks. If None, use internal codebooks.
 
         **kwargs : additional keyword arguments
-            See vector-quantize-pytorch repository for details.
+            See `this page`_ for details.
 
         Returns
         -------
         xq : Tensor [shape=(..., M+1)]
             Quantized vectors.
 
         indices : Tensor [shape=(..., Q)]
@@ -100,15 +100,15 @@
             for i, layer in enumerate(self.vq.layers):
                 layer._codebook.embed[:] = codebooks.view_as(cb)[i]
 
         d = x.dim()
         if d == 1:
             x = x.unsqueeze(0)
 
-        xq, indices, losses = self.vq(x, **kwargs)
+        xq, indices, losses = self.vq(x.float(), **kwargs)
 
         if d == 1:
             xq = xq.squeeze(0)
             indices = indices.squeeze(0)
         losses = losses.squeeze()
 
         return xq, indices, losses
```

## diffsptk/core/phase.py

```diff
@@ -14,14 +14,15 @@
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import math
 
 import torch
 import torch.nn as nn
+import torch.nn.functional as F
 
 
 class Phase(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/phase.html>`_
     for details.
 
     Parameters
@@ -69,16 +70,15 @@
         """
         B = torch.fft.rfft(b, n=self.fft_length)
 
         if a is None:
             p = torch.atan2(B.imag, B.real)
         else:
             K, a = torch.split(a, [1, a.size(-1) - 1], dim=-1)
-            K = K * 0 + 1
-            a = torch.cat((K, a), dim=-1)
+            a = F.pad(a, (1, 0), value=1)
             A = torch.fft.rfft(a, n=self.fft_length)
             p = torch.atan2(
                 B.imag * A.real - B.real * A.imag, B.real * A.real + B.imag * A.imag
             )
 
         # Convert to cycle [-1, 1].
         p /= math.pi
```

## diffsptk/core/pitch.py

```diff
@@ -46,15 +46,15 @@
 
     f_min : float >= 0 [scalar]
         Minimum frequency in Hz.
 
     f_max : float <= sample_rate // 2 [scalar]
         Maximum frequency in Hz.
 
-    threshold : float [scalar]
+    voicing_threshold : float [scalar]
         Voiced/unvoiced threshold.
 
     silence_threshold : float [scalar]
         Silence threshold in dB.
 
     filter_length : int >= 1 [scalar]
         Window length of median and moving average filters.
@@ -196,26 +196,26 @@
 
     def __init__(
         self,
         frame_period,
         sample_rate,
         f_min=0,
         f_max=None,
-        threshold=1e-2,
+        voicing_threshold=1e-2,
         silence_threshold=-60,
         filter_length=3,
         model="full",
     ):
         super(PitchExtractionByCrepe, self).__init__()
 
         self.torchcrepe = importlib.import_module("torchcrepe")
 
         self.f_min = f_min
         self.f_max = self.torchcrepe.MAX_FMAX if f_max is None else f_max
-        self.threshold = threshold
+        self.voicing_threshold = voicing_threshold
         self.silence_threshold = silence_threshold
         self.filter_length = filter_length
         self.model = model
 
         assert 0 <= self.f_min < self.f_max <= sample_rate / 2
         assert self.model in ("tiny", "full")
 
@@ -251,15 +251,15 @@
         return self.forward(x, embed=False)
 
     def calc_embed(self, x):
         return self.forward(x, embed=True)
 
     def calc_pitch(self, x):
         # Compute pitch probabilities.
-        prob = self.calc_prob(x).transpose(-2, -1)
+        prob = self.calc_prob(x).mT
 
         # Decode pitch probabilities.
         pitch, periodicity = self.torchcrepe.postprocess(
             prob,
             fmin=self.f_min,
             fmax=self.f_max,
             decoder=self.torchcrepe.decode.viterbi,
@@ -272,11 +272,11 @@
         pitch = self.torchcrepe.filter.mean(pitch, self.filter_length)
 
         # Decide voiced/unvoiced.
         loudness = self.stft(x) + self.weights
         loudness = torch.clip(loudness, min=self.torchcrepe.loudness.MIN_DB)
         loudness = loudness.mean(-1)
         mask = torch.logical_or(
-            periodicity < self.threshold, loudness < self.silence_threshold
+            periodicity < self.voicing_threshold, loudness < self.silence_threshold
         )
         pitch[mask] = UNVOICED_SYMBOL
         return pitch
```

## diffsptk/core/pqmf.py

```diff
@@ -10,14 +10,16 @@
 # Unless required by applicable law or agreed to in writing, software      #
 # distributed under the License is distributed on an "AS IS" BASIS,        #
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
+import warnings
+
 import numpy as np
 import torch.nn as nn
 import torch.nn.functional as F
 
 from ..misc.utils import next_power_of_two
 from ..misc.utils import numpy_to_torch
 
@@ -28,14 +30,59 @@
     mode="analysis",
     alpha=100,
     n_iter=100,
     step_size=1e-2,
     decay=0.5,
     eps=1e-6,
 ):
+    """Make filter-bank coefficients.
+
+    Parameters
+    ----------
+    n_band : int >= 1 [scalar]
+        Number of subbands, :math:`K`.
+
+    filter_order : int >= 1 [scalar]
+        Order of filter, :math:`M`.
+
+    mode : ['analysis' or 'synthesis']
+        Analysis or synthesis.
+
+    alpha : float > 0 [scalar]
+        Stopband attenuation in dB.
+
+    n_iter : int >= 1 [scalar]
+        Number of iterations.
+
+    step_size : float > 0 [scalar]
+        Step size.
+
+    decay : float > 0 [scalar]
+        Decay factor of step size.
+
+    eps : float >= 0 [scalar]
+        Tolerance.
+
+    Returns
+    -------
+    filters : ndarray [shape=(K, M + 1)]
+        Filter-bank coefficients.
+
+    is_converged : bool
+        Whether the algorithm converged.
+
+    """
+    assert 1 <= n_band
+    assert 1 <= filter_order
+    assert 1 <= n_iter
+    assert 0 < alpha
+    assert 0 < step_size
+    assert 0 < decay
+    assert 0 <= eps
+
     def alpha_to_beta(alpha):
         if alpha <= 21:
             return 0
         elif alpha <= 50:
             a = alpha - 21
             return 0.5842 * np.power(a, 0.4) + 0.07886 * a
         else:
@@ -47,26 +94,28 @@
 
     fft_length = next_power_of_two(filter_order + 1)
     index = fft_length // (4 * n_band)
 
     omega = np.pi / (2 * n_band)
     best_abs_error = np.inf
 
+    is_converged = False
     for _ in range(n_iter):
         with np.errstate(invalid="ignore"):
             h = np.sin(omega * x) / (np.pi * x)
         if filter_order % 2 == 0:
             h[filter_order // 2] = omega / np.pi
 
         prototype_filter = h * w
         H = np.fft.rfft(prototype_filter, n=fft_length)
 
         error = np.square(np.abs(H[index])) - 0.5
         abs_error = np.abs(error)
         if abs_error < eps:
+            is_converged = True
             break
 
         if abs_error < best_abs_error:
             best_abs_error = abs_error
             omega -= np.sign(error) * step_size
         else:
             step_size *= decay
@@ -81,16 +130,17 @@
 
     filters = []
     for k in range(n_band):
         a = ((2 * k + 1) * np.pi / (2 * n_band)) * x
         b = (-1) ** k * (np.pi / 4) * sign
         c = 2 * prototype_filter
         filters.append(c * np.cos(a + b))
+    filters = np.asarray(filters)
 
-    return np.asarray(filters)
+    return filters, is_converged
 
 
 class PseudoQuadratureMirrorFilterBanks(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/pqmf.html>`_
     for details.
 
     Parameters
@@ -100,28 +150,42 @@
 
     filter_order : int >= 2 [scalar]
         Order of filter, :math:`M`.
 
     alpha : float > 0 [scalar]
         Stopband attenuation in dB.
 
+    learnable : bool [scalar]
+        Whether to make filter-bank coefficients learnable.
+
+    **kwargs : additional keyword arguments
+        Parameters to find optimal filter-bank coefficients.
+
     """
 
-    def __init__(self, n_band, filter_order, alpha=100):
+    def __init__(self, n_band, filter_order, alpha=100, learnable=False, **kwargs):
         super(PseudoQuadratureMirrorFilterBanks, self).__init__()
 
         assert 1 <= n_band
         assert 2 <= filter_order
         assert 0 < alpha
 
         # Make filterbanks.
-        filters = make_filter_banks(n_band, filter_order, "analysis", alpha=alpha)
+        filters, is_converged = make_filter_banks(
+            n_band, filter_order, mode="analysis", alpha=alpha, **kwargs
+        )
+        if not is_converged:
+            warnings.warn("Failed to find PQMF coefficients")
         filters = np.expand_dims(filters, 1)
         filters = np.flip(filters, 2).copy()
-        self.register_buffer("filters", numpy_to_torch(filters))
+        filters = numpy_to_torch(filters)
+        if learnable:
+            self.filters = nn.Parameter(filters)
+        else:
+            self.register_buffer("filters", filters)
 
         # Make padding module.
         if filter_order % 2 == 0:
             delay_left = filter_order // 2
             delay_right = filter_order // 2
         else:
             delay_left = (filter_order + 1) // 2
```

## diffsptk/core/root_pol.py

```diff
@@ -13,14 +13,15 @@
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import numpy as np
 import torch
 import torch.nn as nn
+import torch.nn.functional as F
 
 from ..misc.utils import check_size
 from ..misc.utils import numpy_to_torch
 from ..misc.utils import vander
 
 
 class DurandKernerMethod(nn.Module):
@@ -104,15 +105,15 @@
             keepdim=True,
         )
         center = -a[..., :1] / self.order
         x = torch.complex(
             center + radius * self.cos,
             center + radius * self.sin,
         )
-        a = torch.cat((a[..., :1] * 0 + 1, a), dim=-1)
+        a = F.pad(a, (1, 0), value=1)
         a = a.unsqueeze(-1).to(x.dtype)
 
         for _ in range(self.n_iter):
             y = x
             for m in range(self.order):
                 xm = x[..., m : m + 1]
                 v = vander(xm, N=self.order + 1)
```

## diffsptk/core/smcep.py

```diff
@@ -19,119 +19,32 @@
 import torch.nn as nn
 
 from ..misc.utils import check_size
 from ..misc.utils import hankel
 from ..misc.utils import is_power_of_two
 from ..misc.utils import numpy_to_torch
 from ..misc.utils import symmetric_toeplitz
-
-
-def warp(omega, alpha, theta):
-    x = omega - theta
-    y = omega + theta
-    return (
-        omega
-        + np.arctan2(alpha * np.sin(x), 1 - alpha * np.cos(x))
-        + np.arctan2(alpha * np.sin(y), 1 - alpha * np.cos(y))
-    )
-
-
-class SecondOrderAllPassFrequencyTransform(nn.Module):
-    def __init__(self, in_order, out_order, fft_length, alpha, theta):
-        super(SecondOrderAllPassFrequencyTransform, self).__init__()
-
-        assert 0 <= in_order
-        assert 0 <= out_order
-        assert in_order < fft_length
-        assert abs(alpha) < 1
-        assert 0 <= theta <= 1
-
-        def diff_warp(omega, alpha, theta):
-            x = omega - theta
-            y = omega + theta
-            a1 = alpha
-            a2 = alpha + alpha
-            aa = alpha * alpha
-            return (
-                1
-                + (a1 * np.cos(x) - aa) / (1 - a2 * np.cos(x) + aa)
-                + (a1 * np.cos(y) - aa) / (1 - a2 * np.cos(y) + aa)
-            )
-
-        theta *= np.pi
-        delta = 2 * np.pi / fft_length
-        omega = np.arange(fft_length) * delta
-        ww = warp(omega, alpha, theta)
-        dw = diff_warp(omega, alpha, theta)
-
-        m2 = np.arange(out_order + 1)
-        wwm2 = ww.reshape(-1, 1) * m2.reshape(1, -1)
-        real = np.cos(wwm2) * dw.reshape(-1, 1)
-        imag = -np.sin(wwm2) * dw.reshape(-1, 1)
-
-        M1 = in_order + 1
-        A = np.fft.ifft(real + 1j * imag, axis=0).real
-        if 2 <= M1:
-            A[1:M1] += np.flip(A[-(M1 - 1) :], axis=0)
-        A = A[:M1]
-        A[1:, 0] /= 2
-        A[0, 1:] *= 2
-        self.register_buffer("A", numpy_to_torch(A))
-
-    def forward(self, c1):
-        c2 = torch.matmul(c1, self.A)
-        return c2
-
-
-class SecondOrderAllPassInverseFrequencyTransform(nn.Module):
-    def __init__(self, in_order, out_order, fft_length, alpha, theta):
-        super(SecondOrderAllPassInverseFrequencyTransform, self).__init__()
-
-        assert 0 <= in_order
-        assert 0 <= out_order
-        assert out_order < fft_length
-        assert abs(alpha) < 1
-        assert 0 <= theta <= 1
-
-        theta *= np.pi
-        delta = 2 * np.pi / fft_length
-        omega = np.arange(fft_length) * delta
-        ww = warp(omega, alpha, theta)
-
-        m1 = np.arange(-in_order, in_order + 1)
-        wwm1 = ww.reshape(-1, 1) * m1.reshape(1, -1)
-        real = np.cos(wwm1)
-        imag = -np.sin(wwm1)
-
-        M2 = out_order + 1
-        A = np.fft.ifft(real + 1j * imag, axis=0).real
-        A[:M2, in_order + 1 :] += np.flip(A[:M2, :in_order], axis=1)
-        A = A[:M2, in_order:]
-        A[0, 1:] /= 2
-        A[1:, 0] *= 2
-        self.register_buffer("A", numpy_to_torch(A.T))
-
-    def forward(self, c2):
-        c1 = torch.matmul(c2, self.A)
-        return c1
+from .freqt2 import SecondOrderAllPassFrequencyTransform
+from .freqt2 import warp
+from .ifreqt2 import SecondOrderAllPassInverseFrequencyTransform
 
 
 class CoefficientsFrequencyTransform(nn.Module):
-    def __init__(self, in_order, out_order, fft_length, alpha, theta):
+    def __init__(self, in_order, out_order, alpha, theta, n_fft=512):
         super(CoefficientsFrequencyTransform, self).__init__()
 
         assert 0 <= in_order
         assert 0 <= out_order
-        assert out_order < fft_length
+        assert out_order < n_fft
         assert abs(alpha) < 1
         assert 0 <= theta <= 1
 
         theta *= np.pi
-        delta = 2 * np.pi / fft_length
-        omega = np.arange(fft_length) * delta
+        delta = 2 * np.pi / n_fft
+        omega = np.arange(n_fft) * delta
         ww = warp(omega, alpha, theta)
 
         m2 = np.arange(out_order + 1)
         wwm2 = ww.reshape(-1, 1) * m2.reshape(1, -1)
         real = np.cos(wwm2)
         imag = -np.sin(wwm2)
 
@@ -187,40 +100,40 @@
         assert self.cep_order <= self.fft_length // 2
         assert is_power_of_two(self.fft_length)
         assert 0 <= self.n_iter
 
         self.freqt = SecondOrderAllPassFrequencyTransform(
             self.fft_length // 2,
             self.cep_order,
-            self.fft_length * accuracy_factor,
             alpha,
             theta,
+            self.fft_length * accuracy_factor,
         )
         self.ifreqt = SecondOrderAllPassInverseFrequencyTransform(
             self.cep_order,
             self.fft_length // 2,
-            self.fft_length * accuracy_factor,
             alpha,
             theta,
+            self.fft_length * accuracy_factor,
         )
         self.rfreqt = CoefficientsFrequencyTransform(
             self.fft_length // 2,
             2 * self.cep_order,
-            self.fft_length * accuracy_factor,
             alpha,
             theta,
+            self.fft_length * accuracy_factor,
         )
 
         seed = np.ones(1)
         alpha_vector = CoefficientsFrequencyTransform(
             0,
             self.cep_order,
-            self.fft_length * accuracy_factor,
             alpha,
             theta,
+            self.fft_length * accuracy_factor,
         )(numpy_to_torch(seed))
         self.register_buffer("alpha_vector", alpha_vector)
 
     def forward(self, x):
         """Estimate mel-cepstrum from spectrum.
 
         Parameters
```

## diffsptk/core/spec.py

```diff
@@ -12,14 +12,15 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
 # See the License for the specific language governing permissions and      #
 # limitations under the License.                                           #
 # ------------------------------------------------------------------------ #
 
 import torch
 import torch.nn as nn
+import torch.nn.functional as F
 
 
 class Spectrum(nn.Module):
     """See `this page <https://sp-nitech.github.io/sptk/latest/main/spec.html>`_
     for details.
 
     Parameters
@@ -91,15 +92,15 @@
         tensor([36.0000, 25.3137,  8.0000,  2.6863,  4.0000])
 
         """
         X = torch.fft.rfft(b, n=self.fft_length).abs()
 
         if a is not None:
             K, a1 = torch.split(a, [1, a.size(-1) - 1], dim=-1)
-            a = torch.cat((K * 0 + 1, a1), dim=-1)
+            a = F.pad(a1, (1, 0), value=1)
             X /= torch.fft.rfft(a, n=self.fft_length).abs()
             X *= K
 
         y = torch.square(X) + self.eps
         if self.relative_floor is not None:
             m, _ = torch.max(y, dim=-1, keepdim=True)
             y = torch.maximum(y, m * self.relative_floor)
```

## diffsptk/core/unframe.py

```diff
@@ -17,15 +17,15 @@
 import torch.nn as nn
 import torch.nn.functional as F
 
 from .window import Window
 
 
 class Unframe(nn.Module):
-    """This is the opposite module to Frame.
+    """This is the opposite module to :func:`~diffsptk.Frame`.
 
     Parameters
     ----------
     frame_length : int >= 1 [scalar]
         Frame length, :math:`L`.
 
     frame_peirod : int >= 1 [scalar]
@@ -116,15 +116,15 @@
             )
             s = self.left_pad_width
             e = None if out_length is None else s + out_length
             x = x[..., 0, 0, s:e]
             return x
 
         w = self.window.repeat(1, 1, N)
-        x = y.transpose(-2, -1)
+        x = y.mT
 
         if d == 2:
             x = x.unsqueeze(0)
 
         w = fold(w)
         x = fold(x)
         x = x / w
```

## diffsptk/core/vq.py

```diff
@@ -31,15 +31,15 @@
     order : int >= 0 [scalar]
         Order of vector, :math:`M`.
 
     codebook_size : int >= 1 [scalar]
         Codebook size, :math:`K`.
 
     **kwargs : additional keyword arguments
-        See vector-quantize-pytorch repository for details.
+        See `this page`_ for details.
 
     """
 
     def __init__(self, order, codebook_size, **kwargs):
         super(VectorQuantization, self).__init__()
 
         assert 0 <= order
@@ -61,15 +61,15 @@
         x : Tensor [shape=(..., M+1)]
             Input vectors.
 
         codebook : Tensor [shape=(K, M+1)]
             External codebook. If None, use internal codebook.
 
         **kwargs : additional keyword arguments
-            See vector-quantize-pytorch repository for details.
+            See `this page`_ for details.
 
         Returns
         -------
         xq : Tensor [shape=(..., M+1)]
             Quantized vectors.
 
         indices : Tensor [shape=(...,)]
@@ -92,15 +92,15 @@
         if codebook is not None:
             self.codebook[:] = codebook.view_as(self.vq.codebook)
 
         d = x.dim()
         if d == 1:
             x = x.unsqueeze(0)
 
-        xq, indices, loss = self.vq(x)
+        xq, indices, loss = self.vq(x.float())
 
         if d == 1:
             xq = xq.squeeze(0)
             indices = indices.squeeze(0)
         loss = loss.squeeze()
 
         return xq, indices, loss
```

## diffsptk/core/zerodf.py

```diff
@@ -33,15 +33,15 @@
         Frame period, :math:`P`.
 
     ignore_gain : bool [scalar]
         If True, perform filtering without gain.
 
     """
 
-    def __init__(self, filter_order, frame_period=1, ignore_gain=False):
+    def __init__(self, filter_order, frame_period, ignore_gain=False):
         super(AllZeroDigitalFilter, self).__init__()
 
         self.filter_order = filter_order
         self.frame_period = frame_period
         self.ignore_gain = ignore_gain
 
         assert 0 <= self.filter_order
@@ -65,15 +65,15 @@
         y : Tensor [shape=(..., T)]
             Output signal.
 
         Examples
         --------
         >>> x = diffsptk.step(4)
         >>> h = diffsptk.ramp(4)
-        >>> zerodf = diffsptk.AllZeroDigitalFilter(0)
+        >>> zerodf = diffsptk.AllZeroDigitalFilter(0, 1)
         >>> y = zerodf(x, h.view(-1, 1))
         >>> y
         tensor([[0., 1., 2., 3., 4.]])
 
         """
         check_size(h.size(-1), self.filter_order + 1, "dimension of impulse response")
         check_size(x.size(-1), h.size(-2) * self.frame_period, "sequence length")
```

## diffsptk/misc/signals.py

```diff
@@ -26,14 +26,17 @@
     for details.
 
     Parameters
     ----------
     order : int >= 0 [scalar]
         Order of sequence, :math:`M`.
 
+    kwargs : additional keyword arguments
+        See `torch.eye <https://pytorch.org/docs/stable/generated/torch.eye.html>`_.
+
     Returns
     -------
     x : Tensor [shape=(M+1,)]
         Impulse sequence.
 
     Examples
     --------
@@ -56,14 +59,17 @@
     ----------
     order : int >= 0 [scalar]
         Order of sequence, :math:`M`.
 
     value : float [scalar]
         Step value.
 
+    kwargs : additional keyword arguments
+        See `torch.full <https://pytorch.org/docs/stable/generated/torch.full.html>`_.
+
     Returns
     -------
     x : Tensor [shape=(M+1,)]
         Step sequence.
 
     Examples
     --------
@@ -92,14 +98,18 @@
 
     step : float != 0 [scalar]
         Slope.
 
     eps : float [scalar]
         A correction value.
 
+    kwargs : additional keyword arguments
+        See `torch.arange
+        <https://pytorch.org/docs/stable/generated/torch.arange.html>`_.
+
     Returns
     -------
     x : Tensor [shape=(?,)]
         Ramp sequence.
 
     Examples
     --------
@@ -134,14 +144,18 @@
 
     period : float > 0 [scalar]
         Period.
 
     magnitude : float [scalar]
         Magnitude.
 
+    kwargs : additional keyword arguments
+        See `torch.arange
+        <https://pytorch.org/docs/stable/generated/torch.arange.html>`_.
+
     Returns
     -------
     x : Tensor [shape=(M+1,)]
         Sinusoidal sequence.
 
     Examples
     --------
@@ -170,14 +184,17 @@
 
     frame_period : float >= 1 [scalar]
         Frame period.
 
     norm : ['none', 'power', 'magnitude']
         Normalization type.
 
+    **kwargs : additional keyword arguments
+        See `torch.zeros <https://pytorch.org/docs/stable/generated/torch.zeros.html>`_.
+
     Returns
     -------
     x : Tensor [shape=(M+1,)]
         Pulse sequence.
 
     Examples
     --------
@@ -224,14 +241,17 @@
 
     stdv : float >= 0 [scalar]
         Standard deviation.
 
     var : float >= 0 [scalar]
         Variance.
 
+    **kwargs : additional keyword arguments
+        See `torch.randn <https://pytorch.org/docs/stable/generated/torch.randn.html>`_.
+
     Returns
     -------
     x : Tensor [shape=(M+1,)]
         Random value sequence.
 
     Examples
     --------
```

## diffsptk/misc/utils.py

```diff
@@ -109,15 +109,15 @@
             "22050": 0.45,
             "32000": 0.50,
             "44100": 0.53,
             "48000": 0.55,
         }
         key = str(int(sr))
         if key not in sr_to_alpha:
-            raise NotImplementedError
+            raise ValueError("unsupported sample rate: {sr}")
         selected_alpha = sr_to_alpha[key]
         return selected_alpha
 
     def get_auto_alpha(sr, n_freq, n_alpha):
         # Compute target mel-frequencies.
         freq = np.arange(n_freq) * (0.5 * sr / (n_freq - 1))
         mel_freq = np.log(1 + freq / 1000)
@@ -141,15 +141,15 @@
         return selected_alpha
 
     if mode == "hts":
         alpha = get_hts_alpha(sr)
     elif mode == "auto":
         alpha = get_auto_alpha(sr, n_freq, n_alpha)
     else:
-        raise NotImplementedError
+        raise ValueError("only hts and auto are supported")
 
     return alpha
 
 
 def get_gamma(gamma, c):
     if c is None or c == 0:
         return gamma
@@ -191,61 +191,67 @@
     return torch.log(x.abs())
 
 
 def check_size(x, y, cause):
     assert x == y, f"Unexpected {cause} (input {x} vs target {y})"
 
 
-def read(filename, double=False):
+def read(filename, double=False, **kwargs):
     """Read waveform from file.
 
     Parameters
     ----------
     filename : str [scalar]
         Path of wav file.
 
     double : bool [scalar]
         If True, return double-type tensor.
 
+    kwargs : additional keyword arguments
+        Additional arguments passed to `soundfile.read`.
+
     Returns
     -------
     x : Tensor
         Waveform.
 
     Examples
     --------
     >>> x, sr = diffsptk.read("assets/data.wav")
     >>> x
     tensor([ 0.0002,  0.0004,  0.0006,  ...,  0.0006, -0.0006, -0.0007])
     >>> sr
     16000
 
     """
-    x, sr = sf.read(filename)
+    x, sr = sf.read(filename, **kwargs)
     if double:
         x = torch.DoubleTensor(x)
     else:
         x = torch.FloatTensor(x)
     return x, sr
 
 
-def write(filename, x, sr):
+def write(filename, x, sr, **kwargs):
     """Write waveform to file.
 
     Parameters
     ----------
     filename : str [scalar]
         Path of wav file.
 
     x : Tensor
         Waveform.
 
     sr : int [scalar]
         Sample rate in Hz.
 
+    kwargs : additional keyword arguments
+        Additional arguments passed to `soundfile.write`.
+
     Examples
     --------
     >>> x, sr = diffsptk.read("assets/data.wav")
     >>> diffsptk.write("out.wav", x, sr)
 
     """
-    sf.write(filename, x.cpu().numpy(), sr)
+    sf.write(filename, x.cpu().numpy(), sr, **kwargs)
```

## Comparing `diffsptk-0.6.0.dist-info/LICENSE` & `diffsptk-1.0.0.dist-info/licenses/LICENSE`

 * *Files identical despite different names*

## Comparing `diffsptk-0.6.0.dist-info/METADATA` & `diffsptk-1.0.0.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,57 +1,64 @@
 Metadata-Version: 2.1
 Name: diffsptk
-Version: 0.6.0
+Version: 1.0.0
 Summary: Speech signal processing modules for machine learning
-Home-page: https://github.com/sp-nitech/diffsptk
+Project-URL: Homepage, https://sp-tk.sourceforge.net/
+Project-URL: Documentation, https://sp-nitech.github.io/diffsptk/latest/
+Project-URL: Source, https://github.com/sp-nitech/diffsptk
 Author: SPTK Working Group
-Author-email: takenori@sp.nitech.ac.jp
+Maintainer-email: Takenori Yoshimura <takenori@sp.nitech.ac.jp>
 License: Apache 2.0
-Keywords: dsp speech signal processing sptk pytorch
+License-File: LICENSE
+Keywords: dsp,pytorch,signal processing,sptk
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python :: 3.8
-Requires-Python: >= 3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: soundfile
-Requires-Dist: torch (>=1.10.0)
-Requires-Dist: torchcrepe (>=0.0.16)
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Requires-Python: >=3.8
 Requires-Dist: numpy
-Requires-Dist: vector-quantize-pytorch (>=0.8.0)
+Requires-Dist: soundfile
+Requires-Dist: torch>=1.11.0
+Requires-Dist: torchcrepe<=0.0.18,>=0.0.16
+Requires-Dist: torchlpc>=0.2.0
+Requires-Dist: vector-quantize-pytorch>=0.8.0
 Provides-Extra: dev
-Requires-Dist: black ; extra == 'dev'
-Requires-Dist: flake8 ; extra == 'dev'
-Requires-Dist: isort ; extra == 'dev'
-Requires-Dist: numpydoc ; extra == 'dev'
-Requires-Dist: pydata-sphinx-theme ; extra == 'dev'
-Requires-Dist: pytest ; extra == 'dev'
-Requires-Dist: pytest-cov ; extra == 'dev'
-Requires-Dist: sphinx (<6) ; extra == 'dev'
-Requires-Dist: twine ; extra == 'dev'
+Requires-Dist: black; extra == 'dev'
+Requires-Dist: build; extra == 'dev'
+Requires-Dist: isort; extra == 'dev'
+Requires-Dist: numpydoc; extra == 'dev'
+Requires-Dist: pydata-sphinx-theme; extra == 'dev'
+Requires-Dist: pyproject-flake8; extra == 'dev'
+Requires-Dist: pytest; extra == 'dev'
+Requires-Dist: pytest-cov; extra == 'dev'
+Requires-Dist: sphinx; extra == 'dev'
+Requires-Dist: twine; extra == 'dev'
+Description-Content-Type: text/markdown
 
 diffsptk
 ========
 *diffsptk* is a differentiable version of [SPTK](https://github.com/sp-nitech/SPTK) based on the PyTorch framework.
 
 [![Latest Manual](https://img.shields.io/badge/docs-latest-blue.svg)](https://sp-nitech.github.io/diffsptk/latest/)
-[![Stable Manual](https://img.shields.io/badge/docs-stable-blue.svg)](https://sp-nitech.github.io/diffsptk/0.6.0/)
+[![Stable Manual](https://img.shields.io/badge/docs-stable-blue.svg)](https://sp-nitech.github.io/diffsptk/1.0.0/)
 [![Downloads](https://pepy.tech/badge/diffsptk)](https://pepy.tech/project/diffsptk)
 [![Python Version](https://img.shields.io/pypi/pyversions/diffsptk.svg)](https://pypi.python.org/pypi/diffsptk)
-[![PyTorch Version](https://img.shields.io/badge/pytorch-1.10.0%20%7C%201.13.1-orange.svg)](https://pypi.python.org/pypi/diffsptk)
+[![PyTorch Version](https://img.shields.io/badge/pytorch-1.11.0%20%7C%202.0.1-orange.svg)](https://pypi.python.org/pypi/diffsptk)
 [![PyPI Version](https://img.shields.io/pypi/v/diffsptk.svg)](https://pypi.python.org/pypi/diffsptk)
 [![Codecov](https://codecov.io/gh/sp-nitech/diffsptk/branch/master/graph/badge.svg)](https://app.codecov.io/gh/sp-nitech/diffsptk)
 [![License](https://img.shields.io/github/license/sp-nitech/diffsptk.svg)](https://github.com/sp-nitech/diffsptk/blob/master/LICENSE)
 [![GitHub Actions](https://github.com/sp-nitech/diffsptk/workflows/package/badge.svg)](https://github.com/sp-nitech/diffsptk/actions)
 [![Code Style](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
 
 
 Requirements
 ------------
 - Python 3.8+
-- PyTorch 1.10.0+
+- PyTorch 1.11.0+
 
 
 Documentation
 -------------
 See [this page](https://sp-nitech.github.io/diffsptk/latest/) for a reference manual.
 
 
@@ -88,15 +95,15 @@
 
 # Estimate mel-cepstrum of x.
 alpha = diffsptk.get_alpha(sr)
 mcep = diffsptk.MelCepstralAnalysis(cep_order=M, fft_length=n_fft, alpha=alpha, n_iter=10)
 mc = mcep(X)
 
 # Reconstruct x.
-mlsa = diffsptk.MLSA(filter_order=M, alpha=alpha, frame_period=fp, taylor_order=30)
+mlsa = diffsptk.MLSA(filter_order=M, frame_period=fp, alpha=alpha, taylor_order=30)
 x_hat = mlsa(mlsa(x, -mc), mc)
 
 # Write reconstructed waveform.
 diffsptk.write("reconst.wav", x_hat, sr)
 
 # Compute error.
 error = (x_hat - x).abs().sum()
@@ -205,7 +212,19 @@
 print(error)
 ```
 
 
 License
 -------
 This software is released under the Apache License 2.0.
+
+
+Reference
+---------
+```bibtex
+@InProceedings{sp-nitech2023sptk,
+  author = {Takenori Yoshimura and Takato Fujimoto and Keiichiro Oura and Keiichi Tokuda},
+  title = {{SPTK4}: An open-source software toolkit for speech signal processing},
+  booktitle = {12th ISCA Workshop on Speech Synthesis (SSW 12)},
+  year = {2023},
+}
+```
```

## Comparing `diffsptk-0.6.0.dist-info/RECORD` & `diffsptk-1.0.0.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,82 +1,89 @@
 diffsptk/__init__.py,sha256=_wyAsnBjNz4napGjp_ncVQ66mOyhFXjB1uYDq0PK-1Q,111
-diffsptk/version.py,sha256=cID1jLnC_vj48GgMN6Yb1FA3JsQ95zNmCHmRYE8TFhY,22
-diffsptk/core/__init__.py,sha256=n_k3KWHZBeO0qMKHr9P-VLcZcuZTvSm3gGSUgHLLuY4,4260
-diffsptk/core/acorr.py,sha256=Rx7jYJogMl3yEv64fsmiRxNMdaWp0KHCgB35WFuiVhg,3318
-diffsptk/core/b2mc.py,sha256=9PE5noAKHXyFXWN-WRu8D6zDBJm5YyV8OdTTGm6ldao,2667
+diffsptk/version.py,sha256=J-j-u0itpEFT6irdmWmixQqYMadNl1X91TxUmoiLHMI,22
+diffsptk/core/__init__.py,sha256=uZNwzXXcFiKnsRfexNcaiO0wrZWm98_ws9r666RTQHo,4623
+diffsptk/core/acorr.py,sha256=-Dhc7g146i6DR0zjr1B4kBxbtIEaeh9N2Fm8gr0EgK8,3319
+diffsptk/core/ap.py,sha256=2pt4l9XA_nZ_jfKqdYf_CbnVPCpACGm6N9o-Z7NZBbg,12056
+diffsptk/core/b2mc.py,sha256=9EquGKsWQ0SUOauXnvDGIx2WA50ct_ZRjzJCa4dx5tQ,2669
 diffsptk/core/c2acr.py,sha256=9fBiCSZTrdlwPO-MLOWCtSIZVDZCq9Qtj9tVYM7p2ps,2623
-diffsptk/core/c2mpir.py,sha256=lNXO8Jefx45B_M0Und2R_zvQmKXZnMRe8h1DCBEAX_0,3018
+diffsptk/core/c2mpir.py,sha256=y1WnI9zbApOOEtoAQyKUYCEgohMTZKVaNtl4hibl_Hs,2920
 diffsptk/core/c2ndps.py,sha256=a3to35osi8xXkPbBmyZdOedN50y1oyO3EjyWxUBdtVE,2737
 diffsptk/core/cdist.py,sha256=VraHAXaf81X9cmLg8aanu6C16hqZRwmF8C5hDVrqybI,3399
 diffsptk/core/cqt.py,sha256=yadA9Ow8BkBV0vZ3Ee6cTxH9gUm_kB0onbBg7b_k9ao,4061
-diffsptk/core/dct.py,sha256=uKg_MXYGUJbViT0zjKgni9ZgHWMF3QukyPWrCqnNNI0,2453
+diffsptk/core/dct.py,sha256=0dK-RiGig6mp_hQiRDyC3F30zJ0jGfKTyp6xo8GadTc,2650
 diffsptk/core/decimate.py,sha256=88cByhHMIdRFybi_PvEqpaNnHSI-yux_vviD4mqRqXI,2469
 diffsptk/core/delay.py,sha256=ipOKYP7mzMqYsx-a_H8N5w7IHhKswnJwIBou4Ld76ls,3078
-diffsptk/core/delta.py,sha256=-wXIstbcpn1QEV1k7UGkSt_hNEXjj86oaT7fmnFE9Hc,5422
+diffsptk/core/delta.py,sha256=SjNEgHtIVnHfZWJRDvyUcePwCjtNFDyQGw0M3uwFrS8,5893
 diffsptk/core/dequantize.py,sha256=XX6Uu7wjYd348ggqpzIqBSFEJltOIKPmZJuywpq_tPc,3203
-diffsptk/core/df2.py,sha256=pxUj_ZNv81e_6QuO7XZ2BKlaD6XPH0ejNzMCBU4VDcc,3673
-diffsptk/core/dfs.py,sha256=zqB9ZPirFjtZuRm-BtSRLulRxS3Ltiwdi-zYw_jBKVg,3534
+diffsptk/core/df2.py,sha256=Ti8a68HJOoUGhhbfJct05NaeLdcRTqtNe0UchCKY8j8,3603
+diffsptk/core/dfs.py,sha256=tip6JBgXgmDIr8zI5n6i42H2g0L7OX9x0J_fQfoASAo,3422
 diffsptk/core/entropy.py,sha256=cQ7JbMu43r-mnBQu9UCEzDOPAfrYOdF8pLSriw2sFlw,2483
-diffsptk/core/excite.py,sha256=RwoWqS77cLosujrkHB6-rj4PTGxbNNFAW1OoLfK8780,4282
-diffsptk/core/fbank.py,sha256=M0nHZ8RSZd1a25snKqoajILLHXh8AiHOmr3Eji5SZtk,5193
-diffsptk/core/fftcep.py,sha256=0vXKDOiN7_x6WhezkbyNRctyjSN4zZKs7RY_yEKKv7E,3617
+diffsptk/core/excite.py,sha256=eH077kt4Yi-mjx8lbPmuOY7Fe01WdaoWwtj2VQv-u9E,4408
+diffsptk/core/fbank.py,sha256=pklfd1sbwReHrPhtxf1t3gvWtpkrvv3mzmGqxryg92U,5100
+diffsptk/core/fftcep.py,sha256=Q2tQogPp7jwTWuFKtmE7Ny9NdKdAbF6MCf3ROc7fPc4,3343
 diffsptk/core/frame.py,sha256=QDYCvWq6szG5dlQqSK2Ni3d_cIO_JUbt33o_H-Bh1aQ,3180
-diffsptk/core/freqt.py,sha256=zAtMFj3D15IzIFMs9mhsdRQVA7-yfdtzPKyJdiWGrdY,3211
+diffsptk/core/freqt.py,sha256=w_-Ei3TG6GOD5e6W929AXrgY37JJIam6TRIa3Ef85Gw,3213
+diffsptk/core/freqt2.py,sha256=x6oS9HFnn7DHBk7rhvA9gDpYSqPHav8yjn4Drs__hIs,4657
+diffsptk/core/gmm.py,sha256=ba4rZNI_DuMsVgrzVt91yiiL8zxUMGvcBDAteUr8PJY,12168
 diffsptk/core/gnorm.py,sha256=9r8suI4qqqjTagTwaQklKQAVTfdMmreZwKfB86WreEU,2862
-diffsptk/core/grpdelay.py,sha256=uU2kxpBmcS9wUWgEwB66YyzynWCkpGnwxTY-GhCZDC4,3693
+diffsptk/core/grpdelay.py,sha256=iiLmKfS3touEEdFXpWy8eO-byFQPFFuCd11jHLRsbOk,3667
 diffsptk/core/idct.py,sha256=woeRP85hMRWSzcMwUi-HGJSwbkYhjCYaXmVygG3NDAU,2327
+diffsptk/core/ifreqt2.py,sha256=4TgQaznpAwnQ8Wx4n0-gsOvi6CmHAI3Wq48OdPTXMRc,3666
 diffsptk/core/ignorm.py,sha256=gzqD-ArAI0Aszhf_mORt0hrm8TjDtiqNplxjc55nfDI,2959
-diffsptk/core/imglsadf.py,sha256=qt2vNoOY9wsoWM69XjKe9z1vFaTGHx5kps6JvlotiHs,3622
+diffsptk/core/imglsadf.py,sha256=KBW0J3_LjaZd5YNqVkM4dSKe4FXNzHWMkX_sSAmort4,2788
 diffsptk/core/imsvq.py,sha256=rzKm4I-GKI5HQObxAJ4XD_88b1ZdOmSO32tGsDFGTEE,2623
 diffsptk/core/interpolate.py,sha256=Vm-xtPuHjdDCo4iBPVkKc4p6USaoUEJM8MAMd-vWIS8,2653
-diffsptk/core/ipqmf.py,sha256=UQxG8gCtJ1OkYZfQBxpT8ywEnWJTfrzJKVYwgeu-sxE,3647
-diffsptk/core/istft.py,sha256=nG_0vACy2Cskav0-bo6j0TNPNHjlxAV57hoq_2hk6pg,3069
+diffsptk/core/ipqmf.py,sha256=4jldQ-RTEchwiYIAkGLJLjL3YoTDsasOYZwXHrb2WVQ,4145
+diffsptk/core/istft.py,sha256=a1CzEUOjRiUXoYrR-H5Fswk2caC0ST3EoP49KMoKL8U,3086
 diffsptk/core/iulaw.py,sha256=7RrzdIi0W66tXaNrTPRQ9fPxZbDkcLyBI-1kYrq1MNU,2445
 diffsptk/core/ivq.py,sha256=ICIV-4ZQu-j-9hdM-DfLqxKBL3R6uBWqrxOpl-_n0RY,2534
 diffsptk/core/lar2par.py,sha256=64qjl9h1u_n8WxqDvsOkkB8Jtb2BHZAY7ZhnkvMqBik,2391
-diffsptk/core/lbg.py,sha256=LdmOYQboehM7FVQYEV9MQMnSRsDmmslY4vqV3K0jJtg,6420
-diffsptk/core/levdur.py,sha256=SB6yLMRgzIMbZ3k3vikuaMuNnACfOGEU36HbGgxc734,2617
-diffsptk/core/linear_intpl.py,sha256=JKNBMVxHLYb90Sp7H1B3m5giwKOlOR6iLbBaqe-oleE,3434
-diffsptk/core/lpc.py,sha256=3-KZzpAiuEUo8ILzXRJdUO5_TG22RgIeGGAQ0lLmysc,2488
-diffsptk/core/lpc2par.py,sha256=8YoMhD7IRDHU2LJz3RcvzpKE-Qds0yc5N8CqPEBFcNU,3729
-diffsptk/core/lpccheck.py,sha256=1xO0Og5ZZ_N1GCpVwuF7puvXrp5VlwvMJeP1h_j51AI,3101
-diffsptk/core/mc2b.py,sha256=8ClAPOmDWXb7EPDay4nu1G9elLoIeL6P3xMChUnX6lc,2660
+diffsptk/core/lbg.py,sha256=eHV9QCPqfyoT7CbFBg0ZaXITDWByvm9o9KbmVuqlZe0,6740
+diffsptk/core/levdur.py,sha256=VaB-L7rz1wVooYrZUaV7NykS2w4ESYbT57ntgpFQENc,2781
+diffsptk/core/linear_intpl.py,sha256=NaVQ8rvPkJUqYEB2wbaEflW-96sUIBZusSBZmUT4JxM,3144
+diffsptk/core/lpc.py,sha256=Kfw8AbonRpzXuAql3zf0gLDL1pkSqJPlSPkBFg3BFwk,2468
+diffsptk/core/lpc2par.py,sha256=TUtLa5UcZEJ1lYZEzNe3pRyJI4c96SdIrULGjTVVPBw,3691
+diffsptk/core/lpccheck.py,sha256=WQbhWdc29qGAw7W5nWABKcfjJnc_tqXQgXTT-SUwigw,3099
+diffsptk/core/magic_intpl.py,sha256=PLoGyoOmVoGpoIbKaTMC2vjDIUu-JA4dwh5E2J4KWYc,4956
+diffsptk/core/mc2b.py,sha256=t4ExlCKhEKxQyntwXS5rEeRl5wUTmFr6gre-MtIaG_0,2662
 diffsptk/core/mcep.py,sha256=kWFyLp0uzxKbid5tP7P-o_-WnQicgiAaGrauSxR48q4,4946
-diffsptk/core/mcpf.py,sha256=6RjJ_gJzvHTOEjpEBI43cujxLoEPtskZ1vPH24a324M,3712
+diffsptk/core/mcpf.py,sha256=8aBA8Lm7QvLQJOVcGhe0E2lQvDBa4ckCj9Jef4RdRLo,3642
 diffsptk/core/mfcc.py,sha256=BAa-iQ6SGuUekBkQkfZzt8flgFwKw9cwNdZVRdk_C60,4517
-diffsptk/core/mgc2mgc.py,sha256=IPao7gkA_AzTlr6TIu3jNa7pxjk8zX3IPeS70hn9NGM,8938
-diffsptk/core/mgc2sp.py,sha256=-LQ-TWg1V9LNmHJ3eLU-uOQUibh-gpfcfAsO8mwU5ak,4748
+diffsptk/core/mgc2mgc.py,sha256=L_mEW-FeG-Gk8orp7nwsMztyQlNnxDxkv0pxqEIlW5c,9773
+diffsptk/core/mgc2sp.py,sha256=0GjrXIAz0mNR6dkKg7hQv08KXnKxnF1gZbQ_0Ws7owg,4873
 diffsptk/core/mgcep.py,sha256=41OLmJmFBRzmQMghCOwKWjc5JAE2BG3JzMxTvLLPlrQ,8823
-diffsptk/core/mglsadf.py,sha256=10j-KrZ9si8PuarnCelcGw2Fz-l2iK8h2zNPGpjbXpY,8339
+diffsptk/core/mglsadf.py,sha256=nL1E9Du_sgOzOSwCcFGfsSEFY-BqOunJ6z-a9azr4HU,12486
 diffsptk/core/mlpg.py,sha256=JT06-1SA1_YW4YO4IzuB1ZUvX60p8qpvvCS9QmzxnR8,4248
-diffsptk/core/mpir2c.py,sha256=U0iu0Oqyt1o2jHoGWi_CkAt9dU-3RIlzPL0MkMhZeRs,3043
-diffsptk/core/msvq.py,sha256=oxBa_qugG8utCty-kZYySjLbxiSWiLALpVTFfiCMri8,3781
+diffsptk/core/mlsacheck.py,sha256=hx1dctKEIDjvZmPlwo6cXvLbFI0D1cT8n8T3OeV30Rk,5724
+diffsptk/core/mpir2c.py,sha256=6AMJloCdHz1fKzll7fsTNWtJvwgC52tXmQpVpGQYxbw,2945
+diffsptk/core/msvq.py,sha256=0C6BUUzdC2_P-SAJOR7b-TS7qnb5mrwuh94PbALBWks,3745
 diffsptk/core/ndps2c.py,sha256=vdU09Rwg1ZJ1c65z5ZU5ynK8LdfG0z08M9C_WI9xNfA,2782
 diffsptk/core/norm0.py,sha256=v0FnjDyyKCdpIJqCkdfubdI3D2UrgfsWSGVItCtEf1c,2571
 diffsptk/core/par2lar.py,sha256=gvXutMwiv4lkGP6qKRFQLyCYWIUIXc1vDj2FPGrCi7I,2468
 diffsptk/core/par2lpc.py,sha256=82rOk9v9YAgfOlY8Uhyw2oi_8soS5ESND2kpU49lALs,2821
 diffsptk/core/pca.py,sha256=TNrtikEGfuN-vLYx72CyN5t7UCd24EYLYnXbBa5aDcY,3040
-diffsptk/core/phase.py,sha256=2BSzT8t6pusjP2OU5G3lmB6JrQx02-trknSlcqKy5MA,3034
-diffsptk/core/pitch.py,sha256=krHeqpnWQcxpA8rQRVec2ceZXzklwWtpLBRA2dTNUnQ,8549
-diffsptk/core/pqmf.py,sha256=zbgEIaps4KCcyKxhgXWOuLmoem9gE-41zLvlR2FfXfs,5183
+diffsptk/core/phase.py,sha256=qbd4GNRY5lvJnzRkQ3xwdXD_NAGGbHzMo5SEHPJZcO0,3040
+diffsptk/core/pitch.py,sha256=g1HgWqHSH9aQDWwgXVv7wHQb4AUHh1WqTjVylEXY8s0,8574
+diffsptk/core/poledf.py,sha256=jAbNrBmtvoPgiigMncZR2OUjEP4i7IwvRQJjK-6xdoU,3235
+diffsptk/core/pqmf.py,sha256=QIJfU34UH2nyYjEFjSsgRhZ2rnLFTZKg_LIR6f2jins,6698
 diffsptk/core/quantize.py,sha256=t0iUXSBNUP12qUeU7Iit0owVRmwaO7MGbKgbZw9bx_o,3488
+diffsptk/core/rlevdur.py,sha256=VPsOjDJIz5U7QGAvUbzdQ8of4mx64hZbtPRJwVIhYgA,3322
 diffsptk/core/rmse.py,sha256=5CyaIFAtRMULR3Pb5WeOPCsTd8Ioys0IZTAgg4_Beyk,2744
-diffsptk/core/root_pol.py,sha256=Pt393X-_MN3isZx0TCYemr-GQyTTjAl_9cCwVcIcJM0,4580
-diffsptk/core/smcep.py,sha256=rIjmB7xxxsVyzZV4SVSl4WJ-_KwRRDxA4F4wJO4Xq4A,8753
+diffsptk/core/root_pol.py,sha256=bwK0sPXLVer_Zu-3FJSpnyoyyJZJ1NRwX6ntiOas7Yg,4595
+diffsptk/core/smcep.py,sha256=pAkrfoMO4oEYF7dMitXRxOv4ojzfu4mIWGgKgtFQONM,6134
 diffsptk/core/snr.py,sha256=6N_TVKHapvePW2dzqvg5i2fZ5gH3qcGjQA5eXY51JWo,3535
-diffsptk/core/sopr.py,sha256=2oNcXyz2Mlhmt-JRbXHC7ZxXnPG2PGJW6vrmiCu9g60,5152
-diffsptk/core/spec.py,sha256=lNaUxQCTkayZ69uk7QdtdE_XA1hx9NMBoViGD62ENNQ,3810
+diffsptk/core/spec.py,sha256=HAW_sHeAHl159FBa3P8bXnZ9CzEwH6VtYkdrtHKGrpg,3834
 diffsptk/core/stft.py,sha256=evpJf08G-qJQNVNbsnj4w23kFbT6fP9OdBiQnaKmWWQ,3707
 diffsptk/core/ulaw.py,sha256=vvBsp4KVMq5bTsTgKyURli0wF45n31cG9AUAOANh2C8,2412
-diffsptk/core/unframe.py,sha256=wON04ZcpJIQ6lGhzP1qyB1cmUQiexzlTJd1lLkfFSNE,4126
-diffsptk/core/vq.py,sha256=MFZzDkUvIzsIiVpDnKSNwR1tWX3hW07-7fQjD3GDm-k,3417
+diffsptk/core/unframe.py,sha256=2Le0rwH491VoK4K5VlfOfyWoaMkhBs3Z4j_5t5dbK1g,4129
+diffsptk/core/vq.py,sha256=TvBa1Lo8vKMfeeBukiEDpheta2NjrRhf-lxb_w37zq8,3381
 diffsptk/core/window.py,sha256=oxEvlSLo7yqhduLqt34t3x0GOHjpge2agQ_xfkA2arI,4069
+diffsptk/core/yingram.py,sha256=bh0jyqjV7ckQuxC01j8_ptDgMQkRlIey0GUVYczuTzI,4693
 diffsptk/core/zcross.py,sha256=7I2Md0g4OeMwPRe5v_bBw4o0Fx6F7_i-CW0_jgp9kDA,2617
-diffsptk/core/zerodf.py,sha256=Os88M0F50C-VGjUFQZfpcjT99Y9S1187VirUxaHwoJU,3109
+diffsptk/core/zerodf.py,sha256=UFjaULKUPG-SbZBmf7eyU3uV_-WH19SU2wdIqTWrBtw,3110
 diffsptk/misc/__init__.py,sha256=lLxSpYPPr15CTUwnE5zSVFZltMWSR8c1OTv5lcU1xvU,101
-diffsptk/misc/signals.py,sha256=J1wDsne4obkLVMO-ZlELkoi34ALxlvjs5g38i9byWqE,6071
-diffsptk/misc/utils.py,sha256=o0K9SyrpQnz1jvWRBTcqujQXuwwc4xkEW9JND2ouoJA,6716
-diffsptk-0.6.0.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
-diffsptk-0.6.0.dist-info/METADATA,sha256=_6CsDCmGFbuwe4CVtEXpVdMxKiT_NYw02g8CBm6qq0c,5591
-diffsptk-0.6.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-diffsptk-0.6.0.dist-info/top_level.txt,sha256=iFrIbOh4W0AOHOELafgTqs0wwTDR3y8zcB-yUxn4j9o,9
-diffsptk-0.6.0.dist-info/RECORD,,
+diffsptk/misc/signals.py,sha256=2e-rWDLBTiPoxKFIeWGLEGJcMCkpBzOOj3dQW0lkfkk,6881
+diffsptk/misc/utils.py,sha256=gMnLms3jy_GKf6RvV9y-8x9gPcQPdGjljF3TlbHyKDw,7007
+diffsptk-1.0.0.dist-info/METADATA,sha256=jcipFzDrICErEsvEUaWLCHoa9x1KuPu11tIEbDsoGV8,6288
+diffsptk-1.0.0.dist-info/WHEEL,sha256=9QBuHhg6FNW7lppboF2vKVbCGTVzsFykgRQjjlajrhA,87
+diffsptk-1.0.0.dist-info/licenses/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
+diffsptk-1.0.0.dist-info/RECORD,,
```

