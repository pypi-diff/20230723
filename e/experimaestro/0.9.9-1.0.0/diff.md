# Comparing `tmp/experimaestro-0.9.9-py2.py3-none-any.whl.zip` & `tmp/experimaestro-1.0.0.zip`

## zipinfo {}

```diff
@@ -1,125 +1,249 @@
-Zip file size: 4519151 bytes, number of entries: 123
--rw-rw-r--  2.0 unx     1204 b- defN 21-Jul-17 16:51 experimaestro/__init__.py
--rw-rw-r--  2.0 unx     5307 b- defN 21-Apr-05 14:54 experimaestro/__main__.py
--rw-rw-r--  2.0 unx     7124 b- defN 21-Jul-18 11:24 experimaestro/annotations.py
--rw-rw-r--  2.0 unx      696 b- defN 21-Feb-15 17:33 experimaestro/checkers.py
--rw-rw-r--  2.0 unx     2455 b- defN 21-May-24 15:35 experimaestro/click.py
--rw-rw-r--  2.0 unx     9476 b- defN 21-Apr-03 17:00 experimaestro/commandline.py
--rw-rw-r--  2.0 unx     1819 b- defN 20-Oct-02 08:05 experimaestro/dependencies.py
--rw-rw-r--  2.0 unx     2198 b- defN 20-Sep-17 11:28 experimaestro/environment.py
--rw-rw-r--  2.0 unx     1235 b- defN 21-Jul-17 16:53 experimaestro/generators.py
--rw-rw-r--  2.0 unx     1694 b- defN 21-Mar-05 11:33 experimaestro/ipc.py
--rw-rw-r--  2.0 unx     1133 b- defN 20-Sep-08 15:11 experimaestro/locking.py
--rw-rw-r--  2.0 unx      285 b- defN 21-Jan-06 15:43 experimaestro/mypy.py
--rw-rw-r--  2.0 unx     3078 b- defN 21-Jul-17 16:53 experimaestro/notifications.py
--rw-rw-r--  2.0 unx      491 b- defN 20-Sep-08 15:11 experimaestro/register.py
--rw-rw-r--  2.0 unx     3486 b- defN 20-Sep-08 15:11 experimaestro/rpyc.py
--rw-rw-r--  2.0 unx    20793 b- defN 21-Jul-19 12:36 experimaestro/scheduler.py
--rw-rw-r--  2.0 unx     6611 b- defN 21-Jul-17 16:53 experimaestro/scriptbuilder.py
--rw-rw-r--  2.0 unx       84 b- defN 21-Jan-26 17:45 experimaestro/taskglobals.py
--rw-rw-r--  2.0 unx    13441 b- defN 21-May-24 15:35 experimaestro/tokens.py
--rw-rw-r--  2.0 unx      987 b- defN 21-Mar-18 08:23 experimaestro/typingutils.py
--rw-rw-r--  2.0 unx     1014 b- defN 21-Apr-03 09:19 experimaestro/workspace.py
--rw-rw-r--  2.0 unx      613 b- defN 21-Mar-05 10:42 experimaestro/xpmutils.py
--rw-rw-r--  2.0 unx     3555 b- defN 21-Apr-03 09:19 experimaestro/connectors/__init__.py
--rw-rw-r--  2.0 unx     4247 b- defN 21-Apr-03 17:12 experimaestro/connectors/local.py
--rw-rw-r--  2.0 unx     4779 b- defN 20-Sep-08 15:11 experimaestro/connectors/ssh.py
--rw-rw-r--  2.0 unx        0 b- defN 20-Sep-08 15:11 experimaestro/core/__init__.py
--rw-rw-r--  2.0 unx     4132 b- defN 21-Jul-17 16:51 experimaestro/core/arguments.py
--rw-rw-r--  2.0 unx    39282 b- defN 21-Jul-20 09:56 experimaestro/core/objects.py
--rw-rw-r--  2.0 unx    14817 b- defN 21-Jul-19 12:38 experimaestro/core/types.py
--rw-rw-r--  2.0 unx     1595 b- defN 21-Jun-25 12:48 experimaestro/launchers/__init__.py
--rw-rw-r--  2.0 unx        0 b- defN 20-Sep-08 15:11 experimaestro/launchers/oar.py
--rw-rw-r--  2.0 unx     8614 b- defN 21-Jul-17 16:52 experimaestro/launchers/slurm.py
--rw-rw-r--  2.0 unx      173 b- defN 21-Apr-03 06:35 experimaestro/launchers/unix.py
--rw-rw-r--  2.0 unx       32 b- defN 21-May-21 15:04 experimaestro/mkdocs/__init__.py
--rw-rw-r--  2.0 unx      263 b- defN 21-May-21 16:01 experimaestro/mkdocs/annotations.py
--rw-rw-r--  2.0 unx    14982 b- defN 21-Jul-22 12:25 experimaestro/mkdocs/base.py
--rw-rw-r--  2.0 unx     1238 b- defN 21-Jan-29 08:09 experimaestro/mkdocs/metaloader.py
--rw-rw-r--  2.0 unx       66 b- defN 21-Jan-08 14:02 experimaestro/mkdocs/style.css
--rw-rw-r--  2.0 unx     7516 b- defN 21-Apr-03 09:19 experimaestro/server/__init__.py
--rw-rw-r--  2.0 unx     3870 b- defN 20-Oct-14 09:16 experimaestro/server/data/favicon.ico
--rw-rw-r--  2.0 unx      684 b- defN 20-Oct-14 09:20 experimaestro/server/data/index.html
--rw-rw-r--  2.0 unx   279175 b- defN 21-Jul-19 12:37 experimaestro/server/data/static/index.css
--rw-rw-r--  2.0 unx   459877 b- defN 21-Jul-19 12:37 experimaestro/server/data/static/index.css.map
--rw-rw-r--  2.0 unx   222058 b- defN 21-Jul-19 12:37 experimaestro/server/data/static/index.js
--rw-rw-r--  2.0 unx   136822 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.eot
--rw-rw-r--  2.0 unx   747545 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.svg
--rw-rw-r--  2.0 unx   136516 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.ttf
--rw-rw-r--  2.0 unx    92136 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff
--rw-rw-r--  2.0 unx    78460 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2
--rw-rw-r--  2.0 unx    34350 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.eot
--rw-rw-r--  2.0 unx   144714 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.svg
--rw-rw-r--  2.0 unx    34052 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.ttf
--rw-rw-r--  2.0 unx    16772 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.woff
--rw-rw-r--  2.0 unx    13548 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.woff2
--rw-rw-r--  2.0 unx   204814 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.eot
--rw-rw-r--  2.0 unx   917575 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.svg
--rw-rw-r--  2.0 unx   204528 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.ttf
--rw-rw-r--  2.0 unx   104280 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.woff
--rw-rw-r--  2.0 unx    80300 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.woff2
--rw-rw-r--  2.0 unx    69177 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.eot
--rw-rw-r--  2.0 unx   174112 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.ttf
--rw-rw-r--  2.0 unx    79612 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.woff
--rw-rw-r--  2.0 unx    60840 b- defN 20-Oct-14 09:04 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.woff2
--rw-rw-r--  2.0 unx   268784 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.eot
--rw-rw-r--  2.0 unx   268604 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.otf
--rw-rw-r--  2.0 unx   135204 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.woff
--rw-rw-r--  2.0 unx   115340 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.woff2
--rw-rw-r--  2.0 unx   317906 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.eot
--rw-rw-r--  2.0 unx   317732 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.otf
--rw-rw-r--  2.0 unx   155580 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.woff
--rw-rw-r--  2.0 unx   131472 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.woff2
--rw-rw-r--  2.0 unx   224874 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.eot
--rw-rw-r--  2.0 unx   224700 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.otf
--rw-rw-r--  2.0 unx   116032 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.woff
--rw-rw-r--  2.0 unx   100860 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.woff2
--rw-rw-r--  2.0 unx   544532 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.eot
--rw-rw-r--  2.0 unx   544352 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.otf
--rw-rw-r--  2.0 unx   253388 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.woff
--rw-rw-r--  2.0 unx   161920 b- defN 21-Jan-07 16:22 experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.woff2
--rw-rw-r--  2.0 unx        0 b- defN 20-Sep-08 15:11 experimaestro/tests/__init__.py
--rw-rw-r--  2.0 unx      695 b- defN 21-Jan-26 14:22 experimaestro/tests/conftest.py
--rw-rw-r--  2.0 unx      514 b- defN 20-Sep-08 15:11 experimaestro/tests/definitions_types.py
--rw-rw-r--  2.0 unx     2953 b- defN 21-Jul-18 13:03 experimaestro/tests/restart.py
--rw-rw-r--  2.0 unx      295 b- defN 20-Oct-08 11:44 experimaestro/tests/restart_main.py
--rw-rw-r--  2.0 unx      286 b- defN 21-Jan-25 16:26 experimaestro/tests/task_tokens.py
--rw-rw-r--  2.0 unx      409 b- defN 21-Jul-17 16:47 experimaestro/tests/test_checkers.py
--rw-rw-r--  2.0 unx      810 b- defN 21-Feb-18 15:27 experimaestro/tests/test_forward.py
--rw-rw-r--  2.0 unx     4554 b- defN 21-Jul-17 16:53 experimaestro/tests/test_identifier.py
--rw-rw-r--  2.0 unx     1048 b- defN 21-Jul-17 16:47 experimaestro/tests/test_instance.py
--rw-rw-r--  2.0 unx     1143 b- defN 21-Jul-17 16:53 experimaestro/tests/test_objects.py
--rw-rw-r--  2.0 unx     1920 b- defN 21-Jul-17 16:47 experimaestro/tests/test_outputs.py
--rw-rw-r--  2.0 unx     5274 b- defN 21-Jul-18 13:04 experimaestro/tests/test_param.py
--rw-rw-r--  2.0 unx     3073 b- defN 21-Apr-03 17:18 experimaestro/tests/test_snippets.py
--rw-rw-r--  2.0 unx      976 b- defN 20-Sep-08 15:11 experimaestro/tests/test_ssh.py
--rw-rw-r--  2.0 unx     2563 b- defN 21-Jul-17 16:47 experimaestro/tests/test_tags.py
--rw-rw-r--  2.0 unx     4292 b- defN 21-May-26 09:49 experimaestro/tests/test_tasks.py
--rw-rw-r--  2.0 unx     7252 b- defN 21-Jul-22 13:07 experimaestro/tests/test_tokens.py
--rw-rw-r--  2.0 unx     1257 b- defN 21-Feb-18 14:41 experimaestro/tests/test_types.py
--rw-rw-r--  2.0 unx     3926 b- defN 21-Jul-17 16:53 experimaestro/tests/test_validation.py
--rw-rw-r--  2.0 unx     1344 b- defN 21-May-26 09:05 experimaestro/tests/token_reschedule.py
--rw-rw-r--  2.0 unx     3354 b- defN 21-May-26 09:02 experimaestro/tests/utils.py
--rw-rw-r--  2.0 unx     1204 b- defN 21-Apr-03 09:19 experimaestro/tests/connectors/test_local.py
--rw-rw-r--  2.0 unx      702 b- defN 21-Apr-03 09:19 experimaestro/tests/connectors/utils.py
--rw-rw-r--  2.0 unx       21 b- defN 21-Apr-03 09:19 experimaestro/tests/connectors/bin/executable.py
--rw-rw-r--  2.0 unx     1826 b- defN 21-Jul-22 13:07 experimaestro/tests/launchers/test_slurm.py
--rwxrw-r--  2.0 unx      511 b- defN 21-Mar-25 07:44 experimaestro/tests/launchers/bin/sacct
--rwxrwxr-x  2.0 unx      979 b- defN 21-Jul-17 16:52 experimaestro/tests/launchers/bin/sbatch
--rw-rw-r--  2.0 unx      477 b- defN 21-Apr-03 09:19 experimaestro/tests/launchers/bin/test.py
--rw-rw-r--  2.0 unx      120 b- defN 20-Dec-09 16:49 experimaestro/tests/scripts/waitforfile.py
--rw-rw-r--  2.0 unx        0 b- defN 20-Dec-21 15:49 experimaestro/tests/tasks/__init__.py
--rw-rw-r--  2.0 unx     1952 b- defN 21-Jul-18 13:04 experimaestro/tests/tasks/all.py
--rw-rw-r--  2.0 unx      153 b- defN 21-Jan-25 16:30 experimaestro/tests/tasks/foreign.py
--rw-rw-r--  2.0 unx      300 b- defN 21-Jan-27 17:08 experimaestro/tests/tasks/subparams.py
--rw-rw-r--  2.0 unx     2125 b- defN 21-Jan-27 12:12 experimaestro/utils/__init__.py
--rw-rw-r--  2.0 unx     1124 b- defN 21-Jun-04 05:25 experimaestro/utils/jobs.py
--rw-rw-r--  2.0 unx     1895 b- defN 21-Jun-04 05:25 experimaestro/utils/jupyter.py
--rw-rw-r--  2.0 unx      797 b- defN 20-Sep-08 15:11 experimaestro/utils/settings.py
--rw-rw-r--  2.0 unx    35149 b- defN 21-Jul-23 07:17 experimaestro-0.9.9.dist-info/LICENSE
--rw-rw-r--  2.0 unx     6009 b- defN 21-Jul-23 07:17 experimaestro-0.9.9.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 21-Jul-23 07:17 experimaestro-0.9.9.dist-info/WHEEL
--rw-rw-r--  2.0 unx      265 b- defN 21-Jul-23 07:17 experimaestro-0.9.9.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       14 b- defN 21-Jul-23 07:17 experimaestro-0.9.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    13214 b- defN 21-Jul-23 07:17 experimaestro-0.9.9.dist-info/RECORD
-123 files, 8484497 bytes uncompressed, 4497317 bytes compressed:  47.0%
+Zip file size: 5169797 bytes, number of entries: 247
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/docs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/scripts/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/app/
+-rw-r--r--  2.0 unx      646 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/requirements.txt
+-rw-r--r--  2.0 unx     2130 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/setup.cfg
+-rw-r--r--  2.0 unx      236 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/pytest.ini
+-rw-r--r--  2.0 unx      991 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/mkdocs.yml
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/.gitmodules
+-rw-r--r--  2.0 unx     7470 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/PKG-INFO
+-rw-r--r--  2.0 unx     3585 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/CHANGELOG.md
+-rw-r--r--  2.0 unx      182 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/.gitignore
+-rw-r--r--  2.0 unx      232 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/MANIFEST.in
+-rw-r--r--  2.0 unx      511 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/.flake8
+-rw-r--r--  2.0 unx    35149 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/LICENSE
+-rw-r--r--  2.0 unx       33 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/.prettierignore
+-rw-r--r--  2.0 unx     3045 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/README.md
+-rw-r--r--  2.0 unx       38 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/setup.py
+-rw-r--r--  2.0 unx      348 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/pyproject.toml
+-rw-r--r--  2.0 unx      287 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/tox.ini
+-rw-r--r--  2.0 unx      355 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/.readthedocs.yml
+-rw-r--r--  2.0 unx      567 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/.pre-commit-config.yaml
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/docs/launchers/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/docs/experiments/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/docs/connectors/
+-rw-r--r--  2.0 unx       33 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/requirements.txt
+-rw-r--r--  2.0 unx      701 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/faq.md
+-rw-r--r--  2.0 unx      269 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/configuration.md
+-rw-r--r--  2.0 unx     1938 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/index.md
+-rw-r--r--  2.0 unx     2036 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/documenting.md
+-rw-r--r--  2.0 unx      827 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/cli.md
+-rw-r--r--  2.0 unx       22 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/changelog.md
+-rw-r--r--  2.0 unx     1024 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/serialization.md
+-rw-r--r--  2.0 unx       18 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/tutorial.md
+-rw-r--r--  2.0 unx      744 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/concepts.md
+-rw-r--r--  2.0 unx      675 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/jupyter.md
+-rw-r--r--  2.0 unx     5712 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/launchers/index.md
+-rw-r--r--  2.0 unx     3879 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/experiments/task.md
+-rw-r--r--  2.0 unx     7818 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/experiments/config.md
+-rw-r--r--  2.0 unx     6433 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/experiments/overview.md
+-rw-r--r--  2.0 unx     4317 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/experiments/plan.md
+-rw-r--r--  2.0 unx       60 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/docs/connectors/index.md
+-rw-r--r--  2.0 unx      597 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/scripts/longtask.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/launcherfinder/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/mkdocs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tools/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/sphinx/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/launchers/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/core/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/utils/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/connectors/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/scheduler/
+-rw-r--r--  2.0 unx     4455 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/run.py
+-rw-r--r--  2.0 unx      285 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/mypy.py
+-rw-r--r--  2.0 unx     5775 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/filter.py
+-rw-r--r--  2.0 unx      160 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/version.py
+-rw-r--r--  2.0 unx     3605 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/rpyc.py
+-rw-r--r--  2.0 unx     1785 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/typingutils.py
+-rw-r--r--  2.0 unx     1230 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/generators.py
+-rw-r--r--  2.0 unx     8343 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/annotations.py
+-rw-r--r--  2.0 unx     1490 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/ipc.py
+-rw-r--r--  2.0 unx      638 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/xpmutils.py
+-rw-r--r--  2.0 unx      696 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/checkers.py
+-rw-r--r--  2.0 unx    14681 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tokens.py
+-rw-r--r--  2.0 unx     1011 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/settings.py
+-rw-r--r--  2.0 unx      171 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/compat.py
+-rw-r--r--  2.0 unx     8710 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/notifications.py
+-rw-r--r--  2.0 unx     2956 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/huggingface.py
+-rw-r--r--  2.0 unx     1477 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/locking.py
+-rw-r--r--  2.0 unx     1465 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/__init__.py
+-rw-r--r--  2.0 unx     2390 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/click.py
+-rw-r--r--  2.0 unx    13915 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/__main__.py
+-rw-r--r--  2.0 unx     4235 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/scriptbuilder.py
+-rw-r--r--  2.0 unx     9463 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/commandline.py
+-rw-r--r--  2.0 unx      499 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/taskglobals.py
+-rw-r--r--  2.0 unx     6140 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launcherfinder/specs.py
+-rw-r--r--  2.0 unx     1020 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launcherfinder/base.py
+-rw-r--r--  2.0 unx     7878 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launcherfinder/registry.py
+-rw-r--r--  2.0 unx      148 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launcherfinder/__init__.py
+-rw-r--r--  2.0 unx     2129 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launcherfinder/parser.py
+-rw-r--r--  2.0 unx       66 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/mkdocs/style.css
+-rw-r--r--  2.0 unx      263 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/mkdocs/annotations.py
+-rw-r--r--  2.0 unx    16716 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/mkdocs/base.py
+-rw-r--r--  2.0 unx       34 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/mkdocs/__init__.py
+-rw-r--r--  2.0 unx     1481 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/mkdocs/metaloader.py
+-rw-r--r--  2.0 unx     3516 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tools/jobs.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tools/__init__.py
+-rw-r--r--  2.0 unx     3309 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tools/diff.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/sphinx/static/
+-rw-r--r--  2.0 unx     9560 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/sphinx/__init__.py
+-rw-r--r--  2.0 unx      294 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/sphinx/static/experimaestro.css
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/
+-rw-r--r--  2.0 unx    10854 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/server/__init__.py
+-rw-r--r--  2.0 unx      706 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/index.html
+-rw-r--r--  2.0 unx   156236 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/3a4004a46a653d4b2166.woff
+-rw-r--r--  2.0 unx   397728 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/b48ad290d0335879a92b.ttf
+-rw-r--r--  2.0 unx  3822921 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/index.js.map
+-rw-r--r--  2.0 unx   206260 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/5d681e2edae8c60630db.woff
+-rw-r--r--  2.0 unx   528999 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/index.css.map
+-rw-r--r--  2.0 unx   376002 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/index.css
+-rw-r--r--  2.0 unx   182028 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/f882956fd323fd322f31.woff
+-rw-r--r--  2.0 unx  3649207 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/index.js
+-rw-r--r--  2.0 unx      318 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/manifest.json
+-rw-r--r--  2.0 unx   107460 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/e1a247a5ef41e1975742.woff2
+-rw-r--r--  2.0 unx      511 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/login.html
+-rw-r--r--  2.0 unx   155276 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/6f420cf17cc0d7676fad.woff2
+-rw-r--r--  2.0 unx   215704 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/4ef4218c522f1eb6b5b1.woff2
+-rw-r--r--  2.0 unx   150472 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/66104b766c3d0462b3c5.woff2
+-rw-r--r--  2.0 unx   164912 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/4d73cb90e394b34b7670.woff
+-rw-r--r--  2.0 unx     3870 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/favicon.ico
+-rw-r--r--  2.0 unx   135984 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/219aa9140e099e6c72ed.woff2
+-rw-r--r--  2.0 unx   339600 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/3baa5b8f3469222b822d.woff
+-rw-r--r--  2.0 unx   186112 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/f9ee61fab3c11e2f3ed3.ttf
+-rw-r--r--  2.0 unx   173620 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/c380809fd3677d7d6903.woff2
+-rw-r--r--  2.0 unx    62048 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/abf801b7acb6705a15ad.ttf
+-rw-r--r--  2.0 unx   128352 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/0c35d18bf06992036b69.woff2
+-rw-r--r--  2.0 unx    25096 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/server/data/639d2000c1ece92eaec8.woff2
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/launchers/slurm/
+-rw-r--r--  2.0 unx     1967 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launchers/direct.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launchers/oar.py
+-rw-r--r--  2.0 unx     2525 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launchers/__init__.py
+-rw-r--r--  2.0 unx    12747 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launchers/slurm/base.py
+-rw-r--r--  2.0 unx    19130 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launchers/slurm/configuration.py
+-rw-r--r--  2.0 unx       41 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launchers/slurm/__init__.py
+-rw-r--r--  2.0 unx      818 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/launchers/slurm/cli.py
+-rw-r--r--  2.0 unx     5620 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/arguments.py
+-rw-r--r--  2.0 unx    18984 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/types.py
+-rw-r--r--  2.0 unx    58915 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/objects.py
+-rw-r--r--  2.0 unx     7355 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/objects.pyi
+-rw-r--r--  2.0 unx     2479 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/context.py
+-rw-r--r--  2.0 unx      493 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/utils.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/__init__.py
+-rw-r--r--  2.0 unx     1197 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/core/serializers.py
+-rw-r--r--  2.0 unx     1006 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/utils/resources.py
+-rw-r--r--  2.0 unx     6766 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/utils/yaml.py
+-rw-r--r--  2.0 unx      793 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/utils/settings.py
+-rw-r--r--  2.0 unx     2394 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/utils/jobs.py
+-rw-r--r--  2.0 unx      601 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/utils/asyncio.py
+-rw-r--r--  2.0 unx     2434 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/utils/__init__.py
+-rw-r--r--  2.0 unx     2183 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/utils/jupyter.py
+-rw-r--r--  2.0 unx     8206 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/connectors/ssh.py
+-rw-r--r--  2.0 unx     5461 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/connectors/__init__.py
+-rw-r--r--  2.0 unx     5760 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/connectors/local.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/launchers/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/tasks/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/scripts/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/connectors/
+-rw-r--r--  2.0 unx     3081 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_snippets.py
+-rw-r--r--  2.0 unx     1837 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_objects.py
+-rw-r--r--  2.0 unx      477 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/task_tokens.py
+-rw-r--r--  2.0 unx     4016 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/restart.py
+-rw-r--r--  2.0 unx      695 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/conftest.py
+-rw-r--r--  2.0 unx      781 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_outputs.py
+-rw-r--r--  2.0 unx     9099 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_tasks.py
+-rw-r--r--  2.0 unx      979 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_ssh.py
+-rw-r--r--  2.0 unx     4339 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_validation.py
+-rw-r--r--  2.0 unx     1502 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_serializers.py
+-rw-r--r--  2.0 unx    12285 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_identifier.py
+-rw-r--r--  2.0 unx     2964 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_findlauncher.py
+-rw-r--r--  2.0 unx     1701 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/token_reschedule.py
+-rw-r--r--  2.0 unx      780 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_forward.py
+-rw-r--r--  2.0 unx     6405 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_param.py
+-rw-r--r--  2.0 unx     1975 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_tags.py
+-rw-r--r--  2.0 unx     2005 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_dependencies.py
+-rw-r--r--  2.0 unx      295 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/restart_main.py
+-rw-r--r--  2.0 unx     3805 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/utils.py
+-rw-r--r--  2.0 unx     7826 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_tokens.py
+-rw-r--r--  2.0 unx     1540 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_instance.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/__init__.py
+-rw-r--r--  2.0 unx     7580 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_progress.py
+-rw-r--r--  2.0 unx      414 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/definitions_types.py
+-rw-r--r--  2.0 unx      403 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_checkers.py
+-rw-r--r--  2.0 unx     1257 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/test_types.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/launchers/config_slurm/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/
+-rw-r--r--  2.0 unx      717 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/test_local.py
+-rw-r--r--  2.0 unx     2534 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/test_slurm.py
+-rw-r--r--  2.0 unx     2468 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/common.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/__init__.py
+-rw-r--r--  2.0 unx     2497 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/config_slurm/launchers.yaml
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/config_slurm/__init__.py
+-rwxr-xr-x  2.0 unx      639 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/sacct
+-rwxr-xr-x  2.0 unx     1177 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/sbatch
+-rw-r--r--  2.0 unx      477 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/test.py
+-rw-r--r--  2.0 unx     1851 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/tasks/all.py
+-rw-r--r--  2.0 unx      153 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/tasks/foreign.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/tasks/__init__.py
+-rw-r--r--  2.0 unx      407 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/scripts/notifyandwait.py
+-rw-r--r--  2.0 unx      120 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/scripts/waitforfile.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro/tests/connectors/bin/
+-rw-r--r--  2.0 unx     1204 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/connectors/test_local.py
+-rw-r--r--  2.0 unx      702 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/connectors/utils.py
+-rw-r--r--  2.0 unx       21 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/tests/connectors/bin/executable.py
+-rw-r--r--  2.0 unx     1994 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/scheduler/dependencies.py
+-rw-r--r--  2.0 unx     1820 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/scheduler/services.py
+-rw-r--r--  2.0 unx     1731 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/scheduler/workspace.py
+-rw-r--r--  2.0 unx     2393 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/scheduler/environment.py
+-rw-r--r--  2.0 unx    29179 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/scheduler/base.py
+-rw-r--r--  2.0 unx       20 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/src/experimaestro/scheduler/__init__.py
+-rw-r--r--  2.0 unx     7470 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/PKG-INFO
+-rw-r--r--  2.0 unx        1 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/not-zip-safe
+-rw-r--r--  2.0 unx       14 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/top_level.txt
+-rw-r--r--  2.0 unx     7039 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/SOURCES.txt
+-rw-r--r--  2.0 unx      414 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/requires.txt
+-rw-r--r--  2.0 unx        1 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/dependency_links.txt
+-rw-r--r--  2.0 unx      591 b- defN 23-Jul-23 15:59 experimaestro-1.0.0/src/experimaestro.egg-info/entry_points.txt
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/app/xp/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/app/public/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/app/src/
+-rw-r--r--  2.0 unx      536 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/tsconfig.json
+-rw-r--r--  2.0 unx     1955 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/CHANGELOG.md
+-rw-r--r--  2.0 unx      324 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/.gitignore
+-rw-r--r--  2.0 unx     2319 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/package.json
+-rw-r--r--  2.0 unx   127144 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/README.md
+-rw-r--r--  2.0 unx   785936 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/package-lock.json
+-rw-r--r--  2.0 unx      314 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/.nolluprc.js
+-rw-r--r--  2.0 unx     9556 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/webpack.config.ts
+-rw-r--r--  2.0 unx      930 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/postcss.config.js
+-rw-r--r--  2.0 unx     5061 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/xp/run.py
+-rw-r--r--  2.0 unx      706 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/public/index.html
+-rw-r--r--  2.0 unx      318 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/public/manifest.json
+-rw-r--r--  2.0 unx      511 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/public/login.html
+-rw-r--r--  2.0 unx     3870 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/public/favicon.ico
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/app/src/theme/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-23 15:59 experimaestro-1.0.0/app/src/ui/
+-rw-r--r--  2.0 unx   130132 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/logo.png
+-rw-r--r--  2.0 unx      682 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/index.tsx
+-rw-r--r--  2.0 unx     1461 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/client.ts
+-rw-r--r--  2.0 unx     1155 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/Services.tsx
+-rw-r--r--  2.0 unx     3656 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/Tasks.tsx
+-rw-r--r--  2.0 unx      102 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/index.css
+-rw-r--r--  2.0 unx      621 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/clipboard.ts
+-rw-r--r--  2.0 unx     1614 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/TaskJobs.tsx
+-rw-r--r--  2.0 unx       13 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/Experiments.tsx
+-rw-r--r--  2.0 unx   495919 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/logo.pxm
+-rw-r--r--  2.0 unx     3255 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/reducers.ts
+-rw-r--r--  2.0 unx      918 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/store.ts
+-rw-r--r--  2.0 unx     2845 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/TaskDetail.tsx
+-rw-r--r--  2.0 unx     1368 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/App.tsx
+-rw-r--r--  2.0 unx     1583 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/theme/theme.scss
+-rw-r--r--  2.0 unx     3400 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/theme/_jobs.scss
+-rw-r--r--  2.0 unx     3629 b- defN 23-Jul-23 15:58 experimaestro-1.0.0/app/src/ui/messages.tsx
+247 files, 13320556 bytes uncompressed, 5125839 bytes compressed:  61.5%
```

## zipnote {}

```diff
@@ -1,370 +1,742 @@
-Filename: experimaestro/__init__.py
+Filename: experimaestro-1.0.0/
 Comment: 
 
-Filename: experimaestro/__main__.py
+Filename: experimaestro-1.0.0/docs/
 Comment: 
 
-Filename: experimaestro/annotations.py
+Filename: experimaestro-1.0.0/scripts/
 Comment: 
 
-Filename: experimaestro/checkers.py
+Filename: experimaestro-1.0.0/src/
 Comment: 
 
-Filename: experimaestro/click.py
+Filename: experimaestro-1.0.0/app/
 Comment: 
 
-Filename: experimaestro/commandline.py
+Filename: experimaestro-1.0.0/requirements.txt
 Comment: 
 
-Filename: experimaestro/dependencies.py
+Filename: experimaestro-1.0.0/setup.cfg
 Comment: 
 
-Filename: experimaestro/environment.py
+Filename: experimaestro-1.0.0/pytest.ini
 Comment: 
 
-Filename: experimaestro/generators.py
+Filename: experimaestro-1.0.0/mkdocs.yml
 Comment: 
 
-Filename: experimaestro/ipc.py
+Filename: experimaestro-1.0.0/.gitmodules
 Comment: 
 
-Filename: experimaestro/locking.py
+Filename: experimaestro-1.0.0/PKG-INFO
 Comment: 
 
-Filename: experimaestro/mypy.py
+Filename: experimaestro-1.0.0/CHANGELOG.md
 Comment: 
 
-Filename: experimaestro/notifications.py
+Filename: experimaestro-1.0.0/.gitignore
 Comment: 
 
-Filename: experimaestro/register.py
+Filename: experimaestro-1.0.0/MANIFEST.in
 Comment: 
 
-Filename: experimaestro/rpyc.py
+Filename: experimaestro-1.0.0/.flake8
 Comment: 
 
-Filename: experimaestro/scheduler.py
+Filename: experimaestro-1.0.0/LICENSE
 Comment: 
 
-Filename: experimaestro/scriptbuilder.py
+Filename: experimaestro-1.0.0/.prettierignore
 Comment: 
 
-Filename: experimaestro/taskglobals.py
+Filename: experimaestro-1.0.0/README.md
 Comment: 
 
-Filename: experimaestro/tokens.py
+Filename: experimaestro-1.0.0/setup.py
 Comment: 
 
-Filename: experimaestro/typingutils.py
+Filename: experimaestro-1.0.0/pyproject.toml
 Comment: 
 
-Filename: experimaestro/workspace.py
+Filename: experimaestro-1.0.0/tox.ini
 Comment: 
 
-Filename: experimaestro/xpmutils.py
+Filename: experimaestro-1.0.0/.readthedocs.yml
 Comment: 
 
-Filename: experimaestro/connectors/__init__.py
+Filename: experimaestro-1.0.0/.pre-commit-config.yaml
 Comment: 
 
-Filename: experimaestro/connectors/local.py
+Filename: experimaestro-1.0.0/docs/launchers/
 Comment: 
 
-Filename: experimaestro/connectors/ssh.py
+Filename: experimaestro-1.0.0/docs/experiments/
 Comment: 
 
-Filename: experimaestro/core/__init__.py
+Filename: experimaestro-1.0.0/docs/connectors/
 Comment: 
 
-Filename: experimaestro/core/arguments.py
+Filename: experimaestro-1.0.0/docs/requirements.txt
 Comment: 
 
-Filename: experimaestro/core/objects.py
+Filename: experimaestro-1.0.0/docs/faq.md
 Comment: 
 
-Filename: experimaestro/core/types.py
+Filename: experimaestro-1.0.0/docs/configuration.md
 Comment: 
 
-Filename: experimaestro/launchers/__init__.py
+Filename: experimaestro-1.0.0/docs/index.md
 Comment: 
 
-Filename: experimaestro/launchers/oar.py
+Filename: experimaestro-1.0.0/docs/documenting.md
 Comment: 
 
-Filename: experimaestro/launchers/slurm.py
+Filename: experimaestro-1.0.0/docs/cli.md
 Comment: 
 
-Filename: experimaestro/launchers/unix.py
+Filename: experimaestro-1.0.0/docs/changelog.md
 Comment: 
 
-Filename: experimaestro/mkdocs/__init__.py
+Filename: experimaestro-1.0.0/docs/serialization.md
 Comment: 
 
-Filename: experimaestro/mkdocs/annotations.py
+Filename: experimaestro-1.0.0/docs/tutorial.md
 Comment: 
 
-Filename: experimaestro/mkdocs/base.py
+Filename: experimaestro-1.0.0/docs/concepts.md
 Comment: 
 
-Filename: experimaestro/mkdocs/metaloader.py
+Filename: experimaestro-1.0.0/docs/jupyter.md
 Comment: 
 
-Filename: experimaestro/mkdocs/style.css
+Filename: experimaestro-1.0.0/docs/launchers/index.md
 Comment: 
 
-Filename: experimaestro/server/__init__.py
+Filename: experimaestro-1.0.0/docs/experiments/task.md
 Comment: 
 
-Filename: experimaestro/server/data/favicon.ico
+Filename: experimaestro-1.0.0/docs/experiments/config.md
 Comment: 
 
-Filename: experimaestro/server/data/index.html
+Filename: experimaestro-1.0.0/docs/experiments/overview.md
 Comment: 
 
-Filename: experimaestro/server/data/static/index.css
+Filename: experimaestro-1.0.0/docs/experiments/plan.md
 Comment: 
 
-Filename: experimaestro/server/data/static/index.css.map
+Filename: experimaestro-1.0.0/docs/connectors/index.md
 Comment: 
 
-Filename: experimaestro/server/data/static/index.js
+Filename: experimaestro-1.0.0/scripts/longtask.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.eot
+Filename: experimaestro-1.0.0/src/experimaestro/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.svg
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.ttf
+Filename: experimaestro-1.0.0/src/experimaestro/launcherfinder/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff
+Filename: experimaestro-1.0.0/src/experimaestro/mkdocs/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/tools/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.eot
+Filename: experimaestro-1.0.0/src/experimaestro/sphinx/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.svg
+Filename: experimaestro-1.0.0/src/experimaestro/server/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.ttf
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.woff
+Filename: experimaestro-1.0.0/src/experimaestro/core/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-regular-400.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/utils/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.eot
+Filename: experimaestro-1.0.0/src/experimaestro/connectors/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.svg
+Filename: experimaestro-1.0.0/src/experimaestro/tests/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.ttf
+Filename: experimaestro-1.0.0/src/experimaestro/scheduler/
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.woff
+Filename: experimaestro-1.0.0/src/experimaestro/run.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/@fortawesome/fontawesome-free/webfonts/fa-solid-900.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/mypy.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.eot
+Filename: experimaestro-1.0.0/src/experimaestro/filter.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.ttf
+Filename: experimaestro-1.0.0/src/experimaestro/version.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.woff
+Filename: experimaestro-1.0.0/src/experimaestro/rpyc.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIcons-Regular.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/typingutils.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.eot
+Filename: experimaestro-1.0.0/src/experimaestro/generators.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.otf
+Filename: experimaestro-1.0.0/src/experimaestro/annotations.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.woff
+Filename: experimaestro-1.0.0/src/experimaestro/ipc.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsOutlined-Regular.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/xpmutils.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.eot
+Filename: experimaestro-1.0.0/src/experimaestro/checkers.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.otf
+Filename: experimaestro-1.0.0/src/experimaestro/tokens.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.woff
+Filename: experimaestro-1.0.0/src/experimaestro/settings.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsRound-Regular.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/compat.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.eot
+Filename: experimaestro-1.0.0/src/experimaestro/notifications.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.otf
+Filename: experimaestro-1.0.0/src/experimaestro/huggingface.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.woff
+Filename: experimaestro-1.0.0/src/experimaestro/locking.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsSharp-Regular.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/__init__.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.eot
+Filename: experimaestro-1.0.0/src/experimaestro/click.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.otf
+Filename: experimaestro-1.0.0/src/experimaestro/__main__.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.woff
+Filename: experimaestro-1.0.0/src/experimaestro/scriptbuilder.py
 Comment: 
 
-Filename: experimaestro/server/data/static/assets/material-icons/iconfont/MaterialIconsTwoTone-Regular.woff2
+Filename: experimaestro-1.0.0/src/experimaestro/commandline.py
 Comment: 
 
-Filename: experimaestro/tests/__init__.py
+Filename: experimaestro-1.0.0/src/experimaestro/taskglobals.py
 Comment: 
 
-Filename: experimaestro/tests/conftest.py
+Filename: experimaestro-1.0.0/src/experimaestro/launcherfinder/specs.py
 Comment: 
 
-Filename: experimaestro/tests/definitions_types.py
+Filename: experimaestro-1.0.0/src/experimaestro/launcherfinder/base.py
 Comment: 
 
-Filename: experimaestro/tests/restart.py
+Filename: experimaestro-1.0.0/src/experimaestro/launcherfinder/registry.py
 Comment: 
 
-Filename: experimaestro/tests/restart_main.py
+Filename: experimaestro-1.0.0/src/experimaestro/launcherfinder/__init__.py
 Comment: 
 
-Filename: experimaestro/tests/task_tokens.py
+Filename: experimaestro-1.0.0/src/experimaestro/launcherfinder/parser.py
 Comment: 
 
-Filename: experimaestro/tests/test_checkers.py
+Filename: experimaestro-1.0.0/src/experimaestro/mkdocs/style.css
 Comment: 
 
-Filename: experimaestro/tests/test_forward.py
+Filename: experimaestro-1.0.0/src/experimaestro/mkdocs/annotations.py
 Comment: 
 
-Filename: experimaestro/tests/test_identifier.py
+Filename: experimaestro-1.0.0/src/experimaestro/mkdocs/base.py
 Comment: 
 
-Filename: experimaestro/tests/test_instance.py
+Filename: experimaestro-1.0.0/src/experimaestro/mkdocs/__init__.py
 Comment: 
 
-Filename: experimaestro/tests/test_objects.py
+Filename: experimaestro-1.0.0/src/experimaestro/mkdocs/metaloader.py
 Comment: 
 
-Filename: experimaestro/tests/test_outputs.py
+Filename: experimaestro-1.0.0/src/experimaestro/tools/jobs.py
 Comment: 
 
-Filename: experimaestro/tests/test_param.py
+Filename: experimaestro-1.0.0/src/experimaestro/tools/__init__.py
 Comment: 
 
-Filename: experimaestro/tests/test_snippets.py
+Filename: experimaestro-1.0.0/src/experimaestro/tools/diff.py
 Comment: 
 
-Filename: experimaestro/tests/test_ssh.py
+Filename: experimaestro-1.0.0/src/experimaestro/sphinx/static/
 Comment: 
 
-Filename: experimaestro/tests/test_tags.py
+Filename: experimaestro-1.0.0/src/experimaestro/sphinx/__init__.py
 Comment: 
 
-Filename: experimaestro/tests/test_tasks.py
+Filename: experimaestro-1.0.0/src/experimaestro/sphinx/static/experimaestro.css
 Comment: 
 
-Filename: experimaestro/tests/test_tokens.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/
 Comment: 
 
-Filename: experimaestro/tests/test_types.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/__init__.py
 Comment: 
 
-Filename: experimaestro/tests/test_validation.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/index.html
 Comment: 
 
-Filename: experimaestro/tests/token_reschedule.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/3a4004a46a653d4b2166.woff
 Comment: 
 
-Filename: experimaestro/tests/utils.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/b48ad290d0335879a92b.ttf
 Comment: 
 
-Filename: experimaestro/tests/connectors/test_local.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/index.js.map
 Comment: 
 
-Filename: experimaestro/tests/connectors/utils.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/5d681e2edae8c60630db.woff
 Comment: 
 
-Filename: experimaestro/tests/connectors/bin/executable.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/index.css.map
 Comment: 
 
-Filename: experimaestro/tests/launchers/test_slurm.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/index.css
 Comment: 
 
-Filename: experimaestro/tests/launchers/bin/sacct
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/f882956fd323fd322f31.woff
 Comment: 
 
-Filename: experimaestro/tests/launchers/bin/sbatch
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/index.js
 Comment: 
 
-Filename: experimaestro/tests/launchers/bin/test.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/manifest.json
 Comment: 
 
-Filename: experimaestro/tests/scripts/waitforfile.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/e1a247a5ef41e1975742.woff2
 Comment: 
 
-Filename: experimaestro/tests/tasks/__init__.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/login.html
 Comment: 
 
-Filename: experimaestro/tests/tasks/all.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/6f420cf17cc0d7676fad.woff2
 Comment: 
 
-Filename: experimaestro/tests/tasks/foreign.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/4ef4218c522f1eb6b5b1.woff2
 Comment: 
 
-Filename: experimaestro/tests/tasks/subparams.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/66104b766c3d0462b3c5.woff2
 Comment: 
 
-Filename: experimaestro/utils/__init__.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/4d73cb90e394b34b7670.woff
 Comment: 
 
-Filename: experimaestro/utils/jobs.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/favicon.ico
 Comment: 
 
-Filename: experimaestro/utils/jupyter.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/219aa9140e099e6c72ed.woff2
 Comment: 
 
-Filename: experimaestro/utils/settings.py
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/3baa5b8f3469222b822d.woff
 Comment: 
 
-Filename: experimaestro-0.9.9.dist-info/LICENSE
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/f9ee61fab3c11e2f3ed3.ttf
 Comment: 
 
-Filename: experimaestro-0.9.9.dist-info/METADATA
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/c380809fd3677d7d6903.woff2
 Comment: 
 
-Filename: experimaestro-0.9.9.dist-info/WHEEL
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/abf801b7acb6705a15ad.ttf
 Comment: 
 
-Filename: experimaestro-0.9.9.dist-info/entry_points.txt
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/0c35d18bf06992036b69.woff2
 Comment: 
 
-Filename: experimaestro-0.9.9.dist-info/top_level.txt
+Filename: experimaestro-1.0.0/src/experimaestro/server/data/639d2000c1ece92eaec8.woff2
 Comment: 
 
-Filename: experimaestro-0.9.9.dist-info/RECORD
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/slurm/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/direct.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/oar.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/slurm/base.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/slurm/configuration.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/slurm/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/launchers/slurm/cli.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/arguments.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/types.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/objects.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/objects.pyi
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/context.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/utils.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/core/serializers.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/utils/resources.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/utils/yaml.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/utils/settings.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/utils/jobs.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/utils/asyncio.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/utils/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/utils/jupyter.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/connectors/ssh.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/connectors/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/connectors/local.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/tasks/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/scripts/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/connectors/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_snippets.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_objects.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/task_tokens.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/restart.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/conftest.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_outputs.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_tasks.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_ssh.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_validation.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_serializers.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_identifier.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_findlauncher.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/token_reschedule.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_forward.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_param.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_tags.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_dependencies.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/restart_main.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/utils.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_tokens.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_instance.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_progress.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/definitions_types.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_checkers.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/test_types.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/config_slurm/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/test_local.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/test_slurm.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/common.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/config_slurm/launchers.yaml
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/config_slurm/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/sacct
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/sbatch
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/test.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/tasks/all.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/tasks/foreign.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/tasks/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/scripts/notifyandwait.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/scripts/waitforfile.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/connectors/bin/
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/connectors/test_local.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/connectors/utils.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/tests/connectors/bin/executable.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/scheduler/dependencies.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/scheduler/services.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/scheduler/workspace.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/scheduler/environment.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/scheduler/base.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro/scheduler/__init__.py
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/PKG-INFO
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/not-zip-safe
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/top_level.txt
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/SOURCES.txt
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/requires.txt
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/dependency_links.txt
+Comment: 
+
+Filename: experimaestro-1.0.0/src/experimaestro.egg-info/entry_points.txt
+Comment: 
+
+Filename: experimaestro-1.0.0/app/xp/
+Comment: 
+
+Filename: experimaestro-1.0.0/app/public/
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/
+Comment: 
+
+Filename: experimaestro-1.0.0/app/tsconfig.json
+Comment: 
+
+Filename: experimaestro-1.0.0/app/CHANGELOG.md
+Comment: 
+
+Filename: experimaestro-1.0.0/app/.gitignore
+Comment: 
+
+Filename: experimaestro-1.0.0/app/package.json
+Comment: 
+
+Filename: experimaestro-1.0.0/app/README.md
+Comment: 
+
+Filename: experimaestro-1.0.0/app/package-lock.json
+Comment: 
+
+Filename: experimaestro-1.0.0/app/.nolluprc.js
+Comment: 
+
+Filename: experimaestro-1.0.0/app/webpack.config.ts
+Comment: 
+
+Filename: experimaestro-1.0.0/app/postcss.config.js
+Comment: 
+
+Filename: experimaestro-1.0.0/app/xp/run.py
+Comment: 
+
+Filename: experimaestro-1.0.0/app/public/index.html
+Comment: 
+
+Filename: experimaestro-1.0.0/app/public/manifest.json
+Comment: 
+
+Filename: experimaestro-1.0.0/app/public/login.html
+Comment: 
+
+Filename: experimaestro-1.0.0/app/public/favicon.ico
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/theme/
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/ui/
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/logo.png
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/index.tsx
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/client.ts
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/Services.tsx
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/Tasks.tsx
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/index.css
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/clipboard.ts
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/TaskJobs.tsx
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/Experiments.tsx
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/logo.pxm
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/reducers.ts
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/store.ts
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/TaskDetail.tsx
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/App.tsx
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/theme/theme.scss
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/theme/_jobs.scss
+Comment: 
+
+Filename: experimaestro-1.0.0/app/src/ui/messages.tsx
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## Comparing `experimaestro/__init__.py` & `experimaestro-1.0.0/src/experimaestro/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,59 +3,70 @@
 from pathlib import Path
 
 # Annotations
 from .annotations import (
     config,
     task,
     param,
-    subparam,
     ConstantParam,
     constant,
     option,
     pathoption,
     cache,
     Identifier,
     Array,
+    TagDict,
     tag,
     tags,
     tagspath,
     STDOUT,
     STDERR,
+    deprecate,
     # deprecated
     argument,
+    initializer,
 )
 from .core.arguments import (
     # Types
     Param,
-    SubParam,
     Option,
     Meta,
+    DataPath,
     Annotated,
     Constant,
     # Annotations helpers
     help,
     default,
 )
 from .generators import pathgenerator
-from .core.objects import Config, Task, SerializedConfig, Serialized
-from .environment import Environment
-from .workspace import Workspace
-from .scheduler import Scheduler, experiment
+from .core.objects import (
+    Config,
+    copyconfig,
+    setmeta,
+    Task,
+    LightweightTask,
+    ObjectStore,
+)
+from .core.serializers import SerializationLWTask, PathSerializationLWTask
+from .core.types import Any, SubmitHook
+from .launchers import Launcher
+from .scheduler.environment import Environment
+from .scheduler.workspace import Workspace, RunMode
+from .scheduler import Scheduler, experiment, FailedExperiment
 from .notifications import progress, tqdm
-from .register import parse_commandline
-from .core.types import Any
 from .checkers import Choices
 from .xpmutils import DirectoryContext
 from .mkdocs.annotations import documentation
+from .scheduler.base import Job
+from .launcherfinder.registry import LauncherRegistry
 
 
-def set_launcher(launcher):
+def set_launcher(launcher: Launcher):
     Workspace.CURRENT.launcher = launcher
 
 
 # Get version
-from pkg_resources import get_distribution, DistributionNotFound
-
 try:
-    __version__ = get_distribution(__name__).version
-except DistributionNotFound:
+    from .version import __version__, __version_tuple__
+except:
     __version__ = "?"
+    __version_tuple__ = (0, 0, 0, "", "")
```

## Comparing `experimaestro/annotations.py` & `experimaestro-1.0.0/src/experimaestro/annotations.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,22 +1,20 @@
 # Import Python modules
 
-import sys
 import inspect
-import logging
 from pathlib import Path
-from typing import Type as TypingType, Optional, TypeVar
-
+from typing import Callable, Type as TypingType, Optional, TypeVar, Union
+from sortedcontainers import SortedDict
 import experimaestro.core.objects as objects
 import experimaestro.core.types as types
 from experimaestro.generators import PathGenerator
 
 from .core.arguments import Argument as CoreArgument
 from .core.objects import Config
-from .core.types import Identifier, TypeProxy, Type, ObjectType
+from .core.types import Any, Identifier, TypeProxy, Type, ObjectType
 from .utils import logger
 from .checkers import Checker
 
 # --- Annotations to define tasks and types
 
 T = TypeVar("T")
 
@@ -29,20 +27,26 @@
 class config:
     """Annotations for experimaestro types"""
 
     def __init__(self, identifier=None, description=None):
         """[summary]
 
         Keyword Arguments:
-            identifier {Identifier, str} -- Unique identifier of the type, generate by default (None)
-            description {str} -- (deprecated, use comments) Description of the config/task, and use comments with (default) None
-            register {bool} -- False if the type should not be registered (debug only)
+            identifier {Identifier, str} -- Unique identifier of the type,
+            generate by default (None)
+
+            description {str} -- (deprecated, use
+            comments) Description of the config/task, use comments with
+            (default) None
 
-        The identifier, if not specified, will be set to `X.CLASSNAME`(by order of priority),
-        where X is:
+            register {bool} -- False if the type should not be
+            registered (debug only)
+
+        The identifier, if not specified, will be set to `X.CLASSNAME`(by order
+        of priority), where X is:
             - the parent identifier
             - the module qualified name
         """
         super().__init__()
         self.identifier = identifier
         if isinstance(self.identifier, str):
             self.identifier = Identifier(self.identifier)
@@ -130,15 +134,14 @@
         self.type = Type.fromType(type) if type else None
         self.help = help
         self.ignored = ignored
         self.default = default
         self.required = required
         self.generator = None
         self.checker = checker
-        self.subparam = False
         self.constant = constant
 
     def __call__(self, tp):
         # Don't annotate in task mode
         tp.__getxpmtype__().addAnnotation(self)
         return tp
 
@@ -157,28 +160,19 @@
             self.type,
             help=self.help,
             required=self.required,
             ignored=self.ignored,
             generator=self.generator,
             default=self.default,
             checker=self.checker,
-            subparam=self.subparam,
             constant=self.constant,
         )
         xpmtype.addArgument(argument)
 
 
-class subparam(param):
-    """Defines an argument for an experimaestro type"""
-
-    def __init__(self, *args, **kwargs):
-        super().__init__(*args, **kwargs)
-        self.subparam = True
-
-
 # Just a rebind (back-compatibility)
 argument = param
 
 
 class option(param):
     """An argument which is ignored
 
@@ -203,16 +197,20 @@
 
         if path is None:
             path = name
 
         self.generator = PathGenerator(path)
 
 
-STDERR = lambda jobcontext, config: "%s.err" % jobcontext.name
-STDOUT = lambda jobcontext, config: "%s.out" % jobcontext.name
+def STDERR(jobcontext, config):
+    return "%s.err" % jobcontext.name
+
+
+def STDOUT(jobcontext, config):
+    return "%s.out" % jobcontext.name
 
 
 class constant(param):
     """
     An constant argument (useful for versionning tasks)
     """
 
@@ -225,42 +223,88 @@
 # --- Cache
 
 
 def cache(name: str):
     """Use a cache path for a given config"""
 
     def annotate(method):
-
         return objects.cache(method, name)
 
     return annotate
 
 
 # --- Tags
 
 
 def tag(value):
     """Tag a value"""
     return objects.TaggedValue(value)
 
 
-def tags(value):
+class TagDict(SortedDict):
+    """A hashable dictionary"""
+
+    def __hash__(self):
+        return hash(tuple((key, value) for key, value in self.items()))
+
+    def __setitem__(self, key, value):
+        raise Exception("A tag dictionary is not mutable")
+
+
+def tags(value) -> TagDict:
     """Return the tags associated with a value"""
-    return value.__xpm__.tags()
+    return TagDict(value.__xpm__.tags())
+
+
+def _normalizepathcomponent(v: Any):
+    if isinstance(v, str):
+        return v.replace("/", "-")
+    return v
 
 
 def tagspath(value: Config):
     """Return a unique path made of tags and their values"""
-    sortedtags = sorted(value.__xpm__.tags().items(), key=lambda x: x[0])
-    return "_".join(f"""{key.replace("/", "-")}={value}""" for key, value in sortedtags)
+    return "_".join(
+        f"""{_normalizepathcomponent(key)}={_normalizepathcomponent(value)}"""
+        for key, value in tags(value).items()
+    )
 
 
 # --- Deprecated
 
 
+def deprecate(config: Union[TypingType[Config], Callable]):
+    """Deprecate a configuration / task or
+    an attribute (via a method)
+
+    Usage:
+
+        @deprecate
+        class OldConfig(NewConfig):
+            pass
+
+        # Or only a parameter
+        class MyConfig():
+            @deprecate
+            def oldattribute(self, value):
+                # Do something with the value
+                pass
+    """
+    if inspect.isclass(config):
+        config.__getxpmtype__().deprecate()
+        return config
+
+    if inspect.isfunction(config):
+        from experimaestro.core.types import DeprecatedAttribute
+
+        return DeprecatedAttribute(config)
+
+    raise NotImplementedError("Cannot deprecate %s", config)
+
+
 def deprecateClass(klass):
     import inspect
 
     def __init__(self, *args, **kwargs):
         frameinfo = inspect.stack()[1]
         logger.warning(
             "Class %s is deprecated: use %s in %s:%s (%s)",
@@ -270,7 +314,17 @@
             frameinfo.lineno,
             frameinfo.code_context,
         )
         super(klass, self).__init__(*args, **kwargs)
 
     klass.__init__ = __init__
     return klass
+
+
+def initializer(method):
+    """Defines a method as an initializer that can only be called once"""
+
+    def wrapper(self, *args, **kwargs):
+        value = method(self, *args, **kwargs)
+        setattr(self, method.__name__, lambda *args, **kwargs: value)
+
+    return wrapper
```

## Comparing `experimaestro/checkers.py` & `experimaestro-1.0.0/src/experimaestro/checkers.py`

 * *Files identical despite different names*

## Comparing `experimaestro/click.py` & `experimaestro-1.0.0/src/experimaestro/click.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,50 +1,47 @@
 import click
-from experimaestro import parse_commandline, Environment
+from experimaestro import Environment
+from experimaestro.run import parse_commandline
 
 """Defines the task command line argument prefix for experimaestro-handled command lines"""
 
 
 @click.group()
 def cli():
     """Main entry point for CLI"""
     pass
 
 
-@cli.command(context_settings={"allow_extra_args": True})
-@click.pass_context
-def xpm(context):
-    """Command used to run a task"""
-    parse_commandline(context)
-
-
 class forwardoptionMetaclass(type):
     def __getattr__(self, key):
         """Access to a class field"""
         return forwardoption([key])
 
 
 class forwardoption(metaclass=forwardoptionMetaclass):
     """Allows to access an argument of the configuration
 
     This allows to refer to a path of a class in a "python" syntax, e.g.
     `@forwardoption.ranker.optimizer.epsilon(MyConfig)` or
     `@forwardoption.ranker.optimizer.epsilon(MyConfig, "option-name")`
+
+    default can be changed by setting the option
     """
 
     def __init__(self, path=[]):
         self.path = path
 
-    def __call__(self, cls, option_name=None, default=None):
+    def __call__(self, cls, option_name=None, **kwargs):
+        """ """
         argument = cls.__getxpmtype__().arguments[self.path[0]]
         for c in self.path[1:]:
             argument = getattr(argument, c)
 
         name = "--%s" % (option_name or argument.name.replace("_", "-"))
-        default = default if default is not None else argument.default
+        default = kwargs["default"] if "default" in kwargs else argument.default
 
         # TODO: set the type of the option when not a simple type
         return click.option(name, help=argument.help or "", default=default)
 
     def __getattr__(self, key):
         """Access to a class field"""
         return forwardoption([key])
```

## Comparing `experimaestro/commandline.py` & `experimaestro-1.0.0/src/experimaestro/commandline.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 """Command line jobs"""
 
 import json
-import os
 import io
 from pathlib import Path
-from typing import Union, Callable, Dict
+from typing import List, Optional, Union, Callable, Dict
 import itertools
-import psutil
+from experimaestro.core.context import SerializationContext
+from experimaestro.scheduler.workspace import RunMode
 
 from experimaestro.utils import logger
-from .scheduler import Job, JobError, JobState
-from .connectors import Redirect, RedirectType, Connector
+from .scheduler import Job, JobState
+from .connectors import Process, Redirect, RedirectType, Connector
 from .scheduler import Workspace
 from .core.objects import Config
 
 
 # 5 seconds wait for locking file
 LOCKFILE_WAIT_DURATION = 5
 
@@ -46,23 +46,24 @@
         raise NotImplementedError("output for %s" % self.__class__)
 
 
 class AbstractCommandComponent(CommandPart):
     pass
 
 
-class CommandContext:
+class CommandContext(SerializationContext):
     def __init__(
         self,
         workspace: Workspace,
         connector: Connector,
         path: Path,
         name: str,
         config: Config,
     ):
+        super().__init__()
         self.workspace = workspace
         self.connector = connector
         self.path = path
         self.name = name
         self.config = config
         self.namedPipeRedirectionsMap: Dict["CommandPart", NamedPipeRedirections] = {}
         self.auxiliary: Dict[str, int] = {}
@@ -219,110 +220,108 @@
         for command in self.commands:
             command.forEach(f)
 
     def reorder(self):
         return self.commands
 
 
-class JobProcess:
-    def __init__(self, job, process):
-        self.job = job
-        self.process = process
-
-    def wait(self):
-        self.process.wait()
-        if self.job.donepath.is_file():
-            return 0
-        return int(self.job.failedpath.read_text())
-
-
 class CommandLineJob(Job):
     def __init__(
         self,
         commandline: CommandLine,
         parameters,
-        workspace=None,
+        workspace: Optional[Workspace] = None,
         launcher=None,
-        dryrun=False,
+        run_mode: RunMode = None,
     ):
         super().__init__(
-            parameters, workspace=workspace, launcher=launcher, dryrun=dryrun
+            parameters, workspace=workspace, launcher=launcher, run_mode=run_mode
         )
         self.commandline = commandline
 
-    @property
-    def process(self):
-        """Returns the process"""
+    async def aio_process(self) -> Optional[Process]:
+        """Returns the process if there is one"""
         if self._process:
             return self._process
 
         if self.pidpath.is_file():
             # Get from pidpath file
             from experimaestro.connectors import Process
 
             pinfo = json.loads(self.pidpath.read_text())
-            handler = Process.handler(pinfo["type"])
-            if handler is not None:
-                p = handler.fromspec(pinfo)
-                if p and p.is_running():
-                    return JobProcess(self, p)
+            p = Process.fromDefinition(self.launcher.connector, pinfo)
+            if p is None:
+                return None
+
+            if await p.aio_isrunning():
+                return p
+
+            return None
 
-            else:
-                logger.error(f"Type {pinfo['type']} is not handled")
         return None
 
-    def run(self, locks):
-        # Use the lock during preparation
-        logger.info("Running job %s...", self)
+    @property
+    def notificationURL(self):
+        if self.launcher and self.launcher.notificationURL:
+            return self.launcher.notificationURL
+        return self.workspace.notificationURL
+
+    def prepare(self, overwrite=False):
+        """Prepare all files before starting a task
+
+        :param overwrite: if True, overwrite files even if the task has been run
+        """
+        logger.debug("Preparing job %s...", self)
+
+        assert self.launcher is not None, "No launcher defined for this job"
 
         scriptbuilder = self.launcher.scriptbuilder()
-        processbuilder = self.launcher.processbuilder()
-        connector = self.launcher.connector
+        self.path.mkdir(parents=True, exist_ok=True)
         donepath = self.donepath
 
-        # Lock the job and check done again (just in case)
-        logger.debug("Making directories job %s...", self.path)
-        directory = self.path
-        if not directory.is_dir():
-            directory.mkdir(parents=True, exist_ok=True)
-
-        process = self.process
-        if process:
-            return process
-
-        logger.info("Locking job lock path %s", self.lockpath)
-        with connector.lock(self.lockpath, LOCKFILE_WAIT_DURATION) as out:
-            # Check again if done (now that we have locked)
-            if donepath.is_file():
-                logger.info("Job %s is already done", self)
-                return JobState.DONE
-
-            # Now we can write the script
-            scriptbuilder.lockfiles.append(self.lockpath)
-            scriptbuilder.command = self.commandline
-            scriptbuilder.notificationURL = self.launcher.notificationURL
-            scriptPath = scriptbuilder.write(self)
-
-            processbuilder.environ = self.launcher.environ
-            processbuilder.command.append(self.launcher.connector.resolve(scriptPath))
-            processbuilder.stderr = Redirect.file(self.stderr)
-            processbuilder.stdout = Redirect.file(self.stdout)
+        # Check again if done (now that we have locked)
+        if not overwrite and donepath.is_file():
+            logger.info("Job %s is already done", self)
+            return JobState.DONE
+
+        # Now we can write the script
+        scriptbuilder.lockfiles.append(self.lockpath)
+        scriptbuilder.command = self.commandline
+        scriptbuilder.notificationURL = self.notificationURL
+        return scriptbuilder.write(self)
+
+    async def aio_run(self):
+        if self._process:
+            return self._process
+
+        scriptPath = self.prepare()
 
         logger.info("Starting job %s", self.jobpath)
+        processbuilder = self.launcher.processbuilder()
+        processbuilder.environ = self.environ
+        processbuilder.command.append(self.launcher.connector.resolve(scriptPath))
+        processbuilder.stderr = Redirect.file(self.stderr)
+        processbuilder.stdout = Redirect.file(self.stdout)
         self._process = processbuilder.start()
+
+        with self.pidpath.open("w") as fp:
+            json.dump(self._process.tospec(), fp)
+
         self.state = JobState.RUNNING
         logger.info("Process started (%s)", self._process)
         return self._process
 
 
 class CommandLineTask:
     def __init__(self, commandline: CommandLine):
         self.commandline = commandline
 
-    def __call__(self, pyobject, *, launcher=None, workspace=None, dryrun=False) -> Job:
+    def __call__(
+        self, pyobject, *, launcher=None, workspace=None, run_mode=None
+    ) -> Job:
         return CommandLineJob(
             self.commandline,
             pyobject,
             launcher=launcher,
             workspace=workspace,
-            dryrun=dryrun,
+            run_mode=run_mode,
         )
```

## Comparing `experimaestro/dependencies.py` & `experimaestro-1.0.0/src/experimaestro/scheduler/dependencies.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 """Dependency between tasks and tokens"""
 
-from enum import Enum
-from .utils import logger
-from typing import Set
-from .locking import Lock
 import threading
+from typing import Optional, Set, TYPE_CHECKING
+import asyncio
+from enum import Enum
+from ..utils import logger
+from ..locking import Lock
+
+if TYPE_CHECKING:
+    from . import Job
 
 
 class Dependents:
     """Encapsulate the access to the dependents"""
 
     def __init__(self):
         self.lock = threading.Lock()
@@ -41,31 +45,33 @@
 
     FAIL = 2
     """Dependency won't be availabe in the foreseeable future"""
 
 
 class Dependency:
     # Dependency status
+    loop: asyncio.AbstractEventLoop
 
     def __init__(self, origin):
         # Origin and target are two resources
         self.origin = origin
-        self.target = None
+        self.target: Optional["Job"] = None
         self.currentstatus = DependencyStatus.WAIT
 
     def status(self) -> DependencyStatus:
         raise NotImplementedError()
 
     def lock(self) -> Lock:
         raise NotImplementedError()
 
     def __repr__(self) -> str:
         return "Dep[{origin}->{target}]/{currentstatus}".format(**self.__dict__)
 
     def check(self):
+        assert self.target is not None
         status = self.status()
         logger.debug("Dependency check: %s", self)
         if status != self.currentstatus:
             logger.debug(
                 "Dependency %s is %s (was: %s)", self, status, self.currentstatus
             )
             self.target.dependencychanged(self, self.currentstatus, status)
```

## Comparing `experimaestro/environment.py` & `experimaestro-1.0.0/src/experimaestro/scheduler/environment.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 """Defines an experimental environment"""
 
 from pathlib import Path
 from typing import Dict
 import marshmallow as mm
-from .connectors import parsepath
-from .connectors.ssh import SshPath
-from experimaestro.utils.settings import JsonSettings, PathField
+from experimaestro.utils.settings import JsonSettings
 from pytools import memoize
 
 
 def schema(schema_cls):
     def annotate(object_cls):
         schema_cls.OBJECT_CLS = object_cls
         object_cls.SCHEMA = schema_cls
@@ -25,15 +23,18 @@
         for key, value in data.items():
             setattr(settings, key, value)
         return settings
 
 
 class EnvironmentSchema(_Schema):
     hostname = mm.fields.Str()
+    """The hostname (can be empty for localhost)"""
+
     pythonpath = mm.fields.Str()
+    """Path to python executable"""
     workdir = mm.fields.Str()
     environ = mm.fields.Dict(keys=mm.fields.Str(), values=mm.fields.Str())
 
 
 class Schema(_Schema):
     environments = mm.fields.Dict(
         keys=mm.fields.Str(), values=mm.fields.Nested(EnvironmentSchema)
@@ -46,37 +47,43 @@
 
     def __init__(self):
         self.environments: Dict[str, str] = {}
 
 
 @schema(EnvironmentSchema)
 class Environment:
-    """This defines the environment for an experiment, which can be stored"""
+    """This defines the environment for an experiment, and can be stored"""
 
     def __init__(self, workdir=None):
         self.hostname = None
         self._workdir = workdir
         self.pythonpath = None
         self.environ = {}
 
     @property
     def basepath(self):
         if self.hostname:
+            from ..connectors.ssh import SshPath
+
             return SshPath(f"ssh://{self.hostname}")
         return Path()
 
     @property
-    def workdir(self):
+    def workdir(self) -> Path:
         assert self._workdir, "The working directory has not been set"
         return self.basepath / self._workdir
 
     @workdir.setter
     def workdir(self, value):
         self._workdir = value
 
+    def setenv(self, key: str, value: str):
+        """Set the environment variable with key"""
+        self.environ[key] = value
+
     @staticmethod
     @memoize()
     def _load():
         path = (
             Path("~").expanduser() / ".config" / "experimaestro" / "environments.json"
         )
         return Settings.load(path)
```

## Comparing `experimaestro/ipc.py` & `experimaestro-1.0.0/src/experimaestro/ipc.py`

 * *Files 12% similar despite different names*

```diff
@@ -18,29 +18,23 @@
     def __init__(self):
         self.observer = Observer()
         self.observer.start()
         self.pid = os.getpid()
 
     def fswatch(self, watcher: FileSystemEventHandler, path: Path, recursive=False):
         if not self.observer.is_alive():
-            # Just in case...
-            self.observer.start()
+            logging.error("Observer is not alive")
+
         return self.observer.schedule(
             watcher, str(path.absolute()), recursive=recursive
         )
 
     def fsunwatch(self, watcher):
         self.observer.unschedule(watcher)
 
-    # def run(self):
-    #     logger.info("Starting IPC thread")
-    #     self.loop = asyncio.new_event_loop()
-    #     asyncio.set_event_loop(self.loop)
-    #     self.loop.run_forever()
-
 
 def fork_childhandler():
     if IPCom.INSTANCE:
         logger.warning(
             "Removing IPCom instance in child process (watchers won't be copied)"
         )
         IPCom.INSTANCE = None
```

## Comparing `experimaestro/rpyc.py` & `experimaestro-1.0.0/src/experimaestro/rpyc.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,16 @@
 import rpyc
 import threading
 import logging
 
 logger = logging.getLogger("rpyc")
 logger.setLevel(logging.WARNING)
 
-class client():
+
+class client:
     def __init__(self, hostname: str, pythonpath: str, port: int = None):
         """[summary]
 
         Arguments:
             hostname -- The hostname to connect to
             pythonpath -- The remote python path
         """
@@ -42,24 +43,33 @@
         # Get the remote unix_path
         command = self.ssh()
         command.extend(["mktemp", "-d"])
         logger.debug("Runnning %s", command)
         p = run(command, capture_output=True)
         p.check_returncode()
         remote_unix_path = p.stdout.decode("utf-8").strip() + "/rpyc-server.sock"
-        
+
         # Start server
         command = self.ssh(f"-L{local_unix_path}:{remote_unix_path}")
-        command.extend([self.pythonpath, "-m", "experimaestro", "rpyc-server", "--clean", remote_unix_path])
-        
+        command.extend(
+            [
+                self.pythonpath,
+                "-m",
+                "experimaestro",
+                "rpyc-server",
+                "--clean",
+                remote_unix_path,
+            ]
+        )
+
         logger.debug("Runnning %s", command)
         process = Popen(command, stdout=PIPE)
         atexit.register(lambda process: process.kill(), process)
 
-        # Wait for the server to be started        
+        # Wait for the server to be started
         process.stdout.readline()
 
         # Connect to server
         logger.info("Connecting to %s", local_unix_path)
         self.connection = rpyc.classic.unix_connect(local_unix_path)
 
     def __enter__(self):
@@ -71,18 +81,21 @@
         self.connection.close()
 
 
 # --- Server part
 
 server = None
 
+
 class ClassicService(rpyc.core.service.ClassicService):
     """Full duplex master/slave service, i.e. both parties have full control
     over the other. Must be used by both parties."""
-    __slots__ = ("connected")
+
+    __slots__ = "connected"
+
     def __init__(self):
         super().__init__()
         self.connected = False
 
     def on_connect(self, conn):
         self.connected = True
         super().on_connect(conn)
@@ -93,28 +106,33 @@
 
 
 def cleanup(path):
     logger.info("Cleaning up %s", path)
     path.unlink()
     path.parent.rmdir()
 
+
 def start_server(unix_path, clean=None):
     service = ClassicService()
-    server = OneShotServer(socket_path=str(unix_path), listener_timeout=1, service=service, logger=logger)
+    server = OneShotServer(
+        socket_path=str(unix_path), listener_timeout=1, service=service, logger=logger
+    )
+
     def sayhello():
         while not server.active:
-            time.sleep(.01)
+            time.sleep(0.01)
         print("HELLO", flush=True)
         logger.debug("Server started")
-        
+
         time.sleep(5)
         if not service.connected:
             logger.warning("No inbound connection: stopping")
             server.close()
 
     threading.Thread(target=sayhello).start()
     if clean:
         atexit.register(cleanup, unix_path)
     server.start()
 
+
 def stop_server():
     server.stop()
```

## Comparing `experimaestro/tokens.py` & `experimaestro-1.0.0/src/experimaestro/tokens.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,34 +1,49 @@
 """Tokens are special types of dependency controlling the access to 
 a computational resource (e.g. number of launched jobs, etc.)
 """
 
+from dataclasses import dataclass
 import sys
-import psutil
 from pathlib import Path
 from experimaestro.core.objects import Config
 import fasteners
 import threading
 import os.path
 from watchdog.events import FileSystemEventHandler
 from typing import Dict
+from experimaestro.launcherfinder.base import TokenConfiguration
+
+from experimaestro.launcherfinder.registry import LauncherRegistry
+from experimaestro.utils.yaml import YAMLDict
 
 from .ipc import ipcom
 from .locking import Lock, LockError
-from .dependencies import Dependency, DependencyStatus, Resource
+from .scheduler.dependencies import Dependency, DependencyStatus, Resource
 import logging
+import json
 
 
 logger = logging.getLogger("xpm.tokens")
 
 
 class Token(Resource):
     """Base class for all token-based resources"""
 
-    pass
+    available: int
+
+    def aio_notify(self):
+        # Notifying
+        def check(dependency: Dependency):
+            if self.available > 0:
+                dependency.check()
+
+        with self.dependents as dependents:
+            for _dependency in dependents:
+                _dependency.loop.call_soon_threadsafe(check, _dependency)
 
 
 class CounterTokenLock(Lock):
     def __init__(self, dependency: "CounterTokenDependency"):
         super().__init__()
         self.dependency = dependency
 
@@ -90,43 +105,54 @@
         self.path = path
         logging.debug("Writing token file %s", path)
         with path.open("wt") as fp:
             fp.write(f"{str(count)}\n{uri}\n")
         return self
 
     def delete(self):
-        logging.debug("Deleting token file %s", self.path)
-        self.path.unlink()
+        if self.path.is_file():
+            logging.debug("Deleting token file %s", self.path)
+            self.path.unlink()
 
     def watch(self):
         """Watch the matching process"""
         logger.debug(
             "Watching process for %s (%s, taken %d)", self.path, self.uri, self.count
         )
         path = Path(self.uri)
         lockpath = path.with_suffix(".lock")
         pidpath = path.with_suffix(".pid")
 
         # Watch for the job
         def run():
             logger.debug("Locking job lock path %s", lockpath)
+            process = None
             with fasteners.InterProcessLock(lockpath):
                 if not pidpath.is_file():
                     logger.debug("Job already finished (no PID file)")
                 else:
                     s = ""
                     while s == "":
                         s = pidpath.read_text()
 
-                    pid = int(s)
-                    logger.debug("Watching external job with PID %d", pid)
-                    p = psutil.Process(pid)
-                    p.wait()
+                    logger.info("Loading job watcher from definition")
+                    from experimaestro.connectors import Process
 
-                self.delete()
+                    # FIXME: not always localhost...
+                    from experimaestro.connectors.local import LocalConnector
+
+                    connector = LocalConnector.instance()
+                    process = Process.fromDefinition(connector, json.loads(s))
+
+            # Wait out of the lock
+            if process is not None:
+                # Process is None: process has finished
+                process.wait()
+
+            self.delete()
 
         threading.Thread(target=run).start()
 
 
 class CounterToken(Token, FileSystemEventHandler):
     """File-based counter token
 
@@ -151,31 +177,33 @@
         if created:
             logger.warning("Re-using token for path %s", path)
         else:
             created = CounterToken(name, path, count)
             CounterToken.TOKENS[name] = created
         return created
 
+    @staticmethod
+    def init_registry(registry: LauncherRegistry):
+        registry.register_token("countertoken", CounterTokenConfiguration)
+
     def __init__(self, name: str, path: Path, count: int, force=True):
         """[summary]
 
         Arguments:
             path {Path} -- The file path of the token file
             count {int} -- Number of tokens (overrides previous definitions)
             force --   If the token has already been created, force to write the maximum
                        number of tokens
         """
         super().__init__()
 
         self.path = path
         self.path.mkdir(exist_ok=True, parents=True)
 
-        self.cache: Dict[
-            str,
-        ] = {}
+        self.cache: Dict[str, TokenFile] = {}
 
         self.infopath = path / "token.info"
 
         self.ipc_lock = fasteners.InterProcessLock(path / "token.lock")
         self.lock = threading.Lock()
 
         self.name = name
@@ -227,33 +255,32 @@
     def on_deleted(self, event):
         logger.debug(
             "Deleted path notification %s [watched %s]",
             event.src_path,
             self.watchedpath,
         )
         name = Path(event.src_path).name
+        # Name is in cache if we did not release the token ourselves
         if name in self.cache:
             with self.lock:
                 if name in self.cache:
+                    logging.debug("Deleting %s from token cache (event)", name)
                     fc = self.cache[name]
                     del self.cache[name]
 
                     self.available += fc.count
                     logger.debug(
                         "Getting back %d tokens (%d available)",
                         fc.count,
                         self.available,
                     )
 
             # Do not lock here (notify only)
             if self.available > 0:
-                with self.dependents as dependents:
-                    for dependency in dependents:
-                        if self.available > 0:
-                            dependency.check()
+                self.aio_notify()
 
     def on_created(self, event):
         logger.debug(
             "Created path notification %s [watched %s]",
             event.src_path,
             self.watchedpath,
         )
@@ -356,23 +383,21 @@
                 logging.error(
                     "Could not find the taken token for %s (%s)",
                     dependency,
                     dependency.name,
                 )
                 return
 
+            logging.debug("Deleting %s from token cache", dependency.name)
             del self.cache[dependency.name]
             self.available += tf.count
             logging.debug("%s: available %d", self, self.available)
             tf.delete()
 
-        if self.available > 0:
-            with self.dependents as dependents:
-                for dependency in dependents:
-                    dependency.check()
+        self.aio_notify()
 
 
 class ProcessCounterToken(Token):
     """Process-level token"""
 
     def __init__(self, count: int):
         """Creates a new
@@ -412,16 +437,26 @@
             logging.debug(
                 "%s: releasing %d (available %d)",
                 self,
                 dependency.count,
                 self.available,
             )
 
-        if self.available > 0:
-            with self.dependents as dependents:
-                for dependency in dependents:
-                    if self.available > 0:
-                        dependency.check()
+        self.aio_notify()
 
 
 if sys.platform != "win32":
     os.register_at_fork(after_in_child=CounterToken.forkhandler)
+
+
+@dataclass
+class CounterConfiguration(TokenConfiguration):
+    tokens: int
+
+    def create(self, registry: "LauncherRegistry", identifier: str):
+        from experimaestro.connectors.local import LocalConnector
+
+        return LocalConnector.instance().createtoken(identifier, self.tokens)
+
+
+class CounterTokenConfiguration(YAMLDict[CounterConfiguration]):
+    pass
```

## Comparing `experimaestro/xpmutils.py` & `experimaestro-1.0.0/src/experimaestro/xpmutils.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 """Utilities exposed to users of the experimaestro API"""
 
 from pathlib import Path
-from experimaestro.core.objects import GenerationContext
+from experimaestro.core.objects import ConfigWalkContext
 
 
-class DirectoryContext(GenerationContext):
+class DirectoryContext(ConfigWalkContext):
     """Special generation context used for debugging and testing"""
 
     def __init__(self, path: Path):
         super().__init__()
         self._path = Path(path)
 
     @property
     def path(self):
         return self._path
 
 
-class EmptyContext(GenerationContext):
+class EmptyContext(ConfigWalkContext):
     """Special generation context used for debugging and testing"""
 
     @property
     def path(self):
-        raise AssertionError("Empty context has no path")
+        raise AssertionError("Empty experimaestro context does not define a path")
```

## Comparing `experimaestro/connectors/local.py` & `experimaestro-1.0.0/src/experimaestro/connectors/local.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,46 +1,91 @@
 """All classes related to localhost management
 """
 
 import subprocess
 from pathlib import Path, WindowsPath, PosixPath
 import os
 import threading
+from experimaestro.launcherfinder import LauncherRegistry
 import fasteners
 import psutil
 
 from experimaestro.locking import Lock
 
 from . import (
     Connector,
     Process,
     ProcessBuilder,
+    ProcessState,
     RedirectType,
     Redirect,
 )
 from experimaestro.tokens import Token, CounterToken
 from experimaestro.utils import logger
 
 
+class PsutilProcess(Process):
+    """Wrapper for psutil process"""
+
+    def __init__(self, pid: int):
+        self._process = psutil.Process(pid)
+
+    def wait(self) -> int:
+        logger.debug("Waiting (psutil) for process with PID %s", self._process.pid)
+        code = self._process.wait()
+        logger.debug(
+            "Finished to wait (psutil) for process with PID %s", self._process.pid
+        )
+        return code
+
+    async def aio_state(self):
+        if self._process.is_running():
+            return ProcessState.RUNNING
+        return ProcessState.FINISHED
+
+    def __repr__(self):
+        return f"PsUtil({self._process})"
+
+
 class LocalProcess(Process):
     def __init__(self, process: subprocess.Popen):
         self._process = process
 
     def __repr__(self):
         return f"Process({self._process.pid})"
 
     def wait(self) -> int:
+        logger.debug("Waiting (python) for process with PID %s", self._process.pid)
         code = self._process.wait()
+        logger.debug(
+            "Finished to wait (python) for process with PID %s", self._process.pid
+        )
         return code
 
+    async def aio_state(self):
+        code = self._process.poll()
+        if code is None:
+            return ProcessState.RUNNING
+
+        if code == 0:
+            return ProcessState.DONE
+
+        return ProcessState.ERROR
+
+    def tospec(self):
+        return {"type": "local", "pid": self._process.pid}
+
+    def kill(self):
+        self._process.kill()
+
     @staticmethod
-    def fromspec(spec):
+    def fromspec(connector, spec):
         pid = spec["pid"]
         try:
-            return psutil.Process(pid)
+            return PsutilProcess(pid)
         except psutil.NoSuchProcess:
             pass
 
         return None
 
 
 def getstream(redirect: Redirect, write: bool):
@@ -95,31 +140,38 @@
 
 class InterProcessLock(fasteners.InterProcessLock, Lock):
     def __init__(self, path, max_delay=-1):
         super().__init__(path)
         self.max_delay = max_delay
 
     def __enter__(self):
+        logger.debug("Locking %s", self.path)
         if not super().acquire(blocking=True, max_delay=self.max_delay, timeout=None):
             raise threading.ThreadError("Could not acquire lock")
+        logger.debug("Locked %s", self.path)
         return self
 
     def __exit__(self, *args):
+        logger.debug("Unlocking %s", self.path)
         super().__exit__(*args)
 
 
 class LocalConnector(Connector):
     INSTANCE: Connector = None
 
     @staticmethod
     def instance():
         if LocalConnector.INSTANCE is None:
             LocalConnector.INSTANCE = LocalConnector()
         return LocalConnector.INSTANCE
 
+    @staticmethod
+    def init_registry(registry: LauncherRegistry):
+        pass
+
     def __init__(self, localpath: Path = None):
         localpath = localpath
         if not localpath:
             localpath = Path(
                 os.environ.get("XPM_WORKDIR", "~/.local/share/experimaestro")
             ).expanduser()
         super().__init__(localpath)
```

## Comparing `experimaestro/connectors/ssh.py` & `experimaestro-1.0.0/src/experimaestro/connectors/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,155 +1,207 @@
-from pathlib import Path, PurePosixPath, PosixPath, _posix_flavour
-from typing import Union
-import io
-import os
-from fabric import Connection
-from urllib.parse import urlparse
-from itertools import chain
-from . import Connector
-from . import (
-    Connector,
-    Process,
-    ProcessBuilder,
-    RedirectType,
-    Redirect,
-    ProcessThreadError,
-)
+"""Connectors module
+
+This module contains :
+
+- connectors
+- process builders
+- launchers
+
+"""
+
+import enum
+from typing import Any, Dict, Mapping, Type, Union
+from pathlib import Path
+from experimaestro.utils import logger
 from experimaestro.locking import Lock
-from experimaestro.tokens import Token, CounterToken
+from experimaestro.tokens import Token
+from experimaestro.utils.asyncio import asyncThreadcheck
+import pkg_resources
+
+
+class RedirectType(enum.Enum):
+    INHERIT = 0
+    FILE = 1
+    PIPE = 2
+    NONE = 3
+
+
+class Redirect:
+    _NONE: "Redirect"
+    _INHERIT: "Redirect"
+
+    def __init__(self, type: RedirectType, path=None, function=None):
+        self.type = type
+        self.path = path
+        self.function = function
 
-class SshPath(Path, PurePosixPath):
-    """SSH path
+    @staticmethod
+    def file(path: Path):
+        return Redirect(RedirectType.FILE, path=path)
 
-    Absolute:
-    ssh://[user@]host[:port]//this/is/a/path
+    @staticmethod
+    def pipe(function):
+        return Redirect(RedirectType.PIPE, function=function)
+
+    @staticmethod
+    def none():
+        return Redirect._NONE
+
+    @staticmethod
+    def inherit():
+        return Redirect._INHERIT
+
+
+Redirect._NONE = Redirect(RedirectType.NONE)
+Redirect._INHERIT = Redirect(RedirectType.INHERIT)
+
+
+class ProcessState(enum.Enum):
+    SCHEDULED = 0
+    RUNNING = 1
+    FINISHED = 2
+    DONE = 3
+    ERROR = 4
 
-    Relative:
-    ssh://[user@]host[:port]/relative/path
-    """
     @property
-    def hostpath(self):
-        # path = "/" if self._parts[:0]  + "/".join(self._parts[1:])
-        if self.is_absolute():
-            return "/" + self._flavour.join(self._parts[1:])
-        return self._flavour.join(self._parts)
+    def running(self):
+        return self.value < ProcessState.FINISHED.value
 
     @property
-    def host(self):
-        return self._drv
+    def finished(self):
+        return self.value >= ProcessState.FINISHED.value
+
 
-    def is_absolute(self):
-        return self._parts and self._parts[0] == "/"
+class Process:
+    HANDLERS = None
 
     @classmethod
-    def _parse_args(cls, args):
-        drv = ""
-        if args[0].startswith("ssh:"):
-            url = urlparse(args[0])
-            assert not url.fragment and not url.query
-            
-            path = url.path
-
-            if path.startswith("//"):
-                # Absolute path
-                args = tuple(chain(["/", path[2:]], args[1:]))
-            else:
-                args = tuple(chain([path[1:]], args[1:]))
-
-            drv = url.hostname
-        _, root, parts = super()._parse_args(args)
-        return (drv, root, parts)
-        
-
-    def _make_child(self, args):
-        drv, root, parts = self._parse_args(args)
-        assert self._drv == drv or drv == "", f"{self._drv} and {drv}"
-        drv, root, parts = self._flavour.join_parsed_parts(
-            "", self._root, self._parts, "", root, parts)
-        return self._from_parsed_parts(self._drv, root, parts)
-
-    def open(self, mode="r", buffering=-1, encoding=None, errors=None, newline=None):
-        # FIXME: should probably be wiser
-        fileobj = SshConnector.get(self.host).connection.sftp().open(self.hostpath, mode, buffering)
-        if "b" in mode:
-            return fileobj
-
-        return io.TextIOWrapper(
-            fileobj, encoding=encoding, newline=newline, errors=errors
-        )
-
-    def absolute(self):
-        """Return an absolute version of this path.  This function works
-        even if the path doesn't point to anything.
+    def fromspec(cls, connector: "Connector", definition: Dict[str, Any]) -> "Process":
+        """Rebuild a process from a specification"""
+        raise NotImplementedError(f"fromspec for {cls}")
+
+    def tospec(self) -> Dict[str, Any]:
+        """Outputs a process specification"""
+        raise NotImplementedError(f"tospec for {self.__class__}")
 
-        No normalization is done, i.e. all '.' and '..' will be kept along.
-        Use resolve() to get the canonical path to a file.
-        """
-        # XXX untested yet!
-        if self._closed:
-            self._raise_closed()
-        if self.is_absolute():
-            return self
-        # FIXME this must defer to the specific flavour (and, under Windows,
-        # use nt._getfullpathname())
-        obj = self._from_parts([os.getcwd()] + self._parts, init=False)
-        obj._init(template=self)
-        return obj
+    @staticmethod
+    def fromDefinition(connector: "Connector", definition: Dict[str, Any]) -> "Process":
+        """Retrieves a process from a serialized definition"""
+        handler = Process.handler(definition["type"])
+        try:
+            return handler.fromspec(connector, definition)
+        except Exception as e:
+            import logging
 
-    def __repr__(self):
-        return "SshPath(%s,%s)" % (self._drv, self._flavour.join(self._parts[1:]))
+            logging.exception("Could not retrieve job from specification")
+            raise e
 
-    def __str__(self):
-        return "ssh://%s/%s" % (self._drv, self._flavour.join(self._parts[1:]))
+    @staticmethod
+    def handler(key: str) -> Type["Process"]:
+        """Get a handler"""
+        if Process.HANDLERS is None:
+            Process.HANDLERS = {}
+            for ep in pkg_resources.iter_entry_points(group="experimaestro.process"):
+                Process.HANDLERS[ep.name] = ep.load()
 
+        return Process.HANDLERS.get(key, None)
 
-class SshConnector(Connector):
-    def __init__(self, hostname: str):
-        self.connection = Connection(hostname)
-        # self.hostname = hostname
-        # self.port = None
+    def wait(self) -> int:
+        """Wait until the process finishes and returns the error code"""
+        raise NotImplementedError(f"Not implemented: {self.__class__}.wait")
 
-        # # FIXME: should connect on demand
-        # config = paramiko.SSHConfig()
-        # with Path("~/.ssh/config").expanduser().open("r") as fp:
-        #     config.parse(fp)
+    async def aio_state(self) -> ProcessState:
+        """Returns the job state"""
+        raise NotImplementedError(f"Not implemented: {self.__class__}.aio_state")
 
-        # lookup = config.lookup(hostname)
-        
-        # self.client = paramiko.SSHClient()
+    async def aio_isrunning(self):
+        """True is the process is truly running (I/O)"""
+        return (await self.aio_state()).running
 
-        # if "proxycommand" in lookup:
-        #     paramiko.proxy.ProxyCommand(lookup["proxycommand"])
+    async def aio_code(self):
+        """Returns a future containing the returned code"""
+        code = await asyncThreadcheck("aio_code", self.wait)
+        logger.debug("Got for return code %s: %s", self, code)
+        return code
 
-        # self.client.load_system_host_keys()
-        # self.client.connect(lookup["hostname"])
-        # self.sftp = self.client.open_sftp()
+    def kill(self):
+        raise NotImplementedError(f"Not implemented: {self.__class__}.kill")
 
-    @staticmethod
-    def fromPath(path: SshPath):
-        return SshConnector.get(path.host)
 
-    @staticmethod
-    def get(hostname):
-        # TODO: cache values?
-        return SshConnector(hostname)
+class ProcessThreadError(Exception):
+    """Exception thrown by the forked process, to exit properly"""
 
-    def __str__(self):
-        return "%s" % self.hostname
+    pass
+
+
+class ProcessBuilder:
+    """A process builder"""
+
+    def __init__(self):
+        self.workingDirectory = None  # type: Optional[Path]
+        self.stdin = Redirect.inherit()
+        self.stdout = Redirect.inherit()
+        self.stderr = Redirect.inherit()
+        self.detach = True
+        self.environ: Mapping[str, str] = {}
+        self.command = []
+
+    def start(self) -> Process:
+        """Start the process"""
+        raise NotImplementedError("Method not implemented in %s" % self.__class__)
+
+
+class Connector:
+    def __init__(self, localpath: Path):
+        """Creates a new connector
+
+        Arguments:
+            localpath {Path} -- The working directory
+        """
+        self._localpath = localpath
+
+    @property
+    def localpath(self):
+        if not self._localpath.is_dir():
+            self._localpath.mkdir(parents=True)
+        return self._localpath
+
+    @localpath.setter
+    def localpath(self, localpath: Path):
+        self._localpath = localpath
 
     def processbuilder(self) -> ProcessBuilder:
         raise NotImplementedError()
 
     def lock(self, path: Path, max_delay: int = -1) -> Lock:
         """Returns a lock on a file"""
-        print(path.hostpath())
         raise NotImplementedError()
 
     def resolve(self, path: Path, basepath: Path = None):
         raise NotImplementedError()
 
     def setExecutable(self, path: Path, flag: bool):
         raise NotImplementedError()
 
     def createtoken(self, name: str, total: int) -> Token:
         """Returns a token in the default path for the connector"""
-        raise NotImplementedError()
+        raise NotImplementedError()
+
+
+class Locator:
+    pass
+
+
+def parsepath(path: Union[str, Path]) -> Path:
+    """Parse a path
+
+    Returns a local path or a SshPath
+    """
+    if isinstance(path, Path):
+        return path
+
+    if isinstance(path, str) and path.startswith("ssh:"):
+        from .ssh import SshPath
+
+        return SshPath(path)
+
+    return Path(path)
```

## Comparing `experimaestro/core/arguments.py` & `experimaestro-1.0.0/src/experimaestro/core/arguments.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,53 +1,88 @@
 """Management of the arguments (params, options, etc) associated with the XPM objects"""
 
-from pathlib import Path
-from typing import Any, Optional, TypeVar, TYPE_CHECKING
+from typing import Optional, TypeVar, TYPE_CHECKING
 from experimaestro.typingutils import get_optional
+from pathlib import Path
 import sys
 
 if TYPE_CHECKING:
     from typing_extensions import Annotated
+    import experimaestro.core.types
 else:
     if sys.version_info.major == 3 and sys.version_info.minor < 9:
         from typing_extensions import Annotated
     else:
         from typing import Annotated
 
 
 class Argument:
+    """Represents an argument of a configuration or task"""
+
+    objecttype: Optional["experimaestro.core.types.ObjectType"]
+    """The object for which this argument was declared"""
+
     def __init__(
         self,
         name,
         type: "experimaestro.core.types.Type",
         required=None,
         help=None,
         generator=None,
         ignored=None,
         default=None,
         checker=None,
         constant=False,
-        subparam=False,
+        is_data=False,
     ):
+        """Creates a new argument
+
+        Args:
+            name (str): The name of the argument
+
+            type (experimaestro.core.types.Type): The type of the argument
+
+            required (bool, optional): True if required (if None, determines
+            automatically). Defaults to None.
+
+            help (str, optional): Help string. Defaults to None.
+
+            generator (Generator, optional): The value generator (e.g. for
+            paths). Defaults to None.
+
+            ignored (bool, optional): True if ignored (if None, computed
+            automatically). Defaults to None.
+
+            default (any, optional): . Defaults to None.
+
+            checker (any, optional): Value checker. Defaults to None.
+
+            constant (bool, optional): If true, the value is constant. Defaults
+            to False.
+
+            is_data (bool, optional): Flag for paths that are data path (to be
+            serialized). Defaults to False.
+        """
         required = (default is None) if required is None else required
         if default is not None and required is not None and required:
             raise Exception(
                 "argument '%s' is required but default value is given" % name
             )
 
         self.name = name
-        self.help = help
+        self._help = help
         self.checker = checker
         self.type = type
         self.constant = constant
         self.ignored = self.type.ignore if ignored is None else ignored
         self.required = required
         self.default = default
         self.generator = generator
-        self.subparam = subparam
+        self.objecttype = None
+        self.is_data = is_data
 
         assert (
             not self.constant or self.default is not None
         ), "Cannot be constant without default"
 
     def __repr__(self):
         return "Param[{name}:{type}]".format(**self.__dict__)
@@ -60,25 +95,34 @@
         return value
 
     def isoutput(self):
         if self.generator:
             return self.generator.isoutput()
         return False
 
+    @property
+    def help(self):
+        if self._help is None and self.objecttype is not None:
+            self.objecttype.__parsedoc__()
+        return self._help
+
+    @help.setter
+    def help(self, help: str):
+        self._help = help
+
 
 class ArgumentOptions:
     """Helper class when using type hints"""
 
     def __init__(self):
         self.kwargs = {}
         self.constant = False
 
     def create(self, name, originaltype, typehint):
         from experimaestro.core.types import Type
-        import experimaestro.core.objects as objects
 
         optionaltype = get_optional(typehint)
         type = Type.fromType(optionaltype or typehint)
 
         if "default" not in self.kwargs or self.kwargs["default"] is None:
             defaultvalue = getattr(originaltype, name, None)
             self.kwargs["default"] = defaultvalue
@@ -117,28 +161,30 @@
 paramHint = _Param()
 Param = Annotated[T, paramHint]
 
 optionHint = _Param(ignored=True)
 Option = Annotated[T, optionHint]
 Meta = Annotated[T, optionHint]
 
-subparamHint = _Param(subparam=True)
-SubParam = Annotated[T, subparamHint]
+dataHint = _Param(ignored=True, is_data=True)
+DataPath = Annotated[Path, dataHint]
+"""Annotates a path that should be kept to restore an object to its state"""
 
 
 class help(TypeAnnotation):
     def __init__(self, text: str):
         self.text = text
 
     def annotate(self, options: ArgumentOptions):
         options.kwargs["help"] = self.text
 
 
 class default(TypeAnnotation):
-    """Adds a default value (useful when we have problems with setattr and class properties)"""
+    """Adds a default value (useful when we have problems with setattr and class
+    properties)"""
 
     def __init__(self, value):
         self.value = value
 
     def annotate(self, options: ArgumentOptions):
         options.kwargs["default"] = self.value
```

## Comparing `experimaestro/core/objects.py` & `experimaestro-1.0.0/src/experimaestro/core/objects.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,40 +1,137 @@
 """Configuration and tasks"""
 
+from functools import cached_property
+import json
+
+try:
+    from types import NoneType
+except Exception:
+    # compatibility: python-3.8
+    NoneType = type(None)
+from termcolor import cprint
+import os
 from pathlib import Path
 import hashlib
 import struct
 import io
-from experimaestro.core.arguments import Param
 import fasteners
+from enum import Enum
 import inspect
 import importlib
 from typing import (
     Any,
     ClassVar,
     Dict,
+    Iterator,
     List,
     Optional,
     Set,
+    Tuple,
     Type,
     TypeVar,
     Union,
-    get_type_hints,
+    overload,
+    TYPE_CHECKING,
 )
-from experimaestro.utils import logger
 import sys
+import experimaestro
+from experimaestro.utils import logger
 from contextlib import contextmanager
-from experimaestro.core.types import ObjectType
+from experimaestro.core.types import DeprecatedAttribute, ObjectType
+from .context import SerializationContext, SerializedPath, SerializedPathLoader
+
+if TYPE_CHECKING:
+    from experimaestro.scheduler.base import Job
+    from experimaestro.scheduler.workspace import RunMode
+    from experimaestro.launchers import Launcher
+    from experimaestro.scheduler import Workspace
+
+T = TypeVar("T", bound="Config")
 
 
 class Identifier:
-    def __init__(self, all, main, sub):
-        self.all = all
+    def __init__(self, main: bytes):
         self.main = main
-        self.sub = sub
+        self.has_loops = False
+
+    @cached_property
+    def all(self):
+        """Returns the overall identifier"""
+        return self.main
+
+    def __hash__(self) -> int:
+        return hash(self.main)
+
+    def state_dict(self):
+        return self.main.hex()
+
+    def __eq__(self, other: "Identifier"):
+        return self.main == other.main
+
+    @staticmethod
+    def from_state_dict(data: Union[Dict[str, str], str]):
+        if isinstance(data, str):
+            return Identifier(bytes.fromhex(data))
+
+        return Identifier(bytes.fromhex(data["main"]))
+
+
+def is_ignored(value):
+    """Returns True if the value should be ignored by itself"""
+    return value is not None and isinstance(value, Config) and (value.__xpm__.meta)
+
+
+def remove_meta(value):
+    """Cleanup a dict/list by removing ignored values"""
+    if isinstance(value, list):
+        return [el for el in value if not is_ignored(el)]
+    if isinstance(value, dict):
+        return {key: value for key, value in value.items() if not is_ignored(value)}
+    return value
+
+
+class ConfigPath:
+    """Used to keep track of cycles when computing a hash"""
+
+    def __init__(self):
+        self.loops: List[bool] = []
+        """Indicates whether a loop was detected up to this node"""
+
+        self.config2index = {}
+        """Associate an index in the list with a configuration"""
+
+    def detect_loop(self, config) -> Optional[int]:
+        """If there is a loop, return the relative index and update the path"""
+        index = self.config2index.get(id(config), None)
+        if index is not None:
+            for i in range(index, self.depth):
+                self.loops[i] = True
+            return self.depth - index
+
+    def has_loop(self):
+        return self.loops[-1]
+
+    @property
+    def depth(self):
+        return len(self.loops)
+
+    @contextmanager
+    def push(self, config):
+        config_id = id(config)
+        assert config_id not in self.config2index
+
+        self.config2index[config_id] = self.depth
+        self.loops.append(False)
+
+        try:
+            yield
+        finally:
+            self.loops.pop()
+            del self.config2index[config_id]
 
 
 class HashComputer:
     """This class is in charge of computing a config/task identifier"""
 
     OBJECT_ID = b"\x00"
     INT_ID = b"\x01"
@@ -42,140 +139,220 @@
     STR_ID = b"\x03"
     PATH_ID = b"\x04"
     NAME_ID = b"\x05"
     NONE_ID = b"\x06"
     LIST_ID = b"\x07"
     TASK_ID = b"\x08"
     DICT_ID = b"\x09"
+    ENUM_ID = b"\x0a"
+    CYCLE_REFERENCE = b"\x0b"
 
-    def __init__(self):
+    def __init__(self, config: "Config", config_path: ConfigPath, *, version=None):
         # Hasher for parameters
         self._hasher = hashlib.sha256()
-        self._subhasher = None
-        self._tasks = set()
+        self.config = config
+        self.config_path = config_path
+        self.version = version or int(os.environ.get("XPM_HASH_COMPUTER", 2))
 
     def identifier(self) -> Identifier:
-        sub = None if self._subhasher is None else self._subhasher.digest()
         main = self._hasher.digest()
-        if sub:
-            h = hashlib.sha256()
-            h.update(main)
-            h.update(sub)
-            all = h.digest()
-        else:
-            all = main
-
-        return Identifier(all, main, sub)
+        return Identifier(main)
 
-    def _hashupdate(self, bytes, subparam):
-        if subparam:
-            # If subparam, creates a specific sub-hasher
-            if self._subhasher is None:
-                self._subhasher = hashlib.sha256()
-            self._subhasher.update(bytes)
-        else:
-            self._hasher.update(bytes)
-
-    def update(self, value, subparam=False):
+    def _hashupdate(self, bytes: bytes):
+        """Update the hash computers with some bytes"""
+        self._hasher.update(bytes)
+
+    def update(self, value, *, myself=False):
+        """Update the hash
+
+        :param value: The value to add to the hash
+        :param myself: True if the value is the configuration for which we wish
+            to compute the identifier, defaults to False
+        :raises NotImplementedError: If the value cannot be processed
+        """
         if value is None:
-            self._hashupdate(HashComputer.NONE_ID, subparam=subparam)
+            self._hashupdate(HashComputer.NONE_ID)
         elif isinstance(value, float):
-            self._hashupdate(HashComputer.FLOAT_ID, subparam=subparam)
-            self._hashupdate(struct.pack("!d", value), subparam=subparam)
+            self._hashupdate(HashComputer.FLOAT_ID)
+            self._hashupdate(struct.pack("!d", value))
         elif isinstance(value, int):
-            self._hashupdate(HashComputer.INT_ID, subparam=subparam)
-            self._hashupdate(struct.pack("!q", value), subparam=subparam)
+            self._hashupdate(HashComputer.INT_ID)
+            self._hashupdate(struct.pack("!q", value))
         elif isinstance(value, str):
-            self._hashupdate(HashComputer.STR_ID, subparam=subparam)
-            self._hashupdate(value.encode("utf-8"), subparam=subparam)
+            self._hashupdate(HashComputer.STR_ID)
+            self._hashupdate(value.encode("utf-8"))
         elif isinstance(value, list):
-            self._hashupdate(HashComputer.LIST_ID, subparam=subparam)
-            self._hashupdate(struct.pack("!d", len(value)), subparam=subparam)
-            for x in value:
-                self.update(x, subparam=subparam)
+            values = [el for el in value if not is_ignored(el)]
+            self._hashupdate(HashComputer.LIST_ID)
+            self._hashupdate(struct.pack("!d", len(values)))
+            for x in values:
+                self.update(x)
+        elif isinstance(value, Enum):
+            self._hashupdate(HashComputer.ENUM_ID)
+            k = value.__class__
+            self._hashupdate(
+                f"{k.__module__}.{k.__qualname__ }:{value.name}".encode("utf-8"),
+            )
         elif isinstance(value, dict):
-            self._hashupdate(HashComputer.DICT_ID, subparam=subparam)
-            items = list(value.items())
+            self._hashupdate(HashComputer.DICT_ID)
+            items = [
+                (key, value) for key, value in value.items() if not is_ignored(value)
+            ]
             items.sort(key=lambda x: x[0])
             for key, value in items:
-                self.update(key, subparam=subparam)
-                self.update(value, subparam=subparam)
-        elif isinstance(value, TaskOutput):
-            # Use the configuration of the task proxy
-            self.update(value.__xpm__.task, subparam=subparam)
+                self.update(key)
+                self.update(value)
+
+        # Handles configurations
         elif isinstance(value, Config):
+            # Encodes the identifier
+            self._hashupdate(HashComputer.OBJECT_ID)
+
+            # If we encode another config, then
+            if not myself:
+                if loop_ix := self.config_path.detect_loop(value):
+                    # Loop detected: use cycle reference
+                    self._hashupdate(HashComputer.CYCLE_REFERENCE)
+                    self._hashupdate(struct.pack("!q", loop_ix))
+
+                else:
+                    # Just use the object identifier
+                    value_id = HashComputer.compute(
+                        value, version=self.version, config_path=self.config_path
+                    )
+                    self._hashupdate(value_id.all)
+
+                # And that's it!
+                return
+
+            # Process tasks
+            if value.__xpm__.task is not None:
+                self._hashupdate(HashComputer.TASK_ID)
+                self.update(value.__xpm__.task)
+
             xpmtype = value.__xpmtype__
-            self._hashupdate(HashComputer.OBJECT_ID, subparam=subparam)
-            self._hashupdate(xpmtype.identifier.name.encode("utf-8"), subparam=subparam)
+            self._hashupdate(xpmtype.identifier.name.encode("utf-8"))
 
             # Process arguments (sort by name to ensure uniqueness)
             arguments = sorted(xpmtype.arguments.values(), key=lambda a: a.name)
             for argument in arguments:
-                arg_subparam = subparam or argument.subparam
-
                 # Ignored argument
-                if argument.ignored or argument.generator:
+                if argument.ignored:
+                    argvalue = value.__xpm__.values.get(argument.name, None)
+
+                    # ... unless meta is set to false
+                    if (
+                        argvalue is None
+                        or not isinstance(argvalue, Config)
+                        or (argvalue.__xpm__.meta is not False)
+                    ):
+                        continue
+
+                if argument.generator:
                     continue
 
                 # Argument value
+                # Skip if the argument is not a constant, and
+                # - optional argument: both value and default are None
+                # - the argument value is equal to the default value
                 argvalue = getattr(value, argument.name, None)
                 if not argument.constant and (
-                    argument.default and argument.default == argvalue
+                    (
+                        not argument.required
+                        and argument.default is None
+                        and argvalue is None
+                    )
+                    or (
+                        argument.default is not None
+                        and argument.default == remove_meta(argvalue)
+                    )
                 ):
                     # No update if same value (and not constant)
                     continue
 
+                if (
+                    argvalue is not None
+                    and isinstance(argvalue, Config)
+                    and argvalue.__xpm__.meta
+                ):
+                    continue
+
                 # Hash name
-                self.update(argument.name, subparam=arg_subparam)
+                self.update(argument.name)
 
                 # Hash value
-                self._hashupdate(HashComputer.NAME_ID, subparam=arg_subparam)
-                self.update(argvalue, subparam=arg_subparam)
+                self._hashupdate(HashComputer.NAME_ID)
+                self.update(argvalue)
 
         else:
             raise NotImplementedError("Cannot compute hash of type %s" % type(value))
 
+    @staticmethod
+    def compute(
+        config: "Config", config_path: ConfigPath = None, version=None
+    ) -> Identifier:
+        """Compute the identifier for a configuration
+
+        :param config: the configuration for which we compute the identifier
+        :param config_path: used to track down cycles between configurations
+        :param version: version for the hash computation (None for the last one)
+        """
+
+        # Try to use the cached value first
+        # (if there are no loops)
+        if config.__xpm__._sealed:
+            identifier = config.__xpm__._raw_identifier
+            if identifier is not None and not identifier.has_loops:
+                return identifier
+
+        config_path = config_path or ConfigPath()
+
+        with config_path.push(config):
+            self = HashComputer(config, config_path, version=version)
+            self.update(config, myself=True)
+            identifier = self.identifier()
+            identifier.has_loop = config_path.has_loop()
+
+        return identifier
+
 
 def updatedependencies(
     dependencies, value: "Config", path: List[str], taskids: Set[int]
 ):
     """Search recursively jobs to add them as dependencies
 
     Arguments:
         dependencies: The current set of dependencies
         value: The current inspected configuration
         path: The current path (for error tracing)
         taskids: Sets of added tasks (ids) to avoid repeated depencies
     """
 
-    def add(task):
-        if id(task) not in taskids:
-            taskids.add(id(task))
-            dependencies.add(task.__xpm__.dependency())
-
+    # Adds pre-tasks
     if isinstance(value, Config):
-        if value.__xpmtype__.task:
-            add(value)
-        else:
-            value.__xpm__.updatedependencies(dependencies, path, taskids)
+        value.__xpm__.updatedependencies(dependencies, path, taskids)
     elif isinstance(value, (list, set)):
         for el in value:
             updatedependencies(dependencies, el, path, taskids)
-    elif isinstance(value, TaskOutput):
-        dependencies.add(value.__xpm__.task.__xpm__.dependency())
     elif isinstance(value, (dict,)):
         for key, val in value.items():
             updatedependencies(dependencies, key, path, taskids)
             updatedependencies(dependencies, val, path, taskids)
-    elif isinstance(value, (str, int, float, Path)):
+    elif isinstance(value, (str, int, float, Path, Enum)):
         pass
     else:
         raise NotImplementedError("update dependencies for type %s" % type(value))
 
 
+class SealedError(Exception):
+    """Exception when trying to modify a sealed configuration"""
+
+    pass
+
+
 class TaggedValue:
     def __init__(self, value):
         self.value = value
 
 
 @contextmanager
 def add_to_path(p):
@@ -187,15 +364,15 @@
     sys.path.insert(0, p)
     try:
         yield
     finally:
         sys.path = old_path
 
 
-class GenerationContext:
+class ConfigWalkContext:
     """Context when generating values in configurations"""
 
     @property
     def path(self):
         """Returns the path of the job directory"""
         raise NotImplementedError()
 
@@ -219,64 +396,98 @@
         try:
             self._configpath = (Path("out") if p is None else p) / key
             yield key
         finally:
             self._configpath = p
 
 
-class ConfigProcessing:
+NOT_SET = object()
+
+
+class ConfigWalk:
     """Allows to perform an operation on all nested configurations"""
 
-    def __init__(self, recursetask=False):
+    def __init__(self, context: ConfigWalkContext = None, recurse_task=False):
         """
 
-        Parameters:
-            recursetask: Recurse into linked tasks
+        :param recurse_task: Recurse into linked tasks
+        :param context: The context, by default only tracks the position in the
+            config tree
         """
-        self.recursetask = recursetask
-        self.visited = set()
+        self.recurse_task = recurse_task
+        self.context = ConfigWalkContext() if context is None else context
 
-    def preprocess(self, config: "Config"):
+        # Stores already visited nodes
+        self.visited = {}
+
+    def preprocess(self, config: "Config") -> Tuple[bool, Any]:
+        """Returns a tuple boolean/value
+
+        The boolean value is used to stop the processing if False.
+        The value is returned
+        """
         return True, None
 
-    def postprocess(self, config: "Config", values: Dict[str, Any]):
-        return config
+    def postprocess(self, stub, config: "Config", values: Dict[str, Any]):
+        return stub
 
-    @contextmanager
     def list(self, i: int):
-        yield i
+        return self.context.push(str(i))
 
-    @contextmanager
     def map(self, k: str):
-        yield k
+        return self.context.push(k)
+
+    def stub(self, config: "Config"):
+        return config
 
     def __call__(self, x):
         if isinstance(x, Config):
             info = x.__xpm__  # type: ConfigInformation
 
             # Avoid loops
             xid = id(x)
             if xid in self.visited:
-                return
-            self.visited.add(xid)
+                return self.visited[xid]
+
+            # Get a stub
+            stub = self.stub(x)
+            self.visited[xid] = stub
 
             # Pre-process
             flag, value = self.preprocess(x)
 
             if not flag:
                 # Stop processing and returns value
                 return value
 
+            # Process all the arguments
             result = {}
             for arg, v in info.xpmvalues():
                 if v is not None:
                     with self.map(arg.name):
                         result[arg.name] = self(v)
+                else:
+                    result[arg.name] = None
+
+            # Deals with pre-tasks
+            if info.pre_tasks:
+                with self.map("__pre_tasks__"):
+                    self(info.pre_tasks)
+
+            # Process task if different
+            if (
+                x.__xpm__.task is not None
+                and self.recurse_task
+                and x.__xpm__.task is not x
+            ):
+                self(x.__xpm__.task)
 
-            return self.postprocess(x, result)
+            processed = self.postprocess(stub, x, result)
+            self.visited[xid] = processed
+            return processed
 
         if isinstance(x, list):
             result = []
             for i, sv in enumerate(x):
                 with self.list(i):
                     result.append(self(sv))
             return result
@@ -285,67 +496,100 @@
             result = {}
             for key, value in x.items():
                 assert isinstance(key, (str, float, int))
                 with self.map(key):
                     result[key] = self(value)
             return result
 
-        if isinstance(x, TaskOutput):
-            if self.recursetask:
-                self(x.__xpm__.task)
-
-            return x
-
-        if isinstance(x, (float, int, str, Path)):
+        if isinstance(x, (float, int, str, Path, Enum)):
             return x
 
         raise NotImplementedError(f"Cannot handle a value of type {type(x)}")
 
 
-class GenerationConfigProcessing(ConfigProcessing):
-    def __init__(self, context: GenerationContext):
-        super().__init__()
-        self.context = context
+def getqualattr(module, qualname):
+    """Get a qualified attributed value"""
+    cls = module
+    for part in qualname.split("."):
+        cls = getattr(cls, part)
+    return cls
 
-    def list(self, i: int):
-        return self.context.push(str(i))
 
-    def map(self, k: str):
-        return self.context.push(k)
+class ObjectStore:
+    def __init__(self):
+        self.store: Dict[int, Any] = {}
+        self.constructed: Set[int] = set()
+
+    def set_constructed(self, identifier: int):
+        self.constructed.add(identifier)
+
+    def is_constructed(self, identifier: int):
+        return identifier in self.constructed
+
+    def retrieve(self, identifier: int):
+        return self.store.get(identifier, None)
+
+    def add_stub(self, identifier: int, stub: Any):
+        self.store[identifier] = stub
 
 
 class ConfigInformation:
     """Holds experimaestro information for a config (or task) instance"""
 
+    _meta: Optional[bool]
+    """Forces this configuration to be a meta-parameter"""
+
     # Set to true when loading from JSON
-    LOADING = False
+    LOADING: ClassVar[bool] = False
 
-    def __init__(self, pyobject: "Config"):
+    def __init__(self, pyobject: "TypeConfig"):
         # The underlying pyobject and XPM type
         self.pyobject = pyobject
         self.xpmtype = pyobject.__xpmtype__  # type: ObjectType
         self.values = {}
 
         # Meta-informations
         self._tags = {}
-        self._initinfo = {}
+        self._initinfo = ""
 
-        # Generated task
         self._taskoutput = None
+        """Task output (caches the value of a submit)"""
+
+        self.task: Optional["Config"] = None
+        """The task this configuration depends upon (or None)"""
 
         # State information
         self.job = None
 
         # Explicitely added dependencies
         self.dependencies = []
 
+        # Lightweight tasks
+        self.pre_tasks: List["LightweightTask"] = []
+
         # Cached information
-        self._identifier = None
+
+        self._full_identifier = None
+        """The full identifier (with pre-tasks)"""
+
+        self._raw_identifier = None
+        """The identifier without taking into account pre-tasks"""
+
         self._validated = False
         self._sealed = False
+        self._meta = None
+
+    def set_meta(self, value: Optional[bool]):
+        """Sets the meta flag"""
+        assert not self._sealed, "Configuration is sealed"
+        self._meta = value
+
+    @property
+    def meta(self):
+        return self._meta
 
     def get(self, name):
         """Get an XPM managed value"""
         if name in self.xpmtype.arguments:
             return self.values[name]
 
         # Not an argument, bypass
@@ -353,16 +597,16 @@
 
     def set(self, k, v, bypass=False):
         # Not an argument, bypass
         if k not in self.xpmtype.arguments:
             setattr(self.pyobject, k, v)
             return
 
-        if self._sealed:
-            raise AttributeError("Object is read-only")
+        if self._sealed and not bypass:
+            raise AttributeError(f"Object is read-only (trying to set {k})")
 
         try:
             argument = self.xpmtype.arguments.get(k, None)
             if argument:
                 if not bypass and (argument.generator or argument.constant):
                     raise AttributeError("Property %s is read-only" % (k))
                 if v is not None:
@@ -385,288 +629,477 @@
     def xpmvalues(self, generated=False):
         """Returns an iterarator over arguments and associated values"""
         for argument in self.xpmtype.arguments.values():
             if argument.name in self.values or (generated and argument.generator):
                 yield argument, self.values[argument.name]
 
     def tags(self):
-        class TagFinder(ConfigProcessing):
+        class TagFinder(ConfigWalk):
             def __init__(self):
-                super().__init__(recursetask=True)
+                super().__init__(recurse_task=True)
                 self.tags = {}
 
-            def postprocess(self, config: Config, values):
+            def postprocess(self, stub, config: Config, values):
                 self.tags.update(config.__xpm__._tags)
                 return self.tags
 
         return TagFinder()(self.pyobject)
 
     def validate(self):
         """Validate a value"""
         if not self._validated:
             self._validated = True
 
             # Check each argument
             for k, argument in self.xpmtype.arguments.items():
                 value = self.values.get(k)
                 if value is not None:
-                    if value is None and argument.required:
-                        raise ValueError(
-                            "Value %s is required but missing when building %s at %s"
-                            % (k, self.xpmtype, self._initinfo)
-                        )
                     if isinstance(value, Config):
                         value.__xpm__.validate()
                 elif argument.required:
                     if not argument.generator:
                         raise ValueError(
                             "Value %s is required but missing when building %s at %s"
                             % (k, self.xpmtype, self._initinfo)
                         )
 
+            # Validate pre-tasks
+            for pre_task in self.pre_tasks:
+                pre_task.__xpm__.validate()
+
             # Use __validate__ method
             if hasattr(self.pyobject, "__validate__"):
-                self.pyobject.__validate__()
+                try:
+                    self.pyobject.__validate__()
+                except Exception:
+                    logger.error(
+                        "Error while validating %s at %s", self.xpmtype, self._initinfo
+                    )
+                    raise
 
-    def seal(self, context: GenerationContext):
-        """Seal the object, generating values when needed,
-        before scheduling the associated job(s)
+    def seal(self, context: ConfigWalkContext):
+        """Seals the object and generate values when needed
 
         Arguments:
             - context: the generation context
         """
 
-        class Sealer(GenerationConfigProcessing):
+        class Sealer(ConfigWalk):
             def preprocess(self, config: Config):
                 return not config.__xpm__._sealed, config
 
-            def postprocess(self, config: Config, values):
+            def postprocess(self, stub, config: Config, values):
                 # Generate values
                 for k, argument in config.__xpmtype__.arguments.items():
                     if argument.generator:
                         config.__xpm__.set(
                             k, argument.generator(self.context, config), bypass=True
                         )
 
                 config.__xpm__._sealed = True
 
-        Sealer(context)(self.pyobject)
+        Sealer(context, recurse_task=True)(self.pyobject)
 
-    @property
-    def identifier(self) -> Identifier:
+    def __unseal__(self):
+        """Unseal this configuration and its descendant
+
+        Internal API - do not use
+        """
+        context = ConfigWalkContext()
+
+        class Unsealer(ConfigWalk):
+            def preprocess(self, config: Config):
+                return config.__xpm__._sealed, config
+
+            def postprocess(self, stub, config: Config, values):
+                config.__xpm__._sealed = False
+                config.__xpm__._identifier = None
+
+        Unsealer(context, recurse_task=True)(self.pyobject)
+
+    def collect_pre_tasks(self) -> Iterator["Config"]:
+        context = ConfigWalkContext()
+        pre_tasks: Dict[int, "Config"] = {}
+
+        class PreTaskCollect(ConfigWalk):
+            def preprocess(self, config: Config):
+                # Do not cross tasks
+                return not isinstance(config.__xpm__, Task), config
+
+            def postprocess(self, stub, config: Config, values):
+                pre_tasks.update(
+                    {id(pre_task): pre_task for pre_task in config.__xpm__.pre_tasks}
+                )
+
+        PreTaskCollect(context, recurse_task=True)(self.pyobject)
+        return pre_tasks.values()
+
+    def identifiers(self, only_raw: bool):
         """Computes the unique identifier"""
-        if self._identifier is None:
-            hashcomputer = HashComputer()
-            hashcomputer.update(self.pyobject)
-            self._identifier = hashcomputer.identifier()
-        return self._identifier
+
+        raw_identifier = self._raw_identifier
+        full_identifier = self._full_identifier
+
+        # Computes raw identifier if needed
+        if raw_identifier is None or not self._sealed:
+            # Get the main identifier
+            raw_identifier = HashComputer.compute(self.pyobject)
+            if self._sealed:
+                self._raw_identifier = raw_identifier
+
+        if only_raw:
+            return raw_identifier, full_identifier
+
+        # OK, let's compute the full identifier
+        if full_identifier is None or not self._sealed:
+            # Compute the full identifier by including the pre-tasks
+            hasher = hashlib.sha256()
+            hasher.update(raw_identifier.all)
+            pre_tasks_ids = [
+                pre_task.__xpm__.raw_identifier.all
+                for pre_task in self.collect_pre_tasks()
+            ]
+            for task_id in sorted(pre_tasks_ids):
+                hasher.update(task_id)
+
+            full_identifier = Identifier(hasher.digest())
+            full_identifier.has_loops = raw_identifier.has_loops
+
+            # Only cache the identifier if sealed
+            if self._sealed:
+                self._full_identifier = full_identifier
+
+        return raw_identifier, full_identifier
+
+    @property
+    def raw_identifier(self) -> Identifier:
+        """Computes the unique identifier (without task modifiers)"""
+        raw_identifier, _ = self.identifiers(True)
+        return raw_identifier
+
+    @property
+    def full_identifier(self) -> Identifier:
+        """Computes the unique identifier (with task modifiers)"""
+        _, full_identifier = self.identifiers(False)
+        return full_identifier
+
+    identifier = full_identifier
+    """Deprecated: use full_identifier"""
 
     def dependency(self):
         """Returns a dependency"""
         from experimaestro.scheduler import JobDependency
 
         assert self.job, f"{self.xpmtype} is a task but was not submitted"
         return JobDependency(self.job)
 
     def updatedependencies(
         self,
         dependencies: Set["experimaestro.dependencies.Dependency"],
         path: List[str],
         taskids: Set[int],
     ):
-        for argument, value in self.xpmvalues():
-            try:
-                if value is not None:
-                    updatedependencies(
-                        dependencies, value, path + [argument.name], taskids
-                    )
-            except Exception:
-                logger.error("While setting %s", path + [argument.name])
-                raise
+        # Add pre-tasks
+        for pre_task in self.pre_tasks:
+            pre_task.__xpm__.updatedependencies(
+                dependencies, path + ["__pre_tasks___"], taskids
+            )
+
+        # Check for an associated task
+        if self.task:
+            if id(self.task) not in taskids:
+                taskids.add(id(self.task))
+                dependencies.add(self.task.__xpm__.dependency())
+        else:
+            # Look arguments
+            for argument, value in self.xpmvalues():
+                try:
+                    if value is not None:
+                        updatedependencies(
+                            dependencies, value, path + [argument.name], taskids
+                        )
+                except Exception:
+                    logger.error("While setting %s", path + [argument.name])
+                    raise
+
+    def apply_submit_hooks(self, job: "Job", launcher: "Launcher"):
+        """Apply configuration hooks"""
+        context = ConfigWalkContext()
+
+        class HookGatherer(ConfigWalk):
+            def __init__(self, *args, **kwargs):
+                super().__init__(*args, **kwargs)
+                self.hooks = set()
+
+            def postprocess(self, stub, config: "Config", values: Dict[str, Any]):
+                self.hooks.update(config.__xpmtype__.submit_hooks)
+
+        gatherer = HookGatherer(context, recurse_task=False)
+        gatherer(self.pyobject)
+
+        # Apply hooks
+        for hook in gatherer.hooks:
+            hook.process(job, launcher)
+
+    def validate_and_seal(self, context: ConfigWalkContext):
+        try:
+            self.validate()
+        except Exception as e:
+            logger.error(
+                "Error while validating object of type %s, defined %s",
+                self.xpmtype,
+                self._initinfo,
+            )
+            raise e
+
+        # Now, seal the object
+        self.seal(context)
+
+    def submit(self, workspace: "Workspace", launcher: "Launcher", *, run_mode=None):
+        from experimaestro.scheduler import experiment, JobContext
+        from experimaestro.scheduler.workspace import RunMode
 
-    def submit(self, workspace, launcher, dryrun=False):
         # --- Prepare the object
+
         if self.job:
             raise Exception("task %s was already submitted" % self)
         if not self.xpmtype.task:
             raise ValueError("%s is not a task" % self.xpmtype)
 
         # --- Submit the job
-        from experimaestro.scheduler import Job, experiment, JobContext
 
+        # Creates a new job
         self.job = self.xpmtype.task(
-            self.pyobject, launcher=launcher, workspace=workspace, dryrun=dryrun
+            self.pyobject, launcher=launcher, workspace=workspace, run_mode=run_mode
         )
 
         # Validate the object
-        try:
-            self.validate()
-        except Exception as e:
-            logger.error(
-                "Error while validating object of type %s, defined %s",
-                self.xpmtype,
-                self._initinfo,
-            )
-            raise e
+        job_context = JobContext(self.job)
+        self.validate_and_seal(job_context)
 
-        # Now, seal the object
-        self.seal(JobContext(self.job))
+        # --- Workspace
+
+        workspace = workspace or (
+            experiment.CURRENT.workspace if experiment.CURRENT else None
+        )
+
+        # --- Launcher
 
-        # --- Search for dependencies
+        launcher = (
+            launcher
+            or (workspace and workspace.launcher)
+            or (experiment.CURRENT and experiment.CURRENT.workspace.launcher)
+        )
+
+        if launcher:
+            launcher.onSubmit(self.job)
+
+        # Apply submit hooks
+        self.apply_submit_hooks(self.job, launcher)
+
+        # Add job dependencies
         self.updatedependencies(self.job.dependencies, [], set([id(self.pyobject)]))
 
         # Add predefined dependencies
         self.job.dependencies.update(self.dependencies)
 
-        if not dryrun:
+        run_mode = (
+            workspace.run_mode if run_mode is None else run_mode
+        ) or RunMode.NORMAL
+        if run_mode == RunMode.NORMAL:
             other = experiment.CURRENT.submit(self.job)
             if other:
                 # Just returns the other task
                 return other.config.__xpm__._taskoutput
         else:
-            logger.warning("Simulating: not submitting job %s", self.job)
+            # Show a warning
+            if run_mode == RunMode.GENERATE_ONLY:
+                experiment.CURRENT.prepare(self.job)
+
+            # Check if job is done
+            tags = ", ".join(f"{k}={v}" for k, v in self.job.tags.items())
+            s = f"""Simulating {self.job.relpath} {f"({tags})" if tags else ""}"""
+
+            color = "white"
+            if self.job.workspace is not None:
+                if self.job.donepath.is_file():
+                    color = "light_green"
+                    cprint(f"[done] {s}", color, file=sys.stderr)
+                elif self.job.failedpath.is_file():
+                    color = "light_red"
+                    cprint(f"[failed] {s}", color, file=sys.stderr)
+                else:
+                    color = "light_blue"
+                    cprint(f"[not run] {s}", color, file=sys.stderr)
+
+                if launcher:
+                    cprint(f"   [Launcher] {launcher}", color, file=sys.stderr)
+
+                if not self.job.dependencies:
+                    cprint("   [No dependencies]", color, file=sys.stderr)
+
+                for dep in self.job.dependencies:
+                    cprint(f"   [Depency] {dep}", color, file=sys.stderr)
+
+                print(file=sys.stderr)  # noqa: T201
 
         # Handle an output configuration
-        if hasattr(self.pyobject, "config"):
-            config = self.pyobject.config()
-            if isinstance(config, dict):
-                # Converts to the specified configuration
-                hints = get_type_hints(self.pyobject.config)
-                config = hints["return"](**config)
-            self._taskoutput = TaskOutput(config, self.pyobject)
-
-        # New way to handle outputs
-        elif hasattr(self.pyobject, "taskoutputs"):
-            value = self.pyobject.taskoutputs()
-            self._taskoutput = TaskOutput(value, self.pyobject)
+        def mark_output(config: "Config"):
+            """Sets a dependency on the job"""
+            assert not isinstance(config, Task), "Cannot set a dependency on a task"
+            config.__xpm__.task = self.pyobject
+            return config
 
-        # Otherwise, the output is just the config
+        # Mark this configuration also
+        self.task = self.pyobject
+
+        if hasattr(self.pyobject, "task_outputs"):
+            self._taskoutput = self.pyobject.task_outputs(mark_output)
         else:
-            self._taskoutput = TaskOutput(self.pyobject, self.pyobject)
+            self._taskoutput = self.task = self.pyobject
 
         return self._taskoutput
 
     # --- Serialization
 
     @staticmethod
-    def _outputjsonvalue(key, value, jsonout, context):
+    def _outputjsonvalue(value, context):
         """Serialize a value"""
         if value is None:
-            jsonout.write(*key, None)
-        elif isinstance(value, Config):
-            with jsonout.subobject(*key) as obj:
-                obj.write("type", "python")
-                obj.write("value", id(value))
+            return None
+
         elif isinstance(value, list):
-            with jsonout.subarray(*key) as arrayout:
-                for el in value:
-                    ConfigInformation._outputjsonvalue([], el, arrayout, context)
+            return [ConfigInformation._outputjsonvalue(el, context) for el in value]
+
         elif isinstance(value, dict):
-            with jsonout.subobject(*key) as objectout:
-                for name, el in value.items():
-                    ConfigInformation._outputjsonvalue([name], el, objectout, context)
+            return {
+                name: ConfigInformation._outputjsonvalue(el, context)
+                for name, el in value.items()
+            }
+
         elif isinstance(value, Path):
-            with jsonout.subobject(*key) as objectout:
-                objectout.write("type", "path")
-                objectout.write("value", str(value))
+            return {"type": "path", "value": str(value)}
+
+        elif isinstance(value, SerializedPath):
+            return {
+                "type": "path.serialized",
+                "value": str(value.path),
+                "is_folder": value.is_folder,
+            }
+
         elif isinstance(value, (int, float, str)):
-            jsonout.write(*key, value)
-        elif isinstance(value, SerializedTaskOutput):
-            # Reference to a serialized object
-            with jsonout.subobject(*key) as objectout:
-                objectout.write("type", "serialized")
-                objectout.write("value", id(value.__xpm__.serialized.loader))
-                with objectout.subarray("path") as out:
-                    for c in value.__xpm__.path:
-                        out.write(c.toJSON())
-        elif isinstance(value, TaskOutput):
-            ConfigInformation._outputjsonvalue(
-                key, value.__unwrap__(), jsonout, context
-            )
-        else:
-            raise NotImplementedError(
-                "Cannot serialize objects of type %s", type(value)
-            )
+            return value
+
+        elif isinstance(value, Enum):
+            return {
+                "type": "enum",
+                "module": value.__class__.__module__,
+                "enum": value.__class__.__qualname__,
+                "value": value.name,
+            }
+
+        elif isinstance(value, Config):
+            return {
+                "type": "python",
+                "value": id(value),
+            }
+
+        raise NotImplementedError("Cannot serialize objects of type %s", type(value))
+
+    def __get_objects__(
+        self,
+        objects: List[Dict],
+        context: SerializationContext,
+    ) -> List[Dict]:
+        """Returns the list of objects necessary to deserialize ourself
+
+        :param objects: the already output objects
+        :param context: The serialization context (e.g. useful to create files)
+        """
 
-    def _outputjson_inner(self, jsonstream, context, serialized: Set[int]):
-        """Serialize the configuration"""
         # Skip if already serialized
-        if id(self.pyobject) in serialized:
-            return
+        if id(self.pyobject) in context.serialized:
+            return objects
 
-        serialized.add(id(self.pyobject))
+        context.serialized.add(id(self.pyobject))
 
         # Serialize sub-objects
         for argument, value in self.xpmvalues():
             if value is not None:
-                ConfigInformation._outputjsonobjects(
-                    value, jsonstream, context, serialized
-                )
+                ConfigInformation.__collect_objects__(value, objects, context)
 
-        with jsonstream.subobject() as objectout:
-            # Serialize ourselves
-            objectout.write("id", id(self.pyobject))
-            if not self.xpmtype._package:
-                objectout.write("file", str(self.xpmtype._file))
-
-            objectout.write("module", self.xpmtype._module)
-            objectout.write("type", self.xpmtype.objecttype.__qualname__)
-
-            # Serialize identifier and typename
-            # TODO: remove when not needed (cache issues)
-            objectout.write("typename", self.xpmtype.name())
-            objectout.write("identifier", self.identifier.all.hex())
-
-            with objectout.subobject("fields") as jsonfields:
-                for argument, value in self.xpmvalues():
-                    ConfigInformation._outputjsonvalue(
-                        [argument.name], value, jsonfields, value
-                    )
+        # Serialize pre-tasks
+        ConfigInformation.__collect_objects__(self.pre_tasks, objects, context)
 
-    @staticmethod
-    def _outputjsonobjects(value, jsonout, context, serialized):
-        """Serialize all configuration objects present within the value"""
-        # objects
-        if isinstance(value, SerializedTaskOutput):
-            with jsonout.subobject() as objectout:
-                serialized = value.__xpm__.serialized
-                loader = serialized.loader
-                objectout.write("id", id(loader))
-                objectout.write("serialized", True)
-                objectout.write("module", loader.__class__.__module__)
-                objectout.write("type", loader.__class__.__qualname__)
-                objectout.write("value", serialized.loader.toJSON())
-            return
+        # Serialize ourselves
+        state_dict = {
+            "id": id(self.pyobject),
+            "module": self.xpmtype._module,
+            "type": self.xpmtype.objecttype.__qualname__,
+            "typename": self.xpmtype.name(),
+            "identifier": self.identifier.state_dict(),
+        }
+
+        if self.pre_tasks:
+            state_dict["pre-tasks"] = [id(pre_task) for pre_task in self.pre_tasks]
+
+        if self.meta:
+            state_dict["meta"] = self.meta
+
+        if not self.xpmtype._package:
+            state_dict["file"] = str(self.xpmtype._file)
+
+        # Serialize identifier and typename
+        jsonfields = state_dict["fields"] = {}
+        for argument, value in self.xpmvalues():
+            with context.push(argument.name) as var_path:
+                if argument.is_data and value is not None:
+                    assert isinstance(
+                        value, Path
+                    ), f"Data arguments should be paths (type is {type(value)})"
+                    value = context.serialize(var_path, value)
+
+                jsonfields[argument.name] = ConfigInformation._outputjsonvalue(
+                    value, context
+                )
 
-        # Unwrap if needed
-        if isinstance(value, TaskOutput):
-            value = value.__unwrap__()
+        objects.append(state_dict)
+        return objects
 
+    @staticmethod
+    def __collect_objects__(value, objects: List[Dict], context: SerializationContext):
+        """Serialize all needed configuration objects, looking at sub
+        configurations if necessary"""
         if isinstance(value, Config):
-            value.__xpm__._outputjson_inner(jsonout, context, serialized)
+            if value.__xpm__.task is not None and value.__xpm__.task is not value:
+                ConfigInformation.__collect_objects__(
+                    value.__xpm__.task, objects, context
+                )
+            value.__xpm__.__get_objects__(objects, context)
         elif isinstance(value, list):
             for el in value:
-                ConfigInformation._outputjsonobjects(el, jsonout, context, serialized)
+                ConfigInformation.__collect_objects__(el, objects, context)
         elif isinstance(value, dict):
-            for name, el in value.items():
-                ConfigInformation._outputjsonobjects(el, jsonout, context, serialized)
-        elif isinstance(value, (Path, int, float, str)):
+            for el in value.values():
+                ConfigInformation.__collect_objects__(el, objects, context)
+        elif isinstance(value, (Path, int, float, str, Enum)):
             pass
         else:
             raise NotImplementedError(
                 "Cannot serialize objects of type %s", type(value)
             )
 
-    def outputjson(self, out: io.TextIOBase, context: "CommandContext"):
+    def outputjson(self, out: io.TextIOBase, context: SerializationContext):
         """Outputs the json of this object
 
         The format is an array of objects
         {
             "tags: [ LIST_OF_TAGS ],
             "workspace": FOLDERPATH,
+            "version": 2,
             "objects": [
                 {
                     "id": <ID of the object>,
                     "filename": <filename>, // if in a file
                     "module": <module>, // if in a module
                     "type": <type>, // the type within the module or file
                     "fields":
@@ -680,183 +1113,326 @@
 
         The last object is the one that is serialized
 
         Arguments:
             out {io.TextIOBase} -- The output stream
             context {[type]} -- the command context
         """
-        import jsonstreams
+        json.dump(
+            {
+                "workspace": str(context.workspace.path.absolute()),
+                "tags": {key: value for key, value in self.tags().items()},
+                "version": 2,
+                "objects": self.__get_objects__([], context),
+            },
+            out,
+        )
+
+    def __json__(self) -> str:
+        """Returns the JSON representation of the object itself"""
+        return json.dumps(self.__get_objects__([], SerializationContext()))
+
+    def serialize(self, save_directory: Path):
+        """Serialize the configuration and its data files into a directory"""
+        context = SerializationContext(save_directory=save_directory)
+
+        with (save_directory / "definition.json").open("wt") as out:
+            objects = self.__get_objects__([], context)
+            json.dump(objects, out)
+
+    @staticmethod
+    def deserialize(
+        path: Union[str, Path, SerializedPathLoader], as_instance: bool = False
+    ) -> "Config":
+        """Deserialize a configuration
+
+        :param path: The filesystem Path to use, or a way to download the
+            information through a function taking two arguments
+        :return: A Config object
+        """
+        # Load
+        if callable(path):
+            data_loader = path
+        else:
+            path = Path(path)
 
-        serialized: Set[int] = set()
-        with jsonstreams.Stream(jsonstreams.Type.object, fd=out, close_fd=True) as out:
-            # Write information
-            out.write("has_subparam", self.identifier.sub is not None)
-
-            out.write("workspace", str(context.workspace.path.absolute()))
-
-            with out.subobject("tags") as objectout:
-                for key, value in self.tags().items():
-                    objectout.write(key, value)
-
-            # Write objects
-            with out.subarray("objects") as arrayout:
-                self._outputjson_inner(arrayout, context, serialized)
-
-    # def _outputjson(self, jsonout, context, key=[]):
-    #     with jsonout.subobject(*key) as objectout:
-    #         self._outputjson_inner(objectout, context)
+            def data_loader(s: Union[Path, str, SerializedPath]):
+                if isinstance(s, SerializedPath):
+                    return path / Path(s.path)
+                return path / Path(s)
+
+        with data_loader("definition.json").open("rt") as fh:
+            config = json.load(fh)
+
+        return ConfigInformation.fromParameters(
+            config, as_instance=as_instance, data_loader=data_loader
+        )
 
     @staticmethod
-    def _objectFromParameters(value, objects):
+    def _objectFromParameters(value: Any, objects: Dict[str, Any], as_instance: bool):
+        # A list
         if isinstance(value, list):
-            return [ConfigInformation._objectFromParameters(x, objects) for x in value]
+            return [
+                ConfigInformation._objectFromParameters(x, objects, as_instance)
+                for x in value
+            ]
+
+        # A dictionary
         if isinstance(value, dict):
             if "type" not in value:
                 # Just a plain dictionary
                 return {
                     ConfigInformation._objectFromParameters(
-                        key, objects
-                    ): ConfigInformation._objectFromParameters(value, objects)
+                        key, objects, as_instance
+                    ): ConfigInformation._objectFromParameters(
+                        value, objects, as_instance
+                    )
                     for key, value in value.items()
                 }
 
+            # The value is an object (that should have been serialized first)
             if value["type"] == "python":
-                return objects[value["value"]]
+                obj = objects[value["value"]]
 
-            if value["type"] == "serialized":
-                o = objects[value["value"]]
-                for c in value["path"]:
-                    if c["type"] == "item":
-                        o = o[c["name"]]
-                    elif c["type"] == "attr":
-                        o = getattr(o, c["name"])
-                    else:
-                        raise TypeError(f"Cannot handle type {c['type']}")
-                return o
+                # If we have a task
+                if not as_instance:
+                    if task_id := value.get("task", None):
+                        task = objects[task_id]
+                        obj.__xpm__.task = task
+                return obj
 
+            # A path
             if value["type"] == "path":
                 return Path(value["value"])
-            else:
-                raise Exception("Unhandled type: %s", value["type"])
 
+            if value["type"] == "path.serialized":
+                return SerializedPath(value["value"], value["is_folder"])
+
+            if value["type"] == "enum":
+                module = importlib.import_module(value["module"])
+                enumClass = getqualattr(module, value["enum"])
+                return enumClass[value["value"]]
+
+            raise Exception("Unhandled type: %s", value["type"])
+
+        # Just a simple value
         return value
 
+    @overload
     @staticmethod
-    def fromParameters(definitions):
+    def fromParameters(
+        definitions: List[Dict],
+        as_instance=True,
+        save_directory: Optional[Path] = None,
+        discard_id: bool = False,
+    ) -> "TypeConfig":
+        ...
+
+    @overload
+    @staticmethod
+    def fromParameters(
+        definitions: List[Dict],
+        as_instance=False,
+        save_directory: Optional[Path] = None,
+        discard_id: bool = False,
+    ) -> "Config":
+        ...
+
+    @staticmethod
+    def fromParameters(
+        definitions: List[Dict],
+        as_instance=True,
+        data_loader: Optional[SerializedPathLoader] = None,
+        discard_id: bool = False,
+    ):
+        """Builds config (instances) from a dictionary"""
         o = None
         objects = {}
         import experimaestro.taskglobals as taskglobals
 
+        # Loop over all the definitions and create objects
         for definition in definitions:
             module_name = definition["module"]
 
             # Avoids problem when runing module
             if module_name == "__main__":
                 module_name = "_main_"
 
             if "file" in definition:
                 path = definition["file"]
                 with add_to_path(str(Path(path).parent)):
                     spec = importlib.util.spec_from_file_location(module_name, path)
-                    print(spec, module_name, path)
                     mod = importlib.util.module_from_spec(spec)
                     sys.modules[module_name] = mod
                     spec.loader.exec_module(mod)
             else:
                 logger.debug("Importing module %s", definition["module"])
                 mod = importlib.import_module(module_name)
 
-            cls = mod
-            for part in definition["type"].split("."):
-                cls = getattr(cls, part)
+            cls = getqualattr(mod, definition["type"])
 
-            if definition.get("serialized", False):
-                o = cls.fromJSON(definition["value"])
-            else:
-                # Creates an object (and not a config)
-                o = cls.__new__(cls, __xpmobject__=True)
+            # Creates an object (or a config)
+            o = cls.__new__(cls, __xpmobject__=as_instance)
+            assert definition["id"] not in objects, "Duplicate id %s" % definition["id"]
+            objects[definition["id"]] = o
 
-                # And calls the parameter-less initialization
+        # Now that objects have been created, fill in the fields
+        for definition in definitions:
+            o = objects[definition["id"]]
+            xpmtype = o.__getxpmtype__()  # type: ObjectType
+
+            # If instance...
+            if as_instance:
+                # ... calls the parameter-less initialization
                 o.__init__()
 
+                # ... sets potentially useful properties
                 if "typename" in definition:
                     o.__xpmtypename__ = definition["typename"]
-                    o.__xpmidentifier__ = definition["identifier"]
+                    if not discard_id:
+                        o.__xpmidentifier__ = Identifier.from_state_dict(
+                            definition["identifier"]
+                        )
 
                     if "." in o.__xpmtypename__:
                         _, name = o.__xpmtypename__.rsplit(".", 1)
                     else:
                         name = o.__xpmtypename__
-                    basepath = (
-                        taskglobals.wspath
-                        / "jobs"
-                        / o.__xpmtypename__
-                        / o.__xpmidentifier__
-                    )
-                    o.__xpm_stdout__ = basepath / f"{name}.out"
-                    o.__xpm_stderr__ = basepath / f"{name}.err"
 
-                for name, value in definition["fields"].items():
-                    v = ConfigInformation._objectFromParameters(value, objects)
+                    if taskglobals.Env.instance().wspath is not None:
+                        basepath = (
+                            taskglobals.Env.instance().wspath
+                            / "jobs"
+                            / o.__xpmtypename__.lower()
+                            / o.__xpmidentifier__.all.hex().lower()
+                        )
+                        o.__xpm_stdout__ = basepath / f"{name.lower()}.out"
+                        o.__xpm_stderr__ = basepath / f"{name.lower()}.err"
+            else:
+                xpminfo = o.__xpm__  # type: ConfigInformation
+
+                meta = definition.get("meta", None)
+                if meta:
+                    xpminfo._meta = meta
+                if xpminfo.xpmtype.task is not None:
+                    o.__xpm__.job = object()
+
+            # Set the fields
+            for name, value in definition["fields"].items():
+                v = ConfigInformation._objectFromParameters(value, objects, as_instance)
+
+                # Transform serialized paths arguments
+                argument = xpmtype.arguments[name]
+                if argument.is_data and v is not None:
+                    if isinstance(v, SerializedPath):
+                        if data_loader is None:
+                            v = v.path
+                        else:
+                            v = data_loader(v)
+                    else:
+                        assert isinstance(v, Path), "Excepted Path, got {type(v)}"
+
+                if as_instance:
+                    # Unwrap the value if needed
                     setattr(o, name, v)
+
                     assert (
                         getattr(o, name) is v
                     ), f"Problem with deserialization {name} of {o.__class__}"
+                else:
+                    o.__xpm__.set(name, v, bypass=True)
 
+            if as_instance:
                 # Calls post-init
-                postinit = getattr(o, "__postinit__", None)
-                if postinit is not None:
-                    postinit()
+                o.__post_init__()
 
-                assert definition["id"] not in objects, (
-                    "Duplicate id %s" % definition["id"]
-                )
+            else:
+                # Sets pre-tasks
+                o.__xpm__.pre_tasks = [
+                    objects[pre_task_id]
+                    for pre_task_id in definition.get("pre-tasks", [])
+                ]
+
+                # Seal and set the identifier
+                if not discard_id:
+                    xpminfo._identifier = Identifier.from_state_dict(
+                        definition["identifier"]
+                    )
+                xpminfo._sealed = True
 
-            objects[definition["id"]] = o
+        # Execute pre-tasks (just once)
+        completed_pretasks = set()
+        for definition in definitions:
+            for pre_task_id in definition.get("pre-tasks", []):
+                if pre_task_id not in completed_pretasks:
+                    completed_pretasks.add(pre_task_id)
+                    pre_task = objects[pre_task_id]
+                    logger.info("Executing pre-task %s", type(pre_task))
+                    pre_task.execute()
 
         return o
 
-    class FromPython(GenerationConfigProcessing):
-        def __init__(self, context: GenerationContext):
+    class FromPython(ConfigWalk):
+        def __init__(self, context: ConfigWalkContext, *, objects: ObjectStore = None):
             super().__init__(context)
-            self.objects = {}
+            self.objects = ObjectStore() if objects is None else objects
+            self.pre_tasks = {}
 
         def preprocess(self, config: "Config"):
-            v = self.objects.get(id(config))
-            return v is None, v
+            if self.objects.is_constructed(id(config)):
+                return False, self.objects.retrieve(id(config))
+            return True, None
 
-        def postprocess(self, config: "Config", values: Dict[str, Any]):
-            # Creates an object (and not a config)
-            o = config.__xpmtype__.objecttype.__new__(
-                config.__xpmtype__.objecttype, __xpmobject__=True
-            )
-            # And calls the parameter-less initialization
-            o.__init__()
+        def stub(self, config: "Config"):
+            o = self.objects.retrieve(id(config))
 
-            self.objects[id(self)] = o
+            if o is None:
+                # Creates an object (and not a config)
+                o = config.__xpmtype__.objecttype.__new__(
+                    config.__xpmtype__.objecttype, __xpmobject__=True
+                )
 
-            # Set values
-            for key, value in values.items():
-                setattr(o, key, value)
-                postinit = getattr(o, "__postinit__", None)
-                if postinit is not None:
-                    postinit()
-
-            # Generate values
-            for arg in config.__xpmtype__.arguments.values():
-                if arg.generator is not None:
-                    setattr(o, arg.name, arg.generator(self.context, o))
+                # And calls the parameter-less initialization
+                o.__init__()
+
+                # Store in cache
+                self.objects.add_stub(id(config), o)
 
             return o
 
-    def fromConfig(self, context: GenerationContext):
+        def postprocess(self, stub, config: "Config", values: Dict[str, Any]):
+            # Copy values from the
+            for key, value in values.items():
+                setattr(stub, key, value)
+
+            # Call __post_init__
+            stub.__post_init__()
+
+            # Gather pre-tasks
+            for pre_task in config.__xpm__.pre_tasks:
+                self.pre_tasks[id(pre_task)] = self.stub(pre_task)
+
+            self.objects.set_constructed(id(config))
+            return stub
+
+    def fromConfig(self, context: ConfigWalkContext, *, objects: ObjectStore = None):
         """Generate an instance given the current configuration"""
+
+        # Validate and seal
         self.validate()
-        processor = ConfigInformation.FromPython(context)
-        return processor(self.pyobject)
+        self.seal(context)
+
+        processor = ConfigInformation.FromPython(context, objects=objects)
+        last_object = processor(self.pyobject)
+
+        # Execute pre-tasks
+        for pre_task in processor.pre_tasks.values():
+            pre_task.execute()
+
+        return last_object
 
     def add_dependencies(self, *dependencies):
         self.dependencies.extend(dependencies)
 
 
 def clone(v):
     """Clone a value"""
@@ -865,14 +1441,20 @@
 
     if isinstance(v, (str, float, int, Path)):
         return v
 
     if isinstance(v, list):
         return [clone(x) for x in v]
 
+    if isinstance(v, dict):
+        return {clone(key): clone(value) for key, value in v.items()}
+
+    if isinstance(v, Enum):
+        return v
+
     if isinstance(v, Config):
         # Create a new instance
         kwargs = {
             argument.name: clone(value)
             for argument, value in v.__xpm__.xpmvalues()
             if argument.generator is None and not argument.constant
         }
@@ -884,32 +1466,32 @@
 
 
 def cache(fn, name: str):
     def __call__(config, *args, **kwargs):
         import experimaestro.taskglobals as taskglobals
 
         # Get path and create directory if needed
-        hexid = config.__xpmidentifier__  # type: str
+        hexid = config.__xpmidentifier__  # type: Identifier
         typename = config.__xpmtypename__  # type: str
-        dir = taskglobals.wspath / "config" / typename / hexid
+        dir = taskglobals.Env.instance().wspath / "config" / typename / hexid.all.hex()
 
         if not dir.exists():
             dir.mkdir(parents=True, exist_ok=True)
 
         path = dir / name
         ipc_lock = fasteners.InterProcessLock(path.with_suffix(path.suffix + ".lock"))
         with ipc_lock:
             r = fn(config, path, *args, **kwargs)
             return r
 
     return __call__
 
 
 class TypeConfig:
-    """Class of configuration objects"""
+    """Class for configuration objects"""
 
     __xpmtype__: ObjectType
 
     def __init__(self, **kwargs):
         """Initialize the configuration with the given parameters"""
 
         # Add configuration
@@ -920,50 +1502,53 @@
 
         # Get the line where the object was created (error reporting)
         caller = inspect.getframeinfo(inspect.stack()[1][0])
         xpm._initinfo = "%s:%s" % (str(Path(caller.filename).absolute()), caller.lineno)
 
         self.__xpm__ = xpm
 
+        # Initialize with default arguments (or None)
+        for name, value in xpmtype.arguments.items():
+            if name not in kwargs:
+                if value.default is not None:
+                    self.__xpm__.set(name, clone(value.default), bypass=True)
+                elif not value.required:
+                    self.__xpm__.set(name, None, bypass=True)
+
         # Initialize with arguments
         for name, value in kwargs.items():
             # Check if argument is OK
             if name not in xpmtype.arguments:
+                attribute = getattr(self.__class__, name, None)
+                if isinstance(attribute, DeprecatedAttribute):
+                    attribute.__set__(self, value)
+                    continue
                 raise ValueError("%s is not an argument for %s" % (name, xpmtype))
 
             # Special case of a tagged value
             if isinstance(value, TaggedValue):
                 value = value.value
                 self.__xpm__._tags[name] = value
 
             # Really set the value
             xpm.set(name, value)
 
-        # Initialize with default arguments (or None)
-        for name, value in xpmtype.arguments.items():
-            if name not in kwargs:
-                if value.default is not None:
-                    self.__xpm__.set(name, clone(value.default), bypass=True)
-                elif not value.required:
-                    self.__xpm__.set(name, None, bypass=True)
-
     def __repr__(self):
-        lines = [
-            f"Experimaestro configuration object of type {self.__xpmtype__.identifier}",
-            "",
-            "Parameters",
-        ]
-        for argument in self.__xpmtype__.arguments.values():
-            lines.append(
-                f""" - {argument.name} ({argument.type.name()}) {argument.help or ""}"""
-            )
+        return f"Config[{self.__xpmtype__.identifier}]"
 
-        return "\n".join(lines)
+    def __str__(self):
+        params = ", ".join(
+            [f"{key}={value}" for key, value in self.__xpm__.values.items()]
+        )
+        return (
+            f"{self.__xpmtype__.objecttype.__module__}."
+            f"{self.__xpmtype__.objecttype.__qualname__}({params})"
+        )
 
-    def tag(self, name, value) -> "Config":
+    def tag(self, name, value):
         self.__xpm__.addtag(name, value)
         return self
 
     def __eq__(self, other):
         if self.__class__ != other.__class__:
             return False
         for argument, value in self.__xpm__.xpmvalues():
@@ -980,81 +1565,132 @@
         return self.__xpm__.tags()
 
     def add_dependencies(self, *dependencies):
         """Adds tokens to the task"""
         self.__xpm__.add_dependencies(*dependencies)
         return self
 
-    def instance(self, context: GenerationContext = None):
+    def instance(
+        self, context: ConfigWalkContext = None, *, objects: ObjectStore = None
+    ) -> T:
         """Return an instance with the current values"""
         if context is None:
             from experimaestro.xpmutils import EmptyContext
 
             context = EmptyContext()
-        return self.__xpm__.fromConfig(context)
-
-    def submit(self, *, workspace=None, launcher=None, dryrun=False):
-        """Submit this task"""
-        return self.__xpm__.submit(workspace, launcher, dryrun=dryrun)
+        else:
+            assert isinstance(
+                context, ConfigWalkContext
+            ), f"{context.__class__} is not an instance of ConfigWalkContext"
+        return self.__xpm__.fromConfig(context, objects=objects)  # type: ignore
+
+    def submit(self, *, workspace=None, launcher=None, run_mode: "RunMode" = None):
+        """Submit this task
+
+        :param workspace: the workspace, defaults to None
+        :param launcher: The launcher, defaults to None
+        :param run_mode: Run mode (if None, uses the workspace default)
+        :return: an object object
+        """
+        return self.__xpm__.submit(workspace, launcher, run_mode=run_mode)
 
     def stdout(self):
         return self.__xpm__.job.stdout
 
     def stderr(self):
         return self.__xpm__.job.stderr
 
+    def wait(self):
+        return self.__xpm__.job.wait()
+
     @property
     def job(self):
         return self.__xpm__.job
 
     @property
     def jobpath(self):
         if self.__xpm__.job:
             return self.__xpm__.job.jobpath
         raise AssertionError("Cannot ask the job path of a non submitted task")
 
     def copy(self):
-        """Returns a copy of this configuration (ignores other non parameters attributes)"""
+        """Returns a copy of this configuration (ignores other non parameters
+        attributes)"""
         return clone(self)
 
-    def istaskoutput(self):
-        """Returns whether this configuration is a task output"""
-        for arg, value in self.__xpm__.xpmvalues(generated=True):
-            if arg.isoutput():
-                return True
-        return False
+    def add_pretasks(self, *tasks: "LightweightTask"):
+        assert all(
+            [isinstance(task, LightweightTask) for task in tasks]
+        ), "One of the pre-tasks are not lightweight tasks"
+        if self.__xpm__._sealed:
+            raise SealedError("Cannot add pre-tasks to a sealed configuration")
+        self.__xpm__.pre_tasks.extend(tasks)
+        return self
+
+    def add_pretasks_from(self, *configs: "Config"):
+        assert all(
+            [isinstance(config, TypeConfig) for config in configs]
+        ), "One of the parameters is not a configuration object"
+        for config in configs:
+            self.add_pretasks(*config.__xpm__.pre_tasks)
+        return self
 
+    @property
+    def pre_tasks(self) -> List["LightweightTask"]:
+        """Access pre-tasks"""
+        return self.__xpm__.pre_tasks
+
+    def copy_dependencies(self, other: "Config"):
+        """Add all the dependencies from other configuration"""
+
+        # Add task dependency
+        if other.__xpm__.task is not None:
+            assert self.__xpm__.task is None
+            self.__xpm__.task = other.__xpm__.task
 
-T = TypeVar("T")
+        # Add other dependencies
+        self.__xpm__.add_dependencies(*other.__xpm__.dependencies)
 
 
 class Config:
     """Base type for all objects in python interface"""
 
     __xpmtype__: ClassVar[ObjectType]
+    """The object type holds all the information about a specific subclass
+    experimaestro metadata"""
+
     __xpm__: ConfigInformation
+    """The __xpm__ object contains all instance specific information about a
+    configuration/task"""
 
     @classmethod
-    def __getxpmtype__(cls):
+    def __getxpmtype__(cls) -> "ObjectType":
         """Get (and create if necessary) the Object type of this"""
         xpmtype = cls.__dict__.get("__xpmtype__", None)
         if xpmtype is None:
             from experimaestro.core.types import ObjectType
 
             # Will set __xpmtype__
-            return ObjectType(cls)
+            try:
+                return ObjectType(cls)
+            except Exception:
+                logger.error("Error while creating object type for %s", cls)
+                raise
         return xpmtype
 
     def __getnewargs_ex__(self):
         # __new__ will be called with those arguments when unserializing
         return ((), {"__xpmobject__": True})
 
-    def __new__(
-        cls: Type[T], *args, __xpmobject__=False, **kwargs
-    ) -> Union[TypeConfig, T]:
+    @classmethod
+    def c(cls: Type[T], **kwargs) -> T:
+        """Allows typing to process easily"""
+        return cls.__new__(cls, **kwargs)
+
+    def __new__(cls: Type[T], *args, __xpmobject__=False, **kwargs) -> T:
         """Returns an instance of a TypeConfig when called __xpmobject__ is False,
         and otherwise the real object
         """
 
         if __xpmobject__:
             # __init__ is  called directly
             return object.__new__(cls)
@@ -1064,152 +1700,95 @@
         o.__init__(*args, **kwargs)
         return o
 
     def __validate__(self):
         """Validate the values"""
         pass
 
+    def __post_init__(self):
+        """Called after the object  __init__() and with properties set"""
+        # Default implementation is to do nothing
+        pass
 
-class Task(Config):
-    """base class for tasks"""
-
-    pass
-
-
-# --- Output proxy
-
-
-class Proxy:
-    """A proxy for a value"""
-
-    def __unwrap__(self) -> Any:
-        raise NotImplementedError()
-
-
-class ItemAccessor:
-    def __init__(self, key: Any):
-        self.key = key
-
-    def toJSON(self):
-        return {"type": "item", "name": self.key}
-
-    def get(self, value):
-        return value.__getitem__(self.key)
-
-
-class AttrAccessor:
-    def __init__(self, key: Any, default: Any):
-        self.key = key
-        self.default = default
-
-    def get(self, value):
-        return getattr(value, self.key, self.default)
-
-    def toJSON(self):
-        return {"type": "attr", "name": self.key}
-
-
-class Serialized:
-    """Simple serialization object"""
-
-    def __init__(self, value):
-        self.value = value
-
-    def toJSON(self):
-        return self.value
-
-
-class SerializedConfig:
-    def __init__(self, pyobject: Config, loader):
-        self.pyobject = pyobject
-        self.loader = loader
-
-
-class TaskOutputInfo:
-    def __init__(self, task: Task):
-        self.task = task
-        self.value = None
-        self.path = None
-        self.serialized = None
+    def __json__(self):
+        """Returns a JSON version of the object (if possible)"""
+        return self.__xpm__.__json__()
+
+    def __identifier__(self) -> Identifier:
+        return self.__xpm__.identifier
+
+    def add_pretasks(self, *tasks: "LightweightTask"):
+        """Add pre-tasks"""
+        raise AssertionError("This method can only be used during configuration")
+
+    def add_pretasks_from(self, *configs: "Config"):
+        """Add pre-tasks from the listed configurations"""
+        raise AssertionError(
+            "The 'add_pretasks_from' can only be used during configuration"
+        )
 
-    @property
-    def identifier(self):
-        return self.task.__xpm__.identifier
+    def copy_dependencies(self, other: "Config"):
+        """Add pre-tasks from the listed configurations"""
+        raise AssertionError(
+            "The 'copy_dependencies' method can only be used during configuration"
+        )
 
     @property
-    def job(self):
-        return self.task.__xpm__.job
-
-    def tags(self):
-        tags = self.task.__xpm__.tags()
-        return tags
+    def pre_tasks(self) -> List["LightweightTask"]:
+        """Access pre-tasks"""
+        raise AssertionError("Pre-tasks can be accessed only during configuration")
 
-    def stdout(self):
-        return self.task.__xpm__.job.stdout
 
-    def stderr(self):
-        return self.task.__xpm__.job.stderr
+class LightweightTask(Config):
+    """A task that can be run before or after a real task to modify its behaviour"""
 
-    def wait(self):
-        from experimaestro.scheduler import JobState
+    def execute(self):
+        raise NotImplementedError()
 
-        return self.task.__xpm__.job.wait() == JobState.DONE
 
+class Task(LightweightTask):
+    """Base class for tasks"""
 
-class TaskOutput(Proxy):
-    """Task proxy
+    __tags__: Dict[str, str]
+    """Tags associated with class"""
 
-    This is used when accessing properties *after* having submitted a task,
-    to keep track of the dependencies
-    """
+    def submit(self):
+        raise AssertionError("This method can only be used during configuration")
 
-    def __init__(self, value: Any, task: Task):
-        self.__xpm__ = TaskOutputInfo(task)
-        self.__xpm__.value = value
-
-    def _wrap(self, value):
-        if isinstance(value, SerializedConfig):
-            return SerializedTaskOutput(value.pyobject, value, self.__xpm__.task, [])
 
-        if isinstance(value, (str, int, float, Path, bool)):
-            # No need to wrap if direct
-            return value
+# --- Utility functions
 
-        return TaskOutput(value, self.__xpm__.task)
 
-    def __getitem__(self, key: Any):
-        return self._wrap(self.__xpm__.value.__getitem__(key))
+def copyconfig(config: Config, **kwargs):
+    """Copy a configuration
 
-    def __getattr__(self, key: str, default=None) -> Any:
-        return self._wrap(getattr(self.__xpm__.value, key, default))
+    Useful to modify a configuration that can be potentially
+    wrapped into a task output (i.e., the configuration can be
+    a task output). If the configuration is sealed, the copy
+    will be unsealed.
 
-    def __unwrap__(self):
-        return self.__xpm__.value
+    :param config: _description_
+    :param kwargs: Modify the configuration by assigning the values
 
-
-class SerializedTaskOutput(TaskOutput):
-    """Used when serializing a configuration
-
-    Here, we need to keep track of the path to the value we need
+    :return: _description_
     """
 
-    def __init__(
-        self, value, serialized: SerializedConfig, task: Task, path: List[Any]
-    ):
-        super().__init__(value, task)
-        self.__xpm__.serialized = serialized
-        self.__xpm__.path = path
-
-    def __getitem__(self, key: Any):
-        value = self.__xpm__.value.__getitem__(key)
-        return SerializedTaskOutput(
-            value, self.serialized, self.__xpm__.task, self.path + [ItemAccessor(key)]
-        )
+    # Builds a new configuration object
+    copy = config.__class__()
 
-    def __getattr__(self, key: str, default=None) -> Any:
-        value = getattr(self.__xpm__.value, key, default)
-        return SerializedTaskOutput(
-            value,
-            self.__xpm__.serialized,
-            self.__xpm__.task,
-            self.__xpm__.path + [AttrAccessor(key, default)],
-        )
+    fullkwargs = {name: value for name, value in config.__xpm__.values.items()}
+    fullkwargs.update(kwargs)
+    for name, value in fullkwargs.items():
+        copy.__xpm__.set(name, value, True)
+
+    # Remove generated attributes
+    for argument, value in copy.__xpm__.xpmvalues(generated=True):
+        if argument.generator is not None and value is not None:
+            del copy.__xpm__.values[argument.name]
+
+    return copy
+
+
+def setmeta(config: Config, flag: bool):
+    """Flags the configuration as a meta-parameter"""
+    config.__xpm__.set_meta(flag)
+    return config
```

## Comparing `experimaestro/core/types.py` & `experimaestro-1.0.0/src/experimaestro/core/types.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,22 +1,32 @@
+from abc import ABC, abstractmethod
 import inspect
 import sys
-from typing import Union, Dict, Iterator, List, Type as TypingType
+from typing import Set, Union, Dict, Iterator, List
 from collections import ChainMap
 from pathlib import Path
+import typing
 from docstring_parser.parser import parse
 import experimaestro.typingutils as typingutils
 from experimaestro.utils import logger
 from .arguments import Argument
+from enum import Enum
+import ast
+import textwrap
 
 if sys.version_info.major == 3 and sys.version_info.minor < 9:
     from typing_extensions import _AnnotatedAlias, get_type_hints
 else:
     from typing import _AnnotatedAlias, get_type_hints
 
+if typing.TYPE_CHECKING:
+    from experimaestro.scheduler.base import Job
+    from experimaestro.launchers import Launcher
+    from experimaestro.core.objects import Config
+
 
 class Identifier:
     def __init__(self, name: str):
         self.name = name
 
     def __hash__(self):
         return self.name.__hash__()
@@ -53,15 +63,15 @@
 
     def __init__(self, tn: Union[str, Identifier], description=None):
         if tn is None:
             pass
         elif isinstance(tn, str):
             tn = Identifier(tn)
         self.identifier = tn
-        self.description = description
+        self._description = description
 
     @property
     def ignore(self):
         """Ignore by default"""
         return False
 
     def __str__(self):
@@ -97,36 +107,92 @@
 
         if isinstance(key, TypeProxy):
             return key()
 
         if isinstance(key, Config):
             return key.__getxpmtype__()
 
-        if inspect.isclass(key) and issubclass(key, Config):
-            return key.__getxpmtype__()
+        if inspect.isclass(key):
+            if issubclass(key, Enum):
+                return EnumType(key)
+
+            if issubclass(key, Config):
+                return key.__getxpmtype__()
 
         t = typingutils.get_list(key)
         if t:
             return ArrayType(Type.fromType(t))
 
         t = typingutils.get_dict(key)
         if t:
             return DictType(Type.fromType(t[0]), Type.fromType(t[1]))
 
         raise Exception("No type found for %s", key)
 
 
+class DeprecatedAttribute:
+    def __init__(self, fn):
+        self.fn = fn
+        self.key = fn.__name__
+        self.warned = False
+
+    def __set_name__(self, owner, name):
+        self.key = name
+
+    def __get__(self, instance, owner=None):
+        if instance is None:
+            return self
+        raise NotImplementedError(f"{instance} {owner}")
+
+    def __set__(self, instance, value):
+        if not self.warned:
+            logger.warning(f"Parameter {self.key} is deprecated")
+        self.fn(instance, value)
+
+
+class SubmitHook(ABC):
+    """Hook called before the job is submitted to the scheduler
+
+    This allows modifying e.g. the run environnement
+    """
+
+    def __call__(self, cls: typing.Type["Config"]):
+        """Decorates a an XPM configuration"""
+        cls.__getxpmtype__().submit_hooks.add(self)
+        return cls
+
+    @abstractmethod
+    def process(self, job: "Job", launcher: "Launcher"):
+        """Apply the hook for the job/launcher"""
+        ...
+
+    @abstractmethod
+    def spec(self):
+        """Returns an identifier tuple for hashing/equality"""
+        ...
+
+    def __eq__(self, other):
+        if other.__class__ is not self.__class__:
+            return False
+        return self.__spec__ == other.__spec__
+
+    def __hash__(self):
+        return hash((self.__class__, self.spec()))
+
+
 class ObjectType(Type):
+    submit_hooks: Set[SubmitHook]
+    """Hooks associated with this configuration"""
+
     """ObjectType contains class-level information about
     experimaestro configurations and tasks
 
-    Attributes:
-
-    objecttype: The python Type of the associated object
-    configtype: The python Type of the configuration object that uses property for arguments
+    :param objecttype: The python Type of the associated object
+    :param configtype: The python Type of the configuration object that uses
+        property for arguments
     """
 
     # Those entries should not be copied in the __dict__
     FORBIDDEN_KEYS = set(("__dict__", "__weakref__"))
 
     def __init__(
         self,
@@ -136,14 +202,15 @@
         """Creates a type"""
         from .objects import Config, TypeConfig
 
         # Task related attributes
         self.taskcommandfactory = None
         self.task = None
         self._title = None
+        self.submit_hooks = set()
 
         # Get the identifier
         if identifier is None and hasattr(tp, "__xpmid__"):
             __xpmid__ = getattr(tp, "__xpmid__")
             if inspect.ismethod(__xpmid__):
                 identifier = Identifier(__xpmid__())
             elif "__xpmid__" in tp.__dict__:
@@ -183,31 +250,41 @@
         # Create the type-specific configuration class
         __configbases__ = tuple(
             s.__getxpmtype__().configtype
             for s in tp.__bases__
             if issubclass(s, Config) and (s is not Config)
         ) or (TypeConfig,)
 
-        self.configtype = type("TypeConfig", __configbases__ + (self.basetype,), {})
-        self.configtype.__qualname__ = f"{self.basetype.__qualname__}.TypeConfig"
+        *tp_qual, tp_name = self.basetype.__qualname__.split(".")
+        self.configtype = type(f"{tp_name}_XPMConfig", __configbases__ + (self.basetype,), {})
+        self.configtype.__qualname__ = ".".join(tp_qual + [self.configtype.__name__])
         self.configtype.__module__ = tp.__module__
 
         # Create the type-specific object class
-        # (now, the same as basetype - TODO: remove references)
+        # (now, the same as basetype - but in the future, remove references)
         self.objecttype = self.basetype  # type: type
         self.basetype._ = self.configtype
 
+        # Return type is used by tasks to change the output
+        if hasattr(self.basetype, "task_outputs") or False:
+            self.returntype = get_type_hints(
+                getattr(self.basetype, "task_outputs")
+            ).get("return", typing.Any)
+        else:
+            self.returntype = self.objecttype
+
         # Registers ourselves
         self.basetype.__xpmtype__ = self
         self.configtype.__xpmtype__ = self
 
         # Other initializations
         self.__initialized__ = False
         self._runtype = None
         self.annotations = []
+        self._deprecated = False
 
     def addAnnotation(self, annotation):
         assert not self.__initialized__
         self.annotations.append(annotation)
 
     def getpythontaskcommand(self, pythonpath=None):
         import experimaestro.commandline as commandline
@@ -230,15 +307,18 @@
             return
         self.__initialized__ = True
 
         from .objects import Task
 
         # Get the module
         module = inspect.getmodule(self.originaltype)
-        self._file = Path(inspect.getfile(self.originaltype)).absolute()
+        if getattr(module, '__file__', None) is None:
+            self._file = None
+        else:
+            self._file = Path(inspect.getfile(self.originaltype)).absolute()
         self._module = module.__name__
         self._package = module.__package__
 
         # The class of the object
 
         self._arguments = ChainMap(
             {}, *(tp.arguments for tp in self.parents())
@@ -250,23 +330,14 @@
 
         # Add task
         if self.taskcommandfactory is not None:
             self.task = self.taskcommandfactory(self)
         elif issubclass(self.basetype, Task):
             self.task = self.getpythontaskcommand()
 
-        # Get description from documentation
-        paramhelp = {}
-        if "__doc__" in self.basetype.__dict__:
-            parseddoc = parse(self.basetype.__doc__)
-            self._title = parseddoc.short_description
-            self.description = parseddoc.long_description
-            for param in parseddoc.params:
-                paramhelp[param.arg_name] = param.description
-
         # Add arguments from type hints
         from .arguments import TypeAnnotation
 
         if hasattr(self.basetype, "__annotations__"):
             typekeys = set(self.basetype.__dict__.get("__annotations__", {}).keys())
             hints = get_type_hints(self.basetype, include_extras=True)
             for key, typehint in hints.items():
@@ -274,42 +345,100 @@
                 if key in typekeys:
                     options = None
                     if isinstance(typehint, _AnnotatedAlias):
                         for value in typehint.__metadata__:
                             if isinstance(value, TypeAnnotation):
                                 options = value(options)
                         if options is not None:
-                            if options.kwargs.get("help", None) is None:
-                                options.kwargs["help"] = paramhelp.get(key, None)
                             try:
                                 self.addArgument(
                                     options.create(
                                         key, self.objecttype, typehint.__args__[0]
                                     )
                                 )
                             except Exception:
                                 logger.error(
                                     "while adding argument %s of %s",
                                     key,
                                     self.objecttype,
                                 )
                                 raise
 
+    def name(self):
+        return f"{self.basetype.__module__}.{self.basetype.__qualname__}"
+
+    def __parsedoc__(self):
+        """Parse the documentation"""
+        # Initialize the object if needed
+        if self._title is not None:
+            return
+        self.__initialize__()
+
+        # Get description from documentation
+        __doc__ = self.basetype.__dict__.get("__doc__", None)
+        if __doc__:
+            parseddoc = parse(__doc__)
+            self._title = parseddoc.short_description
+            self._description = parseddoc.long_description
+            for param in parseddoc.params:
+                argument = self._arguments.get(param.arg_name, None)
+                if argument is None:
+                    logger.warning(
+                        "Found documentation for undeclared argument %s", param.arg_name
+                    )
+                else:
+                    argument.help = param.description
+
+        # Get argument help from annotations (PEP 257)
+        parsed = ast.parse(textwrap.dedent(inspect.getsource(self.originaltype)))
+
+        argname = None  # Current argument name
+        for node in parsed.body[0].body:
+            if isinstance(node, ast.AnnAssign):
+                argname = node.target.id
+            else:
+                if isinstance(node, ast.Expr) and isinstance(node.value, ast.Constant):
+                    argument = self._arguments.get(argname, None)
+                    if argument is not None:
+                        argument.help = node.value.value
+
+                argname = None
+
+    def deprecate(self):
+        if len(self.basetype.__bases__) != 1:
+            raise RuntimeError(
+                "Deprecated configurations must have "
+                "only one parent (the new configuration)"
+            )
+        assert not self._deprecated, "Already deprecated"
+
+        # Uses the parent identifier (and saves the deprecated one for path updates)
+        self._deprecated_identifier = self.identifier
+        parent = self.basetype.__bases__[0].__getxpmtype__()
+        self.identifier = parent.identifier
+        self._deprecated = True
+
+    @property
+    def description(self) -> str:
+        self.__parsedoc__()
+        return self._description
+
     @property
     def title(self) -> Dict[str, Argument]:
-        self.__initialize__()
+        self.__parsedoc__()
         return self._title or str(self.identifier)
 
     @property
     def arguments(self) -> Dict[str, Argument]:
         self.__initialize__()
         return self._arguments
 
     def addArgument(self, argument: Argument):
         self._arguments[argument.name] = argument
+        argument.objecttype = self
 
         # The the attribute for the config type
         setattr(
             self.configtype,
             argument.name,
             property(
                 lambda _self: _self.__xpm__.get(argument.name),
@@ -330,40 +459,30 @@
 
         for tp in self.basetype.__bases__:
             if issubclass(tp, Config) and tp not in [Config, Task]:
                 yield tp.__xpmtype__
 
     def validate(self, value):
         """Ensures that the value is compatible with this type"""
-        from .objects import Config, Proxy
+        from .objects import Config
 
         self.__initialize__()
 
         if value is None:
             return None
 
-        if isinstance(value, Proxy):
-            _value = value.__unwrap__()
-            _value = self.validate(_value)
-
-            # If this is a simple type, OK
-            if isinstance(_value, (int, float, str, bool, Path)):
-                return _value
-
-            # Returns the proxy
-            return value
-
         if not isinstance(value, Config):
             raise ValueError(f"{value} is not an experimaestro type or task")
 
         types = self.basetype
 
         if not isinstance(value, types):
             raise ValueError("%s is not a subtype of %s" % (value, types))
 
+        # Check that the task has been submitted
         if self.task and not value.__xpm__.job:
             raise ValueError("The value must be submitted before giving it")
         return value
 
     def fullyqualifiedname(self) -> str:
         """Returns the fully qualified (Python) name"""
         return f"{self.basetype.__module__}.{self.basetype.__qualname__}"
@@ -451,29 +570,44 @@
 
 
 class ArrayType(Type):
     def __init__(self, type: Type):
         self.type = type
 
     def name(self):
-        return f"Array[{self.type.name()}]"
+        return f"List[{self.type.name()}]"
 
     def validate(self, value):
         if not isinstance(value, List):
             raise ValueError("value is not a list")
 
         return [self.type.validate(x) for x in value]
 
     def __str__(self):
         return f"Array({self.type})"
 
     def __repr__(self):
         return f"Array({self.type})"
 
 
+class EnumType(Type):
+    def __init__(self, type: typing.Type[Enum]):
+        self.type = type
+
+    def validate(self, value):
+        assert isinstance(value, self.type), f"{value} is not of type {self.type}"
+        return value
+
+    def __str__(self):
+        return f"Enum({self.type})"
+
+    def __repr__(self):
+        return f"Enum({self.type})"
+
+
 class DictType(Type):
     def __init__(self, keytype: Type, valuetype: Type):
         self.keytype = keytype
         self.valuetype = valuetype
 
     def name(self):
         return f"Dict[{self.keytype.name()},{self.valuetype.name()}]"
```

## Comparing `experimaestro/launchers/slurm.py` & `experimaestro-1.0.0/src/experimaestro/launchers/slurm/base.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,128 +1,204 @@
+import logging
 import threading
-from typing import Dict, List, Optional, get_type_hints
+from pathlib import Path
+from typing import (
+    Any,
+    Dict,
+    List,
+    Optional,
+    Tuple,
+    get_type_hints,
+)
 from experimaestro.connectors.local import LocalConnector
 import re
 from contextlib import contextmanager
+from dataclasses import dataclass
+from experimaestro.launcherfinder.registry import (
+    LauncherRegistry,
+)
 from experimaestro.utils import ThreadingCondition
 from experimaestro.tests.connectors.utils import OutputCaptureHandler
-from . import Launcher
-from experimaestro.scriptbuilder import ShScriptBuilder
+from experimaestro.utils.asyncio import asyncThreadcheck
+from experimaestro.compat import cached_property
+from experimaestro.launchers import Launcher
+from experimaestro.scriptbuilder import PythonScriptBuilder
 from experimaestro.connectors import (
     Connector,
     ProcessBuilder,
     Process,
+    ProcessState,
     Redirect,
     RedirectType,
 )
-from experimaestro.utils import logger
+
+logger = logging.getLogger("xpm.slurm")
 
 
 class SlurmJobState:
     start: str
     end: str
     status: str
 
+    STATE_MAP = {
+        "CONFIGURING": ProcessState.SCHEDULED,
+        "REQUEUE_FED": ProcessState.SCHEDULED,
+        "PENDING": ProcessState.SCHEDULED,
+        "REQUEUE_HOLD": ProcessState.SCHEDULED,
+        "COMPLETING": ProcessState.RUNNING,
+        "RUNNING": ProcessState.RUNNING,
+        "COMPLETED": ProcessState.DONE,
+        "FAILED": ProcessState.ERROR,
+        "DEADLINE": ProcessState.ERROR,
+        "NODE_FAIL": ProcessState.ERROR,
+        "REVOKED": ProcessState.ERROR,
+        "TIMEOUT": ProcessState.ERROR,
+        "CANCELLED": ProcessState.ERROR,
+        "BOOT_FAIL": ProcessState.ERROR,
+        "OUT_OF_MEMORY": ProcessState.ERROR,
+    }
+
     def __init__(self, status, start, end):
-        self.status = status
+        self.slurm_state = status if status[-1] == "+" else status
+        if self.slurm_state.startswith("CANCELLED"):
+            self.state = ProcessState.ERROR
+        else:
+            self.state = SlurmJobState.STATE_MAP.get(self.slurm_state, None)
+            if self.state is None:
+                logging.warning(
+                    "Unknown state: %s (supposing this is an error)", self.slurm_state
+                )
+                self.state = ProcessState.ERROR
+
         self.start = start
         self.end = end
 
     def finished(self):
-        return self.status in ["COMPLETED", "FAILED"]
+        """Returns true if the job has finished"""
+        return self.state.finished
 
     def __repr__(self):
-        return f"{self.status} ({self.start}-{self.end})"
+        return f"{self.slurm_state} ({self.start}-{self.end})"
 
 
 class SlurmProcessWatcher(threading.Thread):
-    WATCHERS: Dict["SlurmLauncher", "SlurmProcessWatcher"] = {}
+    """Process that calls sacct at regular interval to check job status"""
+
+    WATCHERS: Dict[Tuple[Tuple[str, Any]], "SlurmProcessWatcher"] = {}
 
     def __init__(self, launcher: "SlurmLauncher"):
         super().__init__()
         self.launcher = launcher
         self.count = 1
-        self.jobs = {}
+        self.jobs: Dict[str, SlurmJobState] = {}
 
         self.cv = ThreadingCondition()
         self.start()
 
     @staticmethod
     @contextmanager
     def get(launcher: "SlurmLauncher"):
-        watcher = SlurmProcessWatcher.WATCHERS.get(launcher.main, None)
+        watcher = SlurmProcessWatcher.WATCHERS.get(launcher.key, None)
         if watcher is None:
             watcher = SlurmProcessWatcher(launcher)
-            SlurmProcessWatcher.WATCHERS[launcher.main] = watcher
+            SlurmProcessWatcher.WATCHERS[launcher.key] = watcher
         else:
             with watcher.cv:
                 watcher.count += 1
         yield watcher
         watcher.count -= 1
+        with watcher.cv:
+            watcher.cv.notify()
 
     def getjob(self, jobid):
+        """Allows to share the calls to sacct"""
         with self.cv:
             self.cv.wait()
             return self.jobs.get(jobid)
 
     def run(self):
         while self.count > 0:
-            with self.cv:
-                self.cv.wait_for(
-                    lambda: self.count == 0, timeout=self.launcher.interval
-                )
-                if self.count == 0:
-                    break
-
             builder = self.launcher.connector.processbuilder()
             builder.command = [
                 f"{self.launcher.binpath}/sacct",
                 "-n",
                 "-p",
                 "--format=JobID,State,Start,End",
             ]
             handler = OutputCaptureHandler()
             builder.detach = False
             builder.stdout = Redirect.pipe(handler)
             builder.environ = self.launcher.launcherenv
+            logger.debug("Checking SLURM state with sacct")
             builder.start()
 
             with self.cv:
                 self.jobs = {}
                 output = handler.output.decode("utf-8")
                 for line in output.split("\n"):
                     line = line.strip()
                     if line:
                         try:
                             jobid, state, start, end, *_ = line.split("|")
                             self.jobs[jobid] = SlurmJobState(state, start, end)
                             logger.debug("Parsed line: %s", line)
-                        except ValueError as e:
+                        except ValueError:
                             logger.error("Could not parse line %s", line)
                 logger.debug("Jobs %s", self.jobs)
                 self.cv.notify_all()
 
+                self.cv.wait_for(
+                    lambda: self.count == 0, timeout=self.launcher.interval
+                )
+                if self.count == 0:
+                    logger.debug("Stopping SLURM watcher process")
+                    del SlurmProcessWatcher.WATCHERS[self.launcher.key]
+                    break
+
 
 class BatchSlurmProcess(Process):
     """A batch slurm process"""
 
     def __init__(self, launcher: "SlurmLauncher", jobid: str):
         self.launcher = launcher
         self.jobid = jobid
 
     def wait(self):
         with SlurmProcessWatcher.get(self.launcher) as watcher:
             while True:
                 state = watcher.getjob(self.jobid)
                 if state and state.finished():
-                    return 0 if state.status == "COMPLETED" else 1
+                    return 0 if state.slurm_state == "COMPLETED" else 1
+
+    async def aio_state(self):
+        def check():
+            with SlurmProcessWatcher.get(self.launcher) as watcher:
+                jobinfo = watcher.getjob(self.jobid)
+                return jobinfo.state if jobinfo else ProcessState.SCHEDULED
+
+        return await asyncThreadcheck("slurm.aio_isrunning", check)
+
+    def kill(self):
+        logger.warning("Killing slurm job %s", self.jobid)
+        builder = self.launcher.connector.processbuilder()
+        builder.command = [f"{self.launcher.binpath}/scancel", f"{self.jobid}"]
+        builder.start()
 
     def __repr__(self):
         return f"slurm:{self.jobid}"
 
+    def tospec(self):
+        return {"type": "slurm", "pid": self.jobid, "options": self.launcher.key}
+
+    @classmethod
+    def fromspec(cls, connector: Connector, spec: Dict[str, Any]):
+        options = {k: v for k, v in spec.get("options", ())}
+        launcher = SlurmLauncher(connector=connector, **options)
+        return BatchSlurmProcess(launcher, spec["pid"])
+
 
 def addstream(command: List[str], option: str, redirect: Redirect):
     if redirect.type == RedirectType.FILE:
         command.extend([option, redirect.path])
     elif redirect.type == RedirectType.INHERIT:
         pass
     else:
@@ -130,15 +206,15 @@
 
 
 class SlurmProcessBuilder(ProcessBuilder):
     def __init__(self, launcher: "SlurmLauncher"):
         super().__init__()
         self.launcher = launcher
 
-    def start(self) -> Process:
+    def start(self) -> BatchSlurmProcess:
         """Start the process"""
         builder = self.launcher.connector.processbuilder()
         builder.workingDirectory = self.workingDirectory
         builder.environ = self.launcher.launcherenv
         builder.detach = False
 
         if not self.detach:
@@ -157,43 +233,70 @@
         builder.command.extend(self.launcher.options.args())
 
         addstream(builder.command, "-e", self.stderr)
         addstream(builder.command, "-o", self.stdout)
         addstream(builder.command, "-i", self.stdin)
 
         builder.command.extend(self.command)
+        logger.info("slurm sbatch command: %s", builder.command)
         handler = OutputCaptureHandler()
         builder.stdout = Redirect.pipe(handler)
+        builder.stderr = Redirect.inherit()
         p = builder.start()
         if p.wait() != 0:
+            logger.error("Error while running sbatch command")
             raise RuntimeError("Error while submitting job")
 
         output = handler.output.decode("utf-8").strip(" \n")
         RE_SUBMITTED_JOB = re.compile(r"""^(\d+)(?:;.*)?$""", re.MULTILINE)
         m = RE_SUBMITTED_JOB.match(output)
         if m is None:
             raise RuntimeError(f"Could not get the submitted job ID from {output}")
 
         return BatchSlurmProcess(self.launcher, m.group(1))
 
 
+@dataclass
 class SlurmOptions:
     # Options
     nodes: Optional[int] = 1
-    time: Optional[int] = None
+    time: Optional[str] = None
+
+    account: Optional[str] = None
+    """The account for launching the job"""
+
+    qos: Optional[str] = None
+    """The requested Quality of Service"""
+
+    partition: Optional[str] = None
+    """The requested partition"""
+
+    constraint: Optional[str] = None
+    """Logic expression on node features (as defined by the administator)"""
+
+    mem: Optional[str] = None
+    """Requested memory on the node (in megabytes by default)"""
+
+    exclude: Optional[str] = None
+    """List of hosts to exclude"""
+
+    mem_per_gpu: Optional[str] = None
+    """Requested memory per allocated GPU (size with units: K, M, G, or T)"""
+
+    cpus_per_task: Optional[str] = None
+    """Number of cpus requested per task"""
+
+    nodelist: Optional[str] = None
+    """Request a specific list of hosts"""
+
     # GPU-related
     gpus: Optional[int] = None
-    gpus_per_node: Optional[int] = None
 
-    def __init__(self, **kwargs):
-        for key, value in kwargs.items():
-            if key in SlurmOptions.__dict__:
-                self.__dict__[key] = value
-            else:
-                raise ValueError("%s is not a valid option for Slurm")
+    gpus_per_node: Optional[int] = None
+    """Number of GPUs per node"""
 
     def args(self) -> List[str]:
         """Returns the corresponding options"""
         options = []
         for key in get_type_hints(SlurmOptions).keys():
             value = getattr(self, key, None)
             if value is not None:
@@ -223,49 +326,70 @@
     """
 
     def __init__(
         self,
         *,
         connector: Connector = None,
         options: SlurmOptions = None,
-        interval: int = 60,
+        interval: float = 60,
         main=None,
         launcherenv: Dict[str, str] = None,
         binpath="/usr/bin",
     ):
         """
         Arguments:
             main: Main slurm launcher to avoid launching too many polling jobs
             interval: seconds between polling job statuses
         """
         super().__init__(connector or LocalConnector.instance())
-        self.binpath = binpath
+        self.binpath = Path(binpath)
         self.interval = interval
         self.launcherenv = launcherenv
         self.options = options or SlurmOptions()
-        self.main = main or self
+
+    def __str__(self):
+        return f"SlurmLauncher({self.options}, path={self.binpath})"
+
+    @staticmethod
+    def init_registry(registry: LauncherRegistry):
+        from .configuration import SlurmConfiguration
+
+        registry.register_launcher("slurm", SlurmConfiguration)
+
+    @staticmethod
+    def get_cli():
+        from .cli import cli
+
+        return cli
+
+    @cached_property
+    def key(self):
+        """Returns a dictionary characterizing this launcher when calling sacct/etc"""
+        return (
+            ("binpath", str(self.binpath)),
+            ("interval", self.interval),
+        )
 
     def config(self, **kwargs):
         """Returns a new Slurm launcher with the given configuration"""
         return SlurmLauncher(
             connector=self.connector,
             binpath=self.binpath,
             launcherenv=self.launcherenv,
             options=self.options.merge(SlurmOptions(**kwargs)),
-            main=self.main,
             interval=self.interval,
         )
 
     def scriptbuilder(self):
         """Returns the script builder
 
         We assume *nix, but should be changed to PythonScriptBuilder when working
         """
-        builder = ShScriptBuilder()
+        builder = PythonScriptBuilder()
         builder.processtype = "slurm"
         return builder
 
-    def processbuilder(self) -> ProcessBuilder:
+    def processbuilder(self) -> SlurmProcessBuilder:
         """Returns the process builder for this launcher
 
         By default, returns the associated connector builder"""
         return SlurmProcessBuilder(self)
```

## Comparing `experimaestro/mkdocs/base.py` & `experimaestro-1.0.0/src/experimaestro/mkdocs/base.py`

 * *Files 3% similar despite different names*

```diff
@@ -132,14 +132,24 @@
     ):
         for child in self.children:
             current.append(child)
 
         for child in self.children:
             child.topologicalOrder(current, cover)
 
+    def iter_all(self):
+        return self._iter_all(set())
+
+    def _iter_all(self, processed: Set):
+        if id(self) not in processed:
+            yield self
+            processed.add(id(self))
+            for node in self.children:
+                yield from node._iter_all(processed)
+
 
 class ObjectLattice:
     """Lattice of objects"""
 
     def __init__(self):
         self.node = ObjectLatticeNode(None)
 
@@ -151,14 +161,17 @@
         return node
 
     def topologicalOrder(self) -> List[ObjectLatticeNode]:
         current = []
         self.node.topologicalOrder(current, set())
         return current
 
+    def iter_all(self) -> Iterator[ObjectLatticeNode]:
+        return self.node.iter_all()
+
 
 class Configurations:
     def __init__(self):
         self.tasks = set()
         self.configs = set()
 
     def add(self, node: ObjectLatticeNode):
@@ -271,42 +284,81 @@
                     except Exception as e:
                         logging.exception(
                             "Error while reading definitions file %s: %s", path, e
                         )
         return config
 
     def on_post_build(self, config):
+        # Custom format export (FIXME: replace by sphinx)
         mapping_path = Path(config["site_dir"]) / "experimaestro-mapping.json"
         logging.info("Writing mapping file %s", mapping_path)
         with mapping_path.open("wt") as fp:
             json.dump(self.parsed, fp)
 
+        # Sphinx export
+        import zlib
+
+        """Fron Sphinx source code"""
+
+        def escape(string: str) -> str:
+            return re.sub("\\s+", " ", string)
+
+        path = Path(config["site_dir"]) / "objects.inv"
+
+        with path.open("wb") as f:
+            # header
+            f.write(
+                (
+                    "# Sphinx inventory version 2\n"
+                    "# Project: %s\n"
+                    "# Version: %s\n"
+                    "# The remainder of this file is compressed using zlib.\n"
+                    % (escape("site_name"), escape("0.0.0"))
+                ).encode()
+            )
+
+            # body
+            compressor = zlib.compressobj(9)
+
+            for node in self.lattice.iter_all():
+                if node.objecttype is not None:
+                    member = node.objecttype.basetype
+                    qname = f"{member.__module__}.{member.__qualname__}"
+                    path = self.type2path[qname]
+
+                    f.write(
+                        compressor.compress(
+                            f"""{qname} py:xpmconfig 1 {path}#$ -\n""".encode("utf-8")
+                        )
+                    )
+
+            f.write(compressor.flush())
+
     def showlink(self, location, m: re.Match):
         """Show a link to the documentation"""
         return self.getlink(location, m.group(1).strip())
 
     def showclass(self, location, m: re.Match, page: MkdocPage, cfgs: Configurations):
         """Show a class and its descendants"""
 
         # Search for the class
-        classname = m.group(1)
-        node = None
-        for _node in cfgs:
-            basetype = _node.objecttype.basetype
-            if f"{basetype.__module__}.{basetype.__qualname__}" == classname:
-                node = _node
-                break
 
-        if node is None:
-            return f"<div class='error'>Cannot find {classname}</div>"
+        modulename, classname = m.group(1).rsplit(":", 2)
+        t = getattr(importlib.import_module(modulename), classname, None)
+        if t is None:
+            return f"<div class='error'>Cannot find {modulename}:{classname}</div>"
+        if not issubclass(t, Config):
+            return f"<div class='error'>{modulename}:{classname} is not an experimaestro Config(uration)</div>"
+
+        xpmtype = t.__getxpmtype__()
 
         # Now, sort according to descendant/ascendant relationship or name
         nodes = set()
         for _node in cfgs:
-            if issubclass(_node.objecttype.configtype, node.objecttype.configtype):
+            if issubclass(_node.objecttype.configtype, xpmtype.configtype):
                 nodes.add(_node)
 
         # Removes so they are not generated twice
         for node in nodes:
             try:
                 cfgs.remove(node)
             except Exception:
```

## Comparing `experimaestro/mkdocs/metaloader.py` & `experimaestro-1.0.0/src/experimaestro/mkdocs/metaloader.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,25 +1,34 @@
-# Utility class that
+# Utility class that allow to avoid installing modules
+# when building documentation
 
 import sys
 import re
 import importlib.abc
 import importlib.machinery
 
 
+class Spec:
+    def __init__(self, name):
+        self.name = name
+
+
 class Module:
     def __init__(self, loader, spec):
         self.__loader__ = loader
         self.__spec__ = spec
         self.__path__ = None
         self.__package__ = spec.name
         _, self.__name__ = f".{spec.name}".rsplit(".", 1)
 
     def __getattr__(self, key):
-        return type(key, (object,), {})
+        return Module(self.__loader__, Spec(f"{self.__package__}.{key}"))
+
+    def __repr__(self):
+        return f"Fake module ({self.__package__})"
 
 
 class DependencyInjectorLoader(importlib.abc.Loader):
     def create_module(self, spec):
         return Module(self, spec)
 
     def exec_module(self, module):
```

## Comparing `experimaestro/server/data/favicon.ico` & `experimaestro-1.0.0/src/experimaestro/server/data/favicon.ico`

 * *Files identical despite different names*

## Comparing `experimaestro/server/data/index.html` & `experimaestro-1.0.0/src/experimaestro/server/data/index.html`

 * *Files 21% similar despite different names*

```diff
@@ -3,24 +3,25 @@
   <head>
     <meta charset="utf-8" />
     <meta
       name="viewport"
       content="width=device-width, initial-scale=1, shrink-to-fit=no"
     />
     <meta name="theme-color" content="#000000" />
-    <link rel="shortcut icon" href="favicon.ico" />
-    <link rel="stylesheet" type="text/css" href="static/index.css" />
+    <link rel="manifest" href="/manifest.json" />
+    <link rel="shortcut icon" href="/favicon.ico" />
     <title>Experimaestro</title>
   </head>
   <body>
-    <noscript> You need to enable JavaScript to run this app. </noscript>
+    <noscript> You need to enable JavaScript to run this app.</noscript>
     <div id="root"></div>
     <script>
       let process = {
         env: {
           NODE_ENV: "production",
         },
       };
     </script>
-    <script src="static/index.js"></script>
+    <link rel="stylesheet" href="/index.css" />
+    <script src="/index.js"></script>
   </body>
 </html>
```

### html2text {}

```diff
@@ -1,5 +1,6 @@
 
 
 
 
  You need to enable JavaScript to run this app.
+
```

## Comparing `experimaestro/tests/conftest.py` & `experimaestro-1.0.0/src/experimaestro/tests/conftest.py`

 * *Files identical despite different names*

## Comparing `experimaestro/tests/restart.py` & `experimaestro-1.0.0/src/experimaestro/tests/restart.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 import time
 import sys
-from experimaestro import task, pathoption, Scheduler
+from typing import Callable
+from experimaestro import Task, pathoption
 import psutil
 import logging
 import subprocess
 import json
 import signal
+from experimaestro.scheduler.workspace import RunMode
 from experimaestro.tests.utils import TemporaryExperiment, is_posix
 from experimaestro.scheduler import JobState
 from . import restart_main
 
 
 def terminate(p):
     p.terminate()
@@ -22,34 +24,47 @@
 TERMINATES_FUNC = [terminate]
 if is_posix():
     TERMINATES_FUNC.append(sigint)
 
 
 @pathoption("touch", "touch")
 @pathoption("wait", "wait")
-@task("restart")
-class Restart:
+class Restart(Task):
     def execute(self):
         # Write the file "touch" to notify that we started
         with open(self.touch, "w") as out:
             out.write("hello")
 
         # Wait for the file "wait" before exiting
         while not self.wait.is_file():
             time.sleep(0.1)
 
 
-def restart(terminate, experiment):
+def restart(terminate: Callable, experiment):
+    """Check if a new experimaestro process is able to take back
+    a running job
+
+    1. Runs an experiment and kills it using "terminate" while keeping the job active
+    2. Runs the same experiment
+        2.1 Submit the same job
+        2.2 Asserts that the job is running
+        2.3 Signals to the job to end
+        2.4 Asserts that the job is done
+
+    Args:
+        terminate (Callable): How to terminate the process (SIGINT / terminate)
+        experiment ([type]): [description]
+    """
     p = None
     xpmprocess = None
     try:
-        with TemporaryExperiment("restart", maxwait=10) as xp:
-            # Create the task and so we can get the file paths
+        with TemporaryExperiment("restart", maxwait=20) as xp:
+            # Create the task with dry_run and so we can get the file paths
             task = Restart()
-            task.submit(dryrun=True)
+            task.submit(run_mode=RunMode.DRY_RUN)
 
         # Start the experiment with another process, and kill the job
         command = [
             sys.executable,
             restart_main.__file__,
             xp.workspace.path,
             experiment.__module__,
@@ -67,32 +82,46 @@
                 terminate(xpmprocess)
                 assert False, "Timeout waiting for task to be executed"
 
         jobinfo = json.loads(task.__xpm__.job.pidpath.read_text())
         pid = int(jobinfo["pid"])
         p = psutil.Process(pid)
 
+        # Now, kills experimaestro
         logging.debug("Process has started [file %s, pid %d]", task.touch, pid)
         terminate(xpmprocess)
         errorcode = xpmprocess.wait(5)
         logging.debug("Process finishing with status %d", errorcode)
 
         # Check that task is still running
         logging.info("Checking that job (PID %s) is still running", pid)
         assert p.is_running()
 
-        with TemporaryExperiment("restart", maxwait=10) as xp:
+        with TemporaryExperiment("restart", maxwait=20) as xp:
             # Now, submit the job - it should pick up the process
             # where it was left
-            logging.debug("Submitting the job")
-            xp.CURRENT.scheduler.submit(task.__xpm__.job)
+            logging.debug("Submitting the job (continues the submit)")
+            job = task.__xpm__.job
+            scheduler = xp.current().scheduler
+
+            assert scheduler.submit(job) is None
+
+            while scheduler.getJobState(job).result() == JobState.READY:
+                time.sleep(0.1)
+
+            currentState = scheduler.getJobState(job).result()
+            assert (
+                currentState == JobState.RUNNING
+            ), f"Job is not running (state is {currentState})"
+
+            # Notify the task
             with task.wait.open("w") as fp:
                 fp.write("done")
 
-            assert task.__xpm__.job.wait() == JobState.DONE
+            assert job.finalState().result() == JobState.DONE
     finally:
         # Force kill
         if xpmprocess and xpmprocess.poll() is None:
             logging.warning("Forcing to quit process %s", xpmprocess.pid)
             xpmprocess.kill()
 
         if p and p.is_running():
```

## Comparing `experimaestro/tests/test_forward.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_forward.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,31 +1,29 @@
-from experimaestro import argument, config
+from experimaestro import argument, Config
 from experimaestro.click import forwardoption
 import click
 
 
 def test_main():
     @argument("epochs", type=int, default=100, help="Number of learning epochs")
-    @config("mymodel")
-    class MyModel:
+    class MyModel(Config):
         pass
 
     @forwardoption.epochs(MyModel)
     @click.command()
     def cli(epochs):
         return epochs
 
     epochs = cli(["--epochs", "100"], standalone_mode=False)
     assert epochs == 100
 
 
 def test_rename():
     @argument("epochs", type=int, default=100, help="Number of learning epochs")
-    @config("mymodel")
-    class MyModel:
+    class MyModel(Config):
         pass
 
     @forwardoption.epochs(MyModel, "my-epochs")
     @click.command()
     def cli(my_epochs):
         return my_epochs
```

## Comparing `experimaestro/tests/test_objects.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_objects.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,43 +1,57 @@
 from pathlib import Path
-from experimaestro import Config, config, tag, Annotated
+
+import pytest
+from experimaestro import Config, Task, Annotated, copyconfig, default
 from experimaestro.core.arguments import Param
 from experimaestro.core.objects import TypeConfig
 from experimaestro.generators import pathgenerator
+from experimaestro.scheduler.workspace import RunMode
+from experimaestro.tests.utils import TemporaryExperiment
+
 
+@pytest.fixture()
+def xp():
+    with TemporaryExperiment("deprecated", maxwait=0, run_mode=RunMode.DRY_RUN) as xp:
+        yield xp
 
-@config()
-class A:
+
+class A(Config):
     x: Param[int] = 3
 
 
 def test_object_default():
     """Test plain default value"""
     a = A()
     assert a.x == 3
 
 
-@config()
-class B:
+class B(Config):
     a: Param[A] = A(x=3)
 
 
-@config()
 class C(B):
     pass
 
 
+class DefaultAnnotationConfig(Config):
+    a: Annotated[A, default(A(x=3))]
+
+
 def test_object_config_default():
     """Test default configurations as default values"""
     b = B()
     assert b.a.x == 3
 
     c = C()
     assert c.a.x == 3
 
+    annotationConfig = DefaultAnnotationConfig()
+    assert annotationConfig.a.x == 3
+
 
 def test_hierarchy():
     """Test if the object hierarchy is OK"""
     OA = A.__xpmtype__.objecttype
     OB = B.__xpmtype__.objecttype
     OC = C.__xpmtype__.objecttype
 
@@ -50,7 +64,23 @@
     assert not issubclass(OC, TypeConfig)
 
     assert issubclass(C, B)
 
     assert OA.__bases__ == (Config,)
     assert OB.__bases__ == (Config,)
     assert OC.__bases__ == (B,)
+
+
+class CopyConfig(Task):
+    path: Annotated[Path, pathgenerator("hello.txt")]
+    x: Param[int]
+
+
+def test_copyconfig(xp):
+    b = CopyConfig(x=2)
+
+    b.submit()
+
+    copy_b = copyconfig(b)
+
+    assert copy_b.x == b.x
+    assert "path" not in copy_b.__xpm__.values
```

## Comparing `experimaestro/tests/test_param.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_param.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,24 +1,26 @@
 """test_annotations.py
 
-Test all the annotations for configurations and tasks
+Test annotation handling for configurations and tasks
 """
 
 # Annotation specific tests
 
+import sys
 from pathlib import Path
 from typing import Dict, Optional, List
+from experimaestro.core.context import SerializationContext
 from experimaestro.core.types import DictType, IntType, StrType
+from enum import Enum
 import pytest
 from experimaestro import (
     config,
     Option,
     Constant,
     Param,
-    task,
     Task,
     default,
     Config,
     pathgenerator,
     Annotated,
 )
 import experimaestro.core.types as types
@@ -44,15 +46,24 @@
     pass
 
 
 def test_noname():
     assert str(A.__xpmtype__.identifier) == "experimaestro.tests.test_param.a"
 
 
-# --- Use type annotations
+def serializeCycle(config: Config):
+    """Serialize and deserialize a configuration"""
+    from experimaestro.core.objects import ConfigInformation
+    import experimaestro.taskglobals as taskglobals
+
+    taskglobals.Env.instance().wspath = Path("/tmp-xpm1234")
+
+    objects = config.__xpm__.__get_objects__([], SerializationContext())
+
+    return ConfigInformation.fromParameters(objects)
 
 
 def ArgumentValue(default=None, *, help=""):
     return default
 
 
 def test_type_hinting():
@@ -176,14 +187,33 @@
     assert a.x == 2, "Constant value not set"
 
     # We should not be able to change the value
     with pytest.raises(AttributeError):
         a.x = 3
 
 
+class EnumParam(Enum):
+    NONE = 0
+    OTHER = 1
+
+
+class EnumConfig(Config):
+    x: Param[EnumParam]
+
+
+def test_param_enum():
+    """Test for enum values"""
+
+    a = EnumConfig(x=EnumParam.OTHER)
+    _a = serializeCycle(a)
+
+    assert isinstance(_a, EnumConfig)
+    assert _a.x == EnumParam.OTHER
+
+
 def test_inheritance():
     class A(Config):
         x: Param[int]
 
     class B(A):
         y: Param[int] = 3
 
@@ -227,30 +257,47 @@
     with pytest.raises(TypeError):
         A(x={"wrong": 1.2})
 
 
 # --- Task annotations
 
 
-def test_task_config():
-    @config()
-    class Output:
-        pass
-
-    @task()
-    class Task:
-        def config(self) -> Output:
-            return {}
-
-    output = Task().submit(dryrun=True)
-    assert Output.__xpmtype__.configtype == type(output.__unwrap__())
-
-
 def test_default_mismatch():
     """Test mismatch between default and type"""
 
     @config()
     class A:
         x: Param[int] = 0.2
 
     with pytest.raises(TypeError):
         A.__xpmtype__.getArgument("x")
+
+
+# --- Handling help annotations
+
+
+def test_help():
+    class A(Config):
+        """Description of A
+
+        Long description of A.
+
+        Arguments:
+
+            y: Parameter y
+        """
+
+        x: Param[int]
+        """Parameter x"""
+
+        y: Param[int]
+
+    xpmtype = A.__getxpmtype__()
+    xpmtype.__initialize__()
+
+    assert xpmtype.title == "Description of A"
+    assert xpmtype.description.strip() == "Long description of A."
+    assert xpmtype.arguments["y"].help == "Parameter y"
+
+    # Only python >= 3.9
+    if sys.version_info.major == 3 and sys.version_info.minor > 8:
+        assert xpmtype.arguments["x"].help == "Parameter x"
```

## Comparing `experimaestro/tests/test_snippets.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_snippets.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,17 +6,18 @@
 import tempfile
 import subprocess
 import sys
 import shlex
 import os
 import logging
 
-DIR = Path(__file__).parents[2]
+DIR = Path(__file__).parents[3]
 RE_SNIPPET_START = re.compile(
-    r"<!-- SNIPPET: (?P<id>\S+)(?:\s+ARGS\[(?P<args>[^\]]+)\])?(?:\s+ENV\[(?P<env>[^\]]+)\])? -->"
+    r"<!-- SNIPPET: (?P<id>\S+)"
+    r"(?:\s+ARGS\[(?P<args>[^\]]+)\])?(?:\s+ENV\[(?P<env>[^\]]+)\])? -->"
 )
 RE_SNIPPET_START2 = re.compile(r"```python")
 RE_SNIPPET_END = re.compile(r"```")
 RE_SNIPPET_VAR = re.compile(r"%([_\w\d]+)%")
 
 
 class Methods:
@@ -85,15 +86,15 @@
 
 
 @pytest.mark.parametrize("path,id", Methods())
 def test_snippet(snippetpath, path, id):
     snippet, args, env = get_snippet(snippetpath, path, id)
     assert snippet != ""
 
-    WAIT_TIME = 10
+    WAIT_TIME = 20
 
     fullenv = {name: value for name, value in os.environ.items()}
     fullenv.update(
         {"XPM_ENABLEFAULTHANDLER": "1", "XPM_LOCK_TIMEOUT": str(WAIT_TIME / 2)}
     )
     fullenv.update(env)
     with tempfile.NamedTemporaryFile(
```

## Comparing `experimaestro/tests/test_ssh.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_ssh.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,23 +1,26 @@
 from experimaestro.connectors.ssh import SshPath
 
 # --- Test SSH path and SSH path manipulation
 
+
 def test_absolute():
     path = SshPath("ssh://host//a/path")
     assert path.host == "host"
     assert path.is_absolute()
 
+
 def test_relative():
     path = SshPath("ssh://host")
     assert path.host == "host"
     assert path.hostpath == ""
     assert path._parts == []
     assert not path.is_absolute()
 
+
 def test_relative_withpath():
     path = SshPath("ssh://host/relative/path")
     assert path.host == "host"
     assert path.hostpath == "relative/path"
     assert not path.is_absolute()
```

## Comparing `experimaestro/tests/test_tags.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_tags.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,21 +1,19 @@
 from typing import Dict
 from pathlib import Path
 from experimaestro import (
     tag,
     config,
     argument,
-    pathgenerator,
-    Annotated,
     Config,
     Task,
     Param,
 )
+from experimaestro.scheduler.workspace import RunMode
 from experimaestro.xpmutils import DirectoryContext
-from experimaestro.tests.utils import TemporaryExperiment
 
 
 @argument("x", type=int)
 @config()
 class Config1:
     pass
 
@@ -55,58 +53,36 @@
         outputs: Param[Dict[str, Output]]
 
     class Evaluate(Task):
         task: Param[MyTask]
 
     output = Output().tag("hello", "world")
     task = MyTask(outputs={}, mainoutput=output)
-    task.submit(dryrun=True)
+    task.submit(run_mode=RunMode.DRY_RUN)
     assert output.tags() == {"hello": "world"}
 
     output = Output().tag("hello", "world")
     task = MyTask(outputs={"a": output}, mainoutput=Output())
-    task.submit(dryrun=True)
+    task.submit(run_mode=RunMode.DRY_RUN)
     assert output.tags() == {"hello": "world"}
 
-    evaluate = Evaluate(task=task).submit(dryrun=True)
+    evaluate = Evaluate(task=task).submit(run_mode=RunMode.DRY_RUN)
     assert evaluate.__xpm__.tags() == {"hello": "world"}
 
 
 class TaskDirectoryContext(DirectoryContext):
     def __init__(self, task, path):
         super().__init__(path)
         self._task = task
 
     @property
     def task(self):
         return self._task
 
 
-def test_objects_nested_tags():
-    """Tags should be propagated to nested output configurations"""
-
-    class B(Config):
-        p: Annotated[Path, pathgenerator("p.txt")]
-
-    class A(Task):
-        x: Param[int]
-        b: Param[B]
-
-    a = A(x=tag(1), b=B())
-    with TemporaryExperiment("nested_tags"):
-        # context = TaskDirectoryContext(a, Path("/__fakepath__"))
-        output = a.submit(dryrun=True)
-
-    # Tags of main object...
-    assert a.__xpm__.tags() == {"x": 1}
-
-    # ...should be propagated to output configurations
-    assert output.b.__xpm__.tags() == {"x": 1}
-
-
 def test_objects_tags():
     """Test tags"""
 
     class A(Config):
         x: Param[int]
 
     context = DirectoryContext(Path("/__fakepath__"))
```

## Comparing `experimaestro/tests/test_tokens.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_tokens.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,17 @@
-import multiprocessing
 import sys
-from typing import Counter
+import json
 import fasteners
 import pytest
 import logging
 import time
 from pathlib import Path
 
 import subprocess
-from experimaestro import task, param
+from experimaestro import Task, param
 from experimaestro.tokens import CounterToken, TokenFile
 from experimaestro.scheduler import JobState
 from .utils import (
     TemporaryExperiment,
     TemporaryDirectory,
     timeout,
     get_times,
@@ -40,55 +39,54 @@
 
     # Wait that both tasks are scheduled
     logging.info("Waiting that the two tasks are scheduled")
     for task in tasks:
         while task.__xpm__.job.state == JobState.UNSCHEDULED:
             time.sleep(0.01)
 
-    # Wait a bit (TODO: find a better way)
+    # Wait a bit (ENHANCE: find a better way)
     time.sleep(1)
 
     # Now any task can finish
-    logging.info("Tasks scheduled - waiting for completion")
+    logging.info("%d tasks scheduled - waiting for completion", ntasks)
     path.write_text("Hello world")
 
     xp.wait()
 
     times = [get_times(task) for task in tasks]
     logging.info("Times: %s", ",".join([str(t) for t in times]))
     times = sorted(times)
     for i in range(1, ntasks):
         assert (times[i - 1] > times[i]) or (times[i] > times[i - 1])
 
 
 @pytest.mark.xfail(strict=True)
 def test_token_fail():
     """Simple token test: should fail without token"""
-    with TemporaryExperiment("tokens", maxwait=10) as xp:
+    with TemporaryExperiment("tokens", maxwait=20) as xp:
         token_experiment(xp, None)
 
 
 def test_token_ok():
     """Simple token test: should succeed with token"""
-    with TemporaryExperiment("tokens", maxwait=10) as xp:
+    with TemporaryExperiment("tokens", maxwait=20) as xp:
         token = CounterToken("token-ok", xp.workdir / "token", 1)
         token_experiment(xp, token)
     logging.info("Finished token_ok test")
 
 
 @param("x", type=int)
-@task()
-class dummy_task:
+class dummy_task(Task):
     def execute(self):
         pass
 
 
 def test_token_cleanup():
     """Test that tokens are correctly cleaned up if the process finished"""
-    with TemporaryExperiment("token_cleanup", maxwait=10) as xp:
+    with TemporaryExperiment("token_cleanup", maxwait=20) as xp:
         token = CounterToken("token-cleanup", xp.workdir / "token-cleanup", 1)
 
         task = dummy_task(x=1)
         dependency = token.dependency(1)
         task.add_dependencies(dependency)
         # Just to create the directory
         task.submit()
@@ -113,15 +111,15 @@
             command = [
                 sys.executable,
                 Path(__file__).parent / "scripts" / "waitforfile.py",
                 lockingpath,
             ]
 
             p1 = subprocess.Popen(command)
-            job.pidpath.write_text(str(p1.pid))
+            job.pidpath.write_text(json.dumps({"pid": p1.pid, "type": "local"}))
 
             task3 = dummy_task(x=3)
             task3.add_dependencies(token.dependency(1)).submit()
 
             # Ends the script "waitforfile.py"
             lockingpath.write_text("Let's go")
 
@@ -136,16 +134,16 @@
     """
 
     def run(xp, x, path):
         token = xp.workspace.connector.createtoken("test-token-monitor", 1)
         task = TokenTask(path=path, x=x).add_dependencies(token.dependency(1)).submit()
         return task
 
-    with TemporaryExperiment("tokens1", maxwait=10) as xp1, TemporaryExperiment(
-        "tokens2", maxwait=10
+    with TemporaryExperiment("tokens1", maxwait=20, port=0) as xp1, TemporaryExperiment(
+        "tokens2", maxwait=20
     ) as xp2:
         path = xp1.workspace.path / "test_token.file"
         task1 = run(xp1, 1, path)
         task2 = run(xp2, 2, path)
 
         time.sleep(0.5)
         path.write_text("Hello world")
@@ -156,55 +154,70 @@
         time2 = get_times(task2)
 
         logging.info("%s vs %s", time1, time2)
         assert time1 > time2 or time2 > time1
 
 
 def test_token_reschedule():
-    """Test whether a job can be re-submitted if it failed to acquire a token due to multiple schedulers concurrency
+    """Test whether a job can be re-submitted if it failed to acquire a token
+    due to multiple schedulers concurrency
 
     - task 1 and 2 are started in two different processes, using the token
     - we wait for both to be scheduled
     - we write a file so that both can finish
     """
-    queue1 = multiprocessing.Queue(3)
-    queue2 = multiprocessing.Queue(3)
+    # queue1 = multiprocessing.Queue(3)
+    # queue2 = multiprocessing.Queue(3)
 
     with TemporaryDirectory("reschedule") as workdir:
         lockingpath = workdir / "lockingpath"
 
         command = [
             sys.executable,
             Path(__file__).parent / "token_reschedule.py",
             workdir,
         ]
 
         ready1 = workdir / "ready.1"
         time1 = workdir / "time.1"
         p1 = subprocess.Popen(command + ["1", lockingpath, str(ready1), str(time1)])
 
-        ready2 = workdir / "ready.1"
+        ready2 = workdir / "ready.2"
         time2 = workdir / "time.2"
         p2 = subprocess.Popen(command + ["2", lockingpath, str(ready2), str(time2)])
 
         try:
             with timeout(20):
+                logging.info("Waiting for both experiments to be ready")
                 # Wait that both processes are ready
                 while not ready1.is_file():
                     time.sleep(0.01)
                 while not ready2.is_file():
                     time.sleep(0.01)
-                logging.info("Both processes are ready: allowing tasks to finish")
+
+                # Create the locking path
+                logging.info(
+                    "Both processes are ready:"
+                    "allowing tasks to finish by writing in %s",
+                    lockingpath,
+                )
                 lockingpath.write_text("Let's go")
 
                 # Waiting for the output
+                logging.info("Waiting for XP1 to finish (%s)", time1)
                 while not time1.is_file():
                     time.sleep(0.01)
+                logging.info("Experiment 1 finished")
+
+                logging.info("Waiting for XP2 to finish")
                 while not time2.is_file():
                     time.sleep(0.01)
+                logging.info("Experiment 2 finished")
+
+                logging.info("Both processes are ready: allowing tasks to finish")
 
                 time1 = get_times_frompath(time1)
                 time2 = get_times_frompath(time2)
 
                 logging.info("%s vs %s", time1, time2)
                 assert time1 > time2 or time2 > time1
         except TimeoutError:
@@ -215,15 +228,15 @@
         except Exception:
             logging.warning("Other exception: killing processes (just in case)")
             p1.terminate()
             p2.terminate()
             pytest.fail("Other exception")
 
 
-@pytest.mark.skip("TODO: not implemented")
+@pytest.mark.skip("ENHANCE: not implemented")
 def test_token_process():
     """Test tokens with two processes"""
     raise NotImplementedError()
 
 
 def restart_function(xp):
     token = CounterToken("restart-token", xp.workdir / "token", 1)
```

## Comparing `experimaestro/tests/test_types.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_types.py`

 * *Files identical despite different names*

## Comparing `experimaestro/tests/test_validation.py` & `experimaestro-1.0.0/src/experimaestro/tests/test_validation.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,25 +1,27 @@
 """Tests for type validation"""
 
 import pytest
 from pathlib import Path
 from experimaestro import (
     config,
-    task,
+    Task,
     Identifier,
     argument,
     pathoption,
     ConstantParam,
-    experiment,
+    Param,
+    Config,
 )
+from enum import Enum
 import experimaestro.core.types as types
 from experimaestro.scheduler import Job, JobContext
+from experimaestro.scheduler.workspace import RunMode
 from .utils import TemporaryExperiment
 from experimaestro.xpmutils import EmptyContext
-import logging
 
 valns = Identifier("validation")
 
 
 def expect_validate(value):
     value.__xpm__.validate()
 
@@ -114,19 +116,18 @@
     class A:
         pass
 
     a = A()
     a.__xpm__.validate()
     with TemporaryExperiment("constant") as xp:
         jobcontext = Job(a)
-        a.__xpm__.seal(jobcontext)
+        a.__xpm__.seal(JobContext(jobcontext))
         assert isinstance(a.value, Path)
-        parents = list(a.value.parents)
         assert a.value.name == "file.txt"
-        assert a.value.parents[0].name == a.__xpm__.identifier.hex()
+        assert a.value.parents[0].name == a.__xpm__.identifier.all.hex()
         assert a.value.parents[1].name == str(a.__xpmtype__.identifier)
         assert a.value.parents[2].name == "jobs"
         assert a.value.parents[3] == xp.workspace.path
 
 
 def test_constant():
     """Test of @ConstantParam"""
@@ -134,15 +135,15 @@
     @ConstantParam("value", 1)
     @config(valns.constant.a)
     class A:
         pass
 
     a = A()
     a.__xpm__.validate()
-    with TemporaryExperiment("constant") as ws:
+    with TemporaryExperiment("constant"):
         joba = Job(a)
         a.__xpm__.seal(JobContext(joba))
         assert a.value == 1
 
 
 @argument("x", type=int)
 @config()
@@ -164,15 +165,15 @@
 
 @pathoption("x", "x")
 @config()
 class PathParent:
     pass
 
 
-def test_path():
+def test_path_option():
     c = PathParent()
     expect_validate(c)
 
 
 # --- Default value
 
 
@@ -202,31 +203,46 @@
     a = A(a=2)
     a.__xpm__.seal(EmptyContext())
 
     with pytest.raises(AttributeError):
         a.a = 1
 
 
+def test_validation_enum():
+    """Path arguments should be ignored"""
+
+    class EnumParam(Enum):
+        FIRST = 0
+        SECOND = 1
+
+    class EnumConfig(Config):
+        a: Param[EnumParam]
+
+    expect_validate(EnumConfig(a=EnumParam.FIRST))
+
+    try:
+        EnumConfig(a=1)
+        assert False, "Enum value should be rejected"
+    except AssertionError:
+        pass
+
+
 # --- Task as argument
 
 
-@config()
-class TaskParentConfig:
+class TaskParentConfig(Config):
     pass
 
 
-@task()
-class taskconfig(TaskParentConfig):
+class taskconfig(TaskParentConfig, Task):
     pass
 
 
-@argument("x", type=TaskParentConfig)
-@config()
-class TaskConfigConsumer:
-    pass
+class TaskConfigConsumer(Config):
+    x: Param[TaskParentConfig]
 
 
 def test_taskargument():
     x = taskconfig()
     with TemporaryExperiment("fake"):
-        x.submit(dryrun=True)
+        x.submit(run_mode=RunMode.DRY_RUN)
         expect_validate(TaskConfigConsumer(x=x))
```

## Comparing `experimaestro/tests/utils.py` & `experimaestro-1.0.0/src/experimaestro/tests/utils.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-from contextlib import contextmanager
 import tempfile
 import shutil
 import os
 from pathlib import Path
 import logging
 import signal
-import pytest
 
-from experimaestro.launchers import Launcher
 from experimaestro import experiment, task
+from experimaestro.scheduler.workspace import RunMode
 
 
 class TimeInterval:
     def __init__(self, start, end):
         self.start = start
         self.end = end
 
@@ -23,17 +21,17 @@
         return "%.4f - %.4f" % (self.start, self.end)
 
     def __repr__(self):
         return str(self)
 
 
 def get_times(task: task) -> TimeInterval:
-    logging.info("Reading times from %s", task.__xpm__.stdout())
+    logging.info("Reading times from %s", task.stdout())
     return TimeInterval(
-        *(float(t) for t in task.__xpm__.stdout().read_text().strip().split("\n"))
+        *(float(t) for t in task.stdout().read_text().strip().split("\n"))
     )
 
 
 def get_times_frompath(path) -> TimeInterval:
     s = path.read_text().strip().split("\n")
     logging.info("Read times: %s", s)
     return TimeInterval(*(float(t) for t in s))
@@ -52,70 +50,90 @@
         )
         return self.path
 
     def __exit__(self, exc_type, exc_value, traceback):
         if os.environ.get("XPM_KEEPWORKDIR", False) == "1":
             logging.warning("NOT Removing %s" % self.path)
         else:
-            logging.warning("CLLLLLEAEANING UP %s", self.path)
+            logging.warning(
+                "Cleaning up working directory %s"
+                " (use XPM_KEEPWORKDIR=1 to keep it)",
+                self.path,
+            )
             shutil.rmtree(self.path, ignore_errors=True)
 
 
 class timeout:
     def __init__(self, seconds, error_message=None):
         if error_message is None:
             error_message = "test timed out after {}s.".format(seconds)
         self.seconds = seconds
         self.error_message = error_message
 
     def handle_timeout(self, signum, frame):
         logging.error("Timeout - sending signal")
+        import faulthandler
+
+        faulthandler.dump_traceback()
         raise TimeoutError(self.error_message)
 
     def __enter__(self):
         signal.signal(signal.SIGALRM, self.handle_timeout)
         signal.alarm(self.seconds)
 
     def __exit__(self, exc_type, exc_val, exc_tb):
         signal.alarm(0)
 
 
 class TemporaryExperiment:
-    def __init__(self, name, workdir=None, maxwait=10):
+    def __init__(
+        self,
+        name,
+        workdir=None,
+        maxwait=20,
+        port=None,
+        run_mode: RunMode = RunMode.NORMAL,
+    ):
         self.name = name
         self.workdir = workdir
         self.clean_workdir = workdir is None
-        self.timeout = timeout(maxwait)
+        self.timeout = timeout(maxwait) if maxwait > 0 else 0
+        self.port = port
+        self.run_mode = run_mode
 
-    def __enter__(self):
+    def __enter__(self) -> experiment:
         if self.clean_workdir:
             self.workdir = TemporaryDirectory(prefix="xpm", suffix=self.name)
             workdir = self.workdir.__enter__()
         else:
             workdir = self.workdir
 
-        self.experiment = experiment(workdir, self.name)
+        self.experiment = experiment(
+            workdir, self.name, port=self.port, run_mode=self.run_mode
+        )
         self.experiment.__enter__()
 
         # Set some useful environment variables
         self.experiment.workspace.launcher.setenv(
             "PYTHONPATH", str(Path(__file__).parents[2])
         )
-        self.timeout.__enter__()
+        if self.timeout:
+            self.timeout.__enter__()
 
         logging.info("Created new temporary experiment (%s)", workdir)
         return self.experiment
 
     def __exit__(self, *args):
         self.experiment.__exit__(*args)
-        self.timeout.__exit__(*args)
+        if self.timeout:
+            self.timeout.__exit__(*args)
         if self.clean_workdir:
             self.workdir.__exit__(*args)
 
 
 def is_posix():
     try:
-        import posix
+        import posix  # noqa: F401
 
         return True
     except ImportError:
         return False
```

## Comparing `experimaestro/tests/connectors/test_local.py` & `experimaestro-1.0.0/src/experimaestro/tests/connectors/test_local.py`

 * *Files identical despite different names*

## Comparing `experimaestro/tests/connectors/utils.py` & `experimaestro-1.0.0/src/experimaestro/tests/connectors/utils.py`

 * *Files identical despite different names*

## Comparing `experimaestro/tests/launchers/test_slurm.py` & `experimaestro-1.0.0/src/experimaestro/tests/launchers/test_slurm.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,64 +1,86 @@
 from pathlib import Path
 import sys
 from experimaestro.connectors import Redirect
+from experimaestro.tests.utils import TemporaryExperiment
 from experimaestro.connectors.local import LocalConnector
-from experimaestro.launchers.slurm import SlurmLauncher
-from experimaestro.tests.utils import TemporaryDirectory
+from experimaestro.launchers.slurm import (
+    SlurmLauncher,
+)
+import shutil
 import pytest
+from .common import waitFromSpec, takeback
 
-binpath = Path(__file__).parent / "bin"
+BINPATH = Path(__file__).parent / "bin"
 
 
 @pytest.fixture(scope="session")
 def slurmlauncher(tmp_path_factory):
     tmpdir = tmp_path_factory.mktemp("slurm-launcher")
-    env = {"XPM_SLURM_DIR": str(tmpdir)}
+    assert tmpdir.is_dir()
+
+    binpath = tmpdir / "bin"
+    (tmpdir / "slurm").mkdir()
+    shutil.copytree(BINPATH, binpath)
+
     launcher = SlurmLauncher(
         connector=LocalConnector.instance(),
         binpath=binpath,
-        launcherenv=env,
-        interval=0.1,
+        interval=0.01,
     )
     yield launcher
 
 
 @pytest.mark.timeout(10)
-def test_slurm_ok(slurmlauncher):
+def test_slurm_ok(slurmlauncher: SlurmLauncher):
     builder = slurmlauncher.processbuilder()
-    builder.command = [sys.executable, binpath / "test.py"]
+    builder.command = [sys.executable, slurmlauncher.binpath / "test.py"]
     p = builder.start()
     assert p.wait() == 0
 
 
 @pytest.mark.timeout(10)
-def test_slurm_failed(slurmlauncher):
+def test_slurm_failed(slurmlauncher: SlurmLauncher):
     builder = slurmlauncher.processbuilder()
-    builder.command = [sys.executable, binpath / "test.py", "--fail"]
+    builder.command = [sys.executable, slurmlauncher.binpath / "test.py", "--fail"]
     p = builder.start()
     assert p.wait() == 1
 
 
 @pytest.mark.timeout(10)
-def test_slurm_config(tmp_path, slurmlauncher):
+def test_slurm_config(tmp_path, slurmlauncher: SlurmLauncher):
     """Test that sbatch is called properly"""
     options = {
         "nodes": 2,
         "gpus_per_node": 3,
         "time": 4,
     }
     launcher = slurmlauncher.config(**options)
     builder = launcher.processbuilder()
 
     outpath = tmp_path / "out.txt"
     builder.stdout = Redirect.file(outpath)
-    builder.command = [sys.executable, binpath / "test.py"]
+    builder.command = [sys.executable, slurmlauncher.binpath / "test.py"]
     p = builder.start()
     assert p.wait() == 0
 
     gotoptions = {}
     for line in outpath.read_text().split("\n"):
         if line != "":
             key, value = line.split("=")
             gotoptions[key] = value
 
     assert gotoptions == {key: str(value) for key, value in options.items()}
+
+
+@pytest.mark.timeout(3)
+def test_slurm_batchprocess(tmp_path: Path, slurmlauncher: SlurmLauncher):
+    waitFromSpec(tmp_path, slurmlauncher)
+
+
+def test_slurm_takeback(slurmlauncher, tmp_path):
+    """Test whether a task can be taken back when running"""
+    txp1 = TemporaryExperiment("slurm-takeback-1", workdir=tmp_path / "xp")
+    txp2 = TemporaryExperiment("slurm-takeback-2", workdir=tmp_path / "xp")
+    datapath = tmp_path / "data"
+
+    takeback(slurmlauncher, datapath, txp1, txp2)
```

## Comparing `experimaestro/tests/launchers/bin/sbatch` & `experimaestro-1.0.0/src/experimaestro/tests/launchers/bin/sbatch`

 * *Files 23% similar despite different names*

```diff
@@ -1,15 +1,19 @@
 #!/bin/bash
 
 # slurm test suite
 
 # Where we store the jobs
-test -z "$XPM_SLURM_DIR" && exit 1
-mkdir -p "$XPM_SLURM_DIR/jobs"
+XPM_SLURM_DIR="$(realpath "$(dirname "$0")"/..)/slurm"
+if ! test -d "$XPM_SLURM_DIR"; then
+    echo "Directory $XPM_SLURM_DIR does not exist" 1>&2
+    exit 1
+fi
 
+mkdir -p "$XPM_SLURM_DIR/jobs"
 echo "Slurm directory: $XPM_SLURM_DIR" >&2 
 
 lockpath() {
     fid="$1"
     path="$2"
 
     echo "Locking $path..." 1>&2
@@ -22,25 +26,27 @@
 
 lockpath 9 "$XPM_SLURM_DIR/slurm.lock"
 
 echo "Command line: $@" >&2
 args=()
 parsable=0
 stdout="/dev/stdout"
+stderr="/dev/stdout"
 while true; do
     case "$1" in
         --parsable) shift; parsable=1;;
         -o) shift; stdout="$1"; shift;;
+        -e) shift; stderr="$1"; shift;;
         --*) args+=("$1"); shift;;
         *) break 2;;    
     esac
 done
 
 echo "Starting $@ ${args[@]} > $stdout" >&2
-(eval "$@" "${args[@]}" > $stdout; echo $? > "$XPM_SLURM_DIR/jobs/$$.status") & 
+(eval "$@" "${args[@]}"; echo $? > "$XPM_SLURM_DIR/jobs/$$.status") > $stdout 2> $stderr & 
 JOBID="$$"
 date > "$XPM_SLURM_DIR/jobs/$JOBID.start"
 disown
 
 if test "$parsable" == 0; then
     echo "Submitted batch job ${JOBID}"
 else
```

## Comparing `experimaestro/tests/tasks/all.py` & `experimaestro-1.0.0/src/experimaestro/tests/tasks/all.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,112 +1,98 @@
 import time
 from typing import List
 from experimaestro import (
     param,
     Param,
-    config,
-    task,
+    Task,
+    Config,
     pathoption,
-    Identifier,
     STDOUT,
     cache,
 )
 
-tasks = Identifier("tasks")
 
-
-@task()
-class SimpleTask:
+class SimpleTask(Task):
     x: Param[int]
 
     def execute(self):
-        print(self.x)
+        print(self.x)  # noqa: T201
 
 
 @pathoption("out", STDOUT)
-@task(tasks.say)
-class Say:
+class Say(Task):
     word: Param[str]
 
     def execute(self):
         self.out.write_text(self.word.upper())
 
 
-@task(tasks.concat)
-class Concat:
+class Concat(Task):
     strings: Param[List[Say]]
 
     def execute(self):
         # We access the file where standard output was stored
         says = []
         for string in self.strings:
             with open(string.out) as fp:
                 says.append(fp.read().strip())
-        print(" ".join(says))
+        print(" ".join(says))  # noqa: T201
 
 
 @param("x", type=int)
-@config()
-class ForeignClassB1:
+class ForeignClassB1(Config):
     pass
 
 
 @param("b", type=ForeignClassB1)
-@task()
-class ForeignTaskA:
+class ForeignTaskA(Task):
     def execute(self):
-        print(self.b.x)
+        print(self.b.x)  # noqa: T201
 
 
 @pathoption("wait", "wait")
-@task(tasks.fail)
-class Fail:
+class Fail(Task):
     def execute(self):
         while not self.wait.is_file():
-            time.sleep(0.1)
+            time.sleep(0.01)
         raise AssertionError("Failing")
 
     def touch(self):
         while self.__xpm__.job.state.notstarted():
-            time.sleep(0.05)
+            time.sleep(0.01)
 
         with open(self.wait, "w") as out:
             out.write("hello")
 
 
 @param("fail", Fail)
-@task(tasks.failconsumer)
-class FailConsumer:
+class FailConsumer(Task):
     def execute(self):
         return True
 
 
 @param("a", int)
-@task(tasks.method)
-class Method:
+class Method(Task):
     def execute(self):
         assert self.a == 1
 
 
-@task(tasks.setunknown)
-class SetUnknown:
+class SetUnknown(Task):
     def execute(self):
         self.abc = 1
 
 
 """Check that config works properly"""
 
 
-@config()
-class CacheConfig:
+class CacheConfig(Config):
     @cache("cached")
     def get(self, path):
         if not path.is_file():
             path.write_text("hello")
         return path.read_text()
 
 
 @param("data", type=CacheConfig)
-@task()
-class CacheConfigTask:
+class CacheConfigTask(Task):
     def execute(self):
         assert self.data.get() == "hello"
```

## Comparing `experimaestro/utils/__init__.py` & `experimaestro-1.0.0/src/experimaestro/utils/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -23,14 +23,26 @@
             else:
                 p.unlink()
 
     path.mkdir(exist_ok=True, parents=True)
     return path
 
 
+def is_notebook():
+    """Returns true if running in a notebook"""
+    try:
+        shell = get_ipython().__class__.__module__  # noqa: F841
+        if shell is not None and shell in ["ipykernel.zmqshell", "google.colab._shell"]:
+            return True
+    except NameError:
+        pass
+
+    return False
+
+
 class ThreadingCondition(threading.Condition):
     # Useful to debug lock problems
     TIMEOUT = float(os.environ.get("XPM_LOCK_TIMEOUT", "-1"))
 
     """Wrapper of threading.condition allowing to debug"""
 
     def __enter__(self) -> bool:
```

## Comparing `experimaestro/utils/jupyter.py` & `experimaestro-1.0.0/src/experimaestro/utils/jupyter.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 from typing import Callable, Dict, Optional
+import uuid
 import ipywidgets as widgets
 from experimaestro import experiment
 from IPython.display import display
 from .jobs import jobmonitor  # noqa: F401
 
 
 class serverwidget:
+    TOKEN = uuid.uuid4().hex
+
     def __init__(
         self,
         name,
         *,
         port=12345,
         hook: Callable[["serverwidget"], None] = None,
         environment: Optional[Dict[str, str]] = None,
@@ -28,30 +31,37 @@
         self.refresh()
 
     def refresh(self):
         self.output.clear_output()
         with self.output:
             if experiment.CURRENT:
                 self.button.description = "Stop experimaestro server"
-                print(f"Server started : http://localhost:{self.port}")
+                print(  # noqa: T201
+                    "Server started : "
+                    f"http://localhost:{self.port}/auth?xpm-token={serverwidget.TOKEN}"
+                )
             else:
                 self.button.description = "Start experimaestro server"
-                print("Server stopped")
+                print("Server stopped")  # noqa: T201
 
     def on_button_clicked(self, b):
         with self.output:
             if experiment.CURRENT:
                 try:
                     experiment.CURRENT.__exit__(None, None, None)
                 except Exception:
-                    print("Error while stopping experimaestro")
+                    print("Error while stopping experimaestro")  # noqa: T201
                 self.current = experiment.CURRENT
             else:
                 self.current = experiment(
-                    self.name, self.name, host="localhost", port=self.port
+                    self.name,
+                    self.name,
+                    host="localhost",
+                    port=self.port,
+                    token=serverwidget.TOKEN,
                 ).__enter__()
                 for key, value in self.environment.items():
                     self.current.setenv(key, value)
                 if self.hook:
                     self.hook(self)
 
         self.refresh()
```

## Comparing `experimaestro/utils/settings.py` & `experimaestro-1.0.0/src/experimaestro/utils/settings.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 from pathlib import Path
 import marshmallow as mm
 
-class JsonSettings():   
+
+class JsonSettings:
     @classmethod
     def load(cls, path: Path):
         if path.is_file():
             settings = cls.SCHEMA().loads(path.read_text())
         else:
             settings = cls()
         settings.path = path
```

## Comparing `experimaestro-0.9.9.dist-info/LICENSE` & `experimaestro-1.0.0/LICENSE`

 * *Files identical despite different names*

